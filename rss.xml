<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>踏步而行</title>
        <link>http://www.songx.fun/</link>
        <description>MemE 是一个强大且可高度定制的 GoHugo 博客主题，专为个人博客设计。</description>
        <generator>Hugo 0.97.3 https://gohugo.io/</generator>
        
            <language>zh-CN</language>
        
        
            <managingEditor>245935836@163.com (songx)</managingEditor>
        
        
            <webMaster>245935836@163.com (songx)</webMaster>
        
        
            <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
        
        <lastBuildDate>Fri, 19 Aug 2022 18:15:43 &#43;0800</lastBuildDate>
        
            <atom:link rel="self" type="application/rss&#43;xml" href="http://www.songx.fun/rss.xml" />
        
        
            <item>
                <title>beego框架介绍和流程分析</title>
                <link>http://www.songx.fun/blog/day36-37beego%E6%A1%86%E6%9E%B6/day36_beego%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day36-37beego%E6%A1%86%E6%9E%B6/day36_beego%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;beego框架介绍和流程分析&#34;&gt;beego框架介绍和流程分析&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从今天开始，我们开始进入一个新的阶段的学习。从今天开始我们开始一个新的框架知识的学习--GoWeb开发之Beego实战项目。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;beego官方文档：&lt;a href=&#34;https://beego.me/&#34;&gt;https://beego.me/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;一beego框架介绍&#34;&gt;一、beego框架介绍&lt;/h1&gt;
&lt;h2 id=&#34;11-beego框架介绍--beego简介&#34;&gt;1.1 beego框架介绍--beego简介&lt;/h2&gt;
&lt;h4 id=&#34;111-什么是beego&#34;&gt;1.1.1 什么是beego&lt;/h4&gt;
&lt;p&gt;beego是一个使用Go语言来开发WEB引用的GoWeb框架，该框架起始于2012年，由一位中国的程序员编写并进行公开，其目的就是为大家提供一个高效率的web应用开发框架。该框架采用模块封装，使用简单，容易学习。方便技术开发者快速学习并进行实际开发。对程序员来说，beego掌握起来非常简单，只需要关注业务逻辑实现即可，框架自动为项目需求提供不同的模块功能。&lt;/p&gt;
&lt;p&gt;在对beego框架有了一个简单基本的了解之后，我们给大家介绍一下beego的一些特性。&lt;/p&gt;
&lt;h4 id=&#34;112-beego框架特性&#34;&gt;1.1.2 beego框架特性&lt;/h4&gt;
&lt;p&gt;Beego框架的主要特性：&lt;/p&gt;
&lt;p&gt;**1）简单化：**RESTful支持，MVC模型；可以使用bee工具来提高开发效率，比如监控代码修改进行热编译，自动化测试代码，以及自动化打包部署等丰富的开发调试功能。&lt;/p&gt;
&lt;p&gt;**2）智能化：**beego框架封装了路由模块，支持智能路由，智能监控，并可以监控内存消耗，CPU使用以及goroutine的运行状况，方便开发者对线上应用进行监控分析。&lt;/p&gt;
&lt;p&gt;**3）模块化：**beego根据功能对代码进行节耦封装，形成了Session，Cache，Log，配置解析，性能监控，上下文操作，ORM等独立的模块，方便开发者进行使用。&lt;/p&gt;
&lt;p&gt;**4）高性能：**beego采用Go原生的http请求，goroutine的并发效率应付大流量的Web应用和API应用。&lt;/p&gt;
&lt;p&gt;大家需要记住beego的几个特性，一方面在面试过程中，如果有面试官问起大家关于goweb开发的相关知识的时候，有可能问beego框架有优势或者有什么特点，这个时候需要大家能够对beego框架这些特点做一个介绍；另一方面，咱们在后面实际的学习和编码过程中，大家感受一下这些特性在实际项目中为我们带来的便利和高效。&lt;/p&gt;
&lt;h2 id=&#34;12-beego框架介绍--beego安装&#34;&gt;1.2 beego框架介绍--beego安装&lt;/h2&gt;
&lt;p&gt;在对beego的特点做了简单了解之后，我们就真正开始来搭建beego的环境，开始进入实际的编码阶段。&lt;/p&gt;
&lt;p&gt;首先我们进行beego源码的安装。说到beego的源码安装，这里需要我们使用一个命令，这个命令之前大家应该都接触过吧？我们使用go get命令来进行beego的安装。&lt;/p&gt;
&lt;h4 id=&#34;121-go语言版本要求&#34;&gt;1.2.1 Go语言版本要求&lt;/h4&gt;
&lt;p&gt;**【注意】：**在安装的时候，有一点大家要注意，beego框架要求Go 语言版本1.1+以上，这个我们大家的版本应该至少也是1.9的吧，应该都没有。或者大家现在在命令行中，执行go version查看一下自己的go语言版本，如下所示：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190515-154819@2x.png&#34; alt=&#34;Go语言版本&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图显示，本地环境go语言版本就是1.10.4版本。&lt;/p&gt;
&lt;h4 id=&#34;122-beego安装命令&#34;&gt;1.2.2 beego安装命令&lt;/h4&gt;
&lt;p&gt;现在，我们来执行安装命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go get github.com/astaxie/beego
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等待go将源代码下载安装完毕，我们就可以在我们自己设置的GOPATH下面的src目录下找到beego框架源码。&lt;/p&gt;
&lt;h4 id=&#34;123-编写第一个beego程序&#34;&gt;1.2.3 编写第一个beego程序&lt;/h4&gt;
&lt;p&gt;那么，我们首先来看一个最最简单的例子beego项目的例子，这个例子就一句话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、编写第一个beego示例项目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main
import &amp;quot;github.com/astaxie/beego&amp;quot;
func main() {
    beego.Info(&amp;quot;第一个beego案例&amp;quot;)
    beego.Run(&amp;quot;localhost:8080&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、编译&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go build -o hello hello.go
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./hello
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4、效果查询&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;访问浏览器http://localhost:8080
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们在浏览器当中进行访问:&lt;a href=&#34;http://localhost:8080&#34;&gt;http://localhost:8080&lt;/a&gt;，可以看到，在我们的浏览器当中出现了404，代表着页面没找到；这个很好理解，因为没有指定默认的页面，所以后台项目就不知道默认指向哪个页面路径，因此就提示404。但是，看后台打出了日志，这就说明，前端的请求确实到了后台main方法里面进行执行。&lt;/p&gt;
&lt;h2 id=&#34;13-beego框架介绍--命令行工具bee&#34;&gt;1.3 beego框架介绍--命令行工具Bee&lt;/h2&gt;
&lt;p&gt;现在，尝试来进行对代码进行修改，就简单的添加一行打印日志：beego.Info(&amp;quot;代码修改&amp;quot;)。这个时候，如果我们要想让代码生效，必须把原来正在执行的程序停止，然后重新执行编码和运行命令，我们来实际尝试一下。&lt;/p&gt;
&lt;p&gt;经过我们的尝试，我们可以发现，确实第二次的重新启动的程序打印出了两条后台日志，这说明我们修改的代码生效了。&lt;/p&gt;
&lt;p&gt;现在向大家引出beego的一个工具：&lt;strong&gt;bee&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;131-什么是bee&#34;&gt;1.3.1 什么是bee&lt;/h4&gt;
&lt;p&gt;bee是一个开发工具，是协助Beego框架开发项目时进行创建项目，运行项目，热部署等相关的项目管理的工具。beego是源码，负责开发，bee是工具，负责构建和管理项目。介绍beego的特性的时候说过其中一点beego支持代码热部署吧。所谓热部署就是，当修改代码的时候，可以不用停止服务重新启动，内置的beego就能够实时感知源代码程序编码，并进行实时生效，这就是热部署，这样就大大方便了开发人员和维护人员要频繁的进行服务停止，服务重启的过程。现在，来看看bee都有哪些功能，如何进行操作？&lt;/p&gt;
&lt;h4 id=&#34;132-bee安装&#34;&gt;1.3.2 bee安装&lt;/h4&gt;
&lt;p&gt;如同beego一样，如果要使用bee，首先要进行安装，同样的道理，先使用go get命令安装bee工具。bee安装命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go get github.com/beego/bee
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;133-bee常用功能命令&#34;&gt;1.3.3 bee常用功能命令&lt;/h4&gt;
&lt;p&gt;安装结束以后，进入到&lt;strong&gt;GOPATH&lt;/strong&gt;对应的目录中，然后进入到bin目录下，可以看到有bee这个可执行文件，这就是安装的bee工具的可执行文件，在该目录中，我们在终端中执行以下bee命令，然后回车，会发现列出很多关于bee的用法，如下图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;new命令：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;bee new ProjectName
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该命令表示新建一个全新的web项目，有一点需要注意：该命令必须在src目录下执行，才能生效，自动生成web项目的目录结构。如果在其他目录下面执行bee new命令，也同样会是在src目录下面生成对应新项目的目录结构，这是bee工具在构建项目的时候默认寻找创建的目录。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;api命令：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;bee api ProjectNames
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该命令表示用来创建开发API应用。很多用户写前端的后台接口也是通过go来写，因此bee专门提供了一个写api接口应用的命令。通过目录结构可以看到，和Web项目相比，API项目少了static和views目录，多了一个test目录，test是用来进行写测试用例代码的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;run命令：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;bee run 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令用来运行项目，并且能够通过监控文件系统，实时进行代码的热部署更新。也就是，我们代码逻辑进行了修改，不用停止应用，在前端页面就能看到改变。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pack命令：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;bee pack
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pack命令用来发布应用的时候的大包操作，该命令会把项目大包成zip包，然后我们就可以在部署的时候直接把大包后的项目上传到服务器，然后解压进行部署。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;version命令：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;bee version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;version命令来查看当前bee，beego，go的版本。&lt;/p&gt;
&lt;h2 id=&#34;14-beego框架介绍--使用bee工具&#34;&gt;1.4 beego框架介绍--使用Bee工具&lt;/h2&gt;
&lt;p&gt;常见的几个bee工具命令就是上面的几个，立即来练习使用一下。打开命令行终端，进入到GOPATH所对应的目录，然后进入到src目录中。&lt;/p&gt;
&lt;h4 id=&#34;141-使用bee创建项目&#34;&gt;1.4.1 使用bee创建项目&lt;/h4&gt;
&lt;p&gt;使用bee run命令来新建一个案例项目，比如我们新建一个BeegoDemo2的项目，我们执行命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;bee new BeegoDemo2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令执行效果如下：
&lt;img src=&#34;http://www.songx.fun/img/png/bee_new.png&#34; alt=&#34;bee新建项目&#34;&gt;
可以看到，终端中输出了bee的图标和版本，并且打印出了很多日志，创建了很多文件和目录。这就是bee new命令的执行效果，表示新建一个项目。&lt;/p&gt;
&lt;h4 id=&#34;142-查看项目结构&#34;&gt;1.4.2 查看项目结构&lt;/h4&gt;
&lt;p&gt;使用我们的开发公局goland来打开新建的BeegoDemo2项目，并查看一下项目目录组织结构：
&lt;img src=&#34;http://www.songx.fun/img/png/project_cont.png&#34; alt=&#34;查看项目结构&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;143-运行新建项目&#34;&gt;1.4.3 运行新建项目&lt;/h4&gt;
&lt;p&gt;现在使用bee命令来运行一下案例，看一下效果。在开发工具下方的terminal中，打开terminal，输入命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;bee run
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;144-项目运行效果&#34;&gt;1.4.4 项目运行效果&lt;/h4&gt;
&lt;p&gt;运行效果如下：
&lt;img src=&#34;http://www.songx.fun/img/png/bee_run.png&#34; alt=&#34;项目运行效果&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到输出日志说，http服务已经在&lt;a href=&#34;http://localhost:8080&#34;&gt;http://localhost:8080&lt;/a&gt;端口运行，现在我们去浏览器中验证一下，效果如下：
&lt;img src=&#34;http://www.songx.fun/img/png/project_show.png&#34; alt=&#34;浏览器效果&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;二beego程序流程分析&#34;&gt;二、beego程序流程分析&lt;/h1&gt;
&lt;h2 id=&#34;21-beego程序流程分析--beego程序入口&#34;&gt;2.1 beego程序流程分析--beego程序入口&lt;/h2&gt;
&lt;p&gt;Go语言执行的时候是执行main包下面的init函数，main函数依次执行。因此，先找到main.go文件。
&lt;img src=&#34;http://www.songx.fun/img/png/main_file.png&#34; alt=&#34;beego程序入口&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图就是main.go文件内容，那么代码如何执行呢？首先，import导入了两个包，一个是routers，一个是beego。而在routers包前面，可以看到有一个“_”，这表明是引入routers包，并执行init方法。&lt;/p&gt;
&lt;h2 id=&#34;22-beego程序流程分析--go语言程序执行顺序&#34;&gt;2.2 beego程序流程分析--Go语言程序执行顺序&lt;/h2&gt;
&lt;p&gt;这里涉及一个知识点，就是Go语言的执行过程，这里给大家一张程序执行流程图：
&lt;img src=&#34;http://www.songx.fun/img/png/main_init.png&#34; alt=&#34;Go语言程序执行顺序&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-beego程序流程分析--请求拦截与路由分发&#34;&gt;2.3 beego程序流程分析--请求拦截与路由分发&lt;/h2&gt;
&lt;p&gt;根据上图，可以得知程序首先到routers包下执行init方法。到router.go里面看一下具体的代码：
&lt;img src=&#34;http://www.songx.fun/img/png/router.png&#34; alt=&#34;router.go程序&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到在router.go文件中有一个init方法，看到beego.Router()这句代码。&lt;/p&gt;
&lt;h2 id=&#34;24-beego程序流程分析--控制器处理&#34;&gt;2.4 beego程序流程分析--控制器处理&lt;/h2&gt;
&lt;p&gt;router表示的是路由的意思，这个函数的功能是映射 URL 到 controller，第一个参数是 URL (用户请求的地址)，这里注册的是 /，也就是访问的不带任何参数的 URL，第二个参数是对应的 Controller，即将把请求分发到那个控制器来执行相应的逻辑，现在去这里设置的MainController中去看一下有什么方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/controller.png&#34; alt=&#34;控制器&#34;&gt;&lt;/p&gt;
&lt;p&gt;MainController结构体及函数声明在default.go文件中。而这里就看到一个Get方法，方法中有三行代码。&lt;/p&gt;
&lt;p&gt;上文在浏览器中访问的是：&lt;a href=&#34;http://localhost:8080&#34;&gt;http://localhost:8080&lt;/a&gt;，这是一个get请求，请求到了后台以后，什么请求参数都没有，因此，就会被“/”拦截，执行到MainController中的代码，因为是get请求，所以这里自动找到Get函数并进行执行。&lt;/p&gt;
&lt;p&gt;在get函数里面，有三句代码，前两句c.Data[]= &amp;quot;&amp;quot;表示设置返回的数据字段及内容，最后一句c.TplName表示设置处理该请求指向某个模板文件，这里指向了index.tpl，那么index.tpl文件在哪里呢？可以查看项目目录结构，在views下面，views下面存放一些模板文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模板文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单解释一下，通常的页面都是使用静态的html+css+js等这些静态代码来进行页面的布局，页面效果控制等，而把页面的数据使用变量表示，这样，在进行页面展示的时候，就能够自动的填充页面里面的变量的值；这些静态的代码文件统称为模板文件。每个模板文件就是像一个模板一样，样式效果都固定，只是根据数据不一样进行渲染和展示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;24-beego程序流程分析--beegorun逻辑&#34;&gt;2.4 beego程序流程分析--beego.Run()逻辑&lt;/h2&gt;
&lt;p&gt;init方法分析完毕后，程序会继续往下执行，就到了main函数，在main函数中执行：beego.Run()代码。分析一下Run代码的逻辑，在Run方法内部，主要做了几件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;解析配置文件，也就是我们的app.conf文件，比如端口，应用名称等信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查是否开启session，如果开启session，就会初始化一个session对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是否编译模板，beego框架会在项目启动的时候根据配置把views目录下的所有模板进行预编译，然后存放在map中，这样可以有效的提高模板运行的效率，不需要进行多次编译。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;监听服务端口。根据app.conf文件中的端口配置，启动监听。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E6%A1%86%E6%9E%B6/">框架</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>beego框架总结及数据库连接配置</title>
                <link>http://www.songx.fun/blog/day36-37beego%E6%A1%86%E6%9E%B6/day37_beego%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day36-37beego%E6%A1%86%E6%9E%B6/day37_beego%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;beego框架总结及数据库连接配置&#34;&gt;beego框架总结及数据库连接配置&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一beego框架总结&#34;&gt;一、beego框架总结&lt;/h2&gt;
&lt;h3 id=&#34;11-beego项目组织架构&#34;&gt;1.1 Beego项目组织架构&lt;/h3&gt;
&lt;p&gt;上节课程内容对beego的案例代码进行了一个简单的分析，总结一下beego项目的组织结构，总结如下：&lt;/p&gt;
&lt;h4 id=&#34;111-项目配置conf&#34;&gt;1.1.1 项目配置：conf&lt;/h4&gt;
&lt;p&gt;项目配置文件所在的目录，项目中有一些全局的配置都可以放在此目录下。默认的app.conf文件中默认指定了三个配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;appname = BeegoDemo2：** 指定项目名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;httpport = 8080：** 指定项目服务监听端口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;runmode = dev：** 指定执行模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;112-控制器controllers&#34;&gt;1.1.2 控制器：controllers&lt;/h4&gt;
&lt;p&gt;该目录是存放控制器文件的目录，所谓控制器就是控制应用调用哪些业务逻辑，由controllers处理完http请求以后，并负责返回给前端调用者。&lt;/p&gt;
&lt;h4 id=&#34;113-数据层models&#34;&gt;1.1.3 数据层：models&lt;/h4&gt;
&lt;p&gt;models层可以解释为实体层或者数据层，在models层中实现和用户和业务数据的处理，主要和数据库表相关的一些操作会在这一目录中实现，然后将执行后的结果数据返回给controller层。比如向数据库中插入新数据，删除数据库表数据，修改某一条数据，从数据库中查询业务数据等都是在models层实现。&lt;/p&gt;
&lt;h4 id=&#34;114-路由层routers&#34;&gt;1.1.4 路由层：routers：&lt;/h4&gt;
&lt;p&gt;该层是路由层。所谓路由就是分发的意思，当前端浏览器进行一个http请求达到后台web项目时，必须要让程序能够根据浏览器的请求url进行不同的业务处理，从接收到前端请求到判断执行具体的业务逻辑的过程的工作，就由routers来实现。&lt;/p&gt;
&lt;h4 id=&#34;115-静态资源目录static&#34;&gt;1.1.5 静态资源目录：static&lt;/h4&gt;
&lt;p&gt;在static目录下，存放的是web项目的静态资源文件，主要有：css文件，img，js，html这几类文件。html中会存放应用的静态页面文件。&lt;/p&gt;
&lt;h4 id=&#34;116-视图模板views&#34;&gt;1.1.6 视图模板：views&lt;/h4&gt;
&lt;p&gt;views中存放的就是应用中存放html模版页面的目录。所谓模版，就是页面框架和布局是已经使用html写好了的，只需要在进行访问和展示时，将获取到的数据动态填充到页面中，能够提高渲染效率。因此，模版文件是非常常见的一种方式。&lt;/p&gt;
&lt;p&gt;综上，这个整个的项目架构就是MVC的运行模式。常见的架构模式大家应该熟悉比如：MVC，MVP，MVVM等架构。这里我们采用MVC，比较清晰易懂。&lt;/p&gt;
&lt;h3 id=&#34;12-beego框架路由设置&#34;&gt;1.2 beego框架路由设置&lt;/h3&gt;
&lt;p&gt;在beego框架中，支持四种路由设置，他们分别是：&lt;strong&gt;基础路由&lt;/strong&gt;，&lt;strong&gt;固定路由&lt;/strong&gt;，&lt;strong&gt;正则路由&lt;/strong&gt;和&lt;strong&gt;自动路由&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;121-基础路由&#34;&gt;1.2.1 基础路由：&lt;/h4&gt;
&lt;p&gt;直接通过beego.Get,beego.POST,beego.Head,beego.Delete等方法来进行路由的映射，我们通过代码给大家来进行演示。我们知道，常见的http请求方法操作有：GET，HEAD，PUT，POST，DELETE，OPTIONS等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GET路由
首先是基础的GET路由。下面我们通过例子来向大家进行展示。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;beego.GET(&amp;quot;&amp;quot;,func)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POST路由：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;beego.POST(&amp;quot;&amp;quot;,func)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除此之外，还支持Patch，Head，Delete等基础路由。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上这种请求和对应找到请求方法类型的方式就是RESTful形式，我们最常用的也是RESTful形式
RESTful是目前开发API中非常常用的一种形式，其实就是RESTful形式就是用户是get请求时就自动执行Get方法，Post请求就执行Post方法。&lt;/p&gt;
&lt;h4 id=&#34;122-固定路由&#34;&gt;1.2.2 固定路由：&lt;/h4&gt;
&lt;p&gt;诸如以下此种代码形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;beego.Router(&amp;quot;/&amp;quot;,controller);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Get请求就会对应到Get方法，Post就会对应到Post方法，Delete就会对应到Delete方法，Header方法就会对应Header方法。&lt;/p&gt;
&lt;h4 id=&#34;123-正则路由&#34;&gt;1.2.3 正则路由：&lt;/h4&gt;
&lt;p&gt;正则路由是指可以在进行固定路由的基础上，支持匹配一定格式的正则表达式。比如:id,:username,自定义正则,file的路径和后缀切换以及全匹配等操作。&lt;/p&gt;
&lt;h4 id=&#34;124-自定义路由&#34;&gt;1.2.4 自定义路由&lt;/h4&gt;
&lt;p&gt;上面两种路由都是默认的根据请求的类型，Get就执行Get方法，Post执行Post方法，比较局限。因为在开发的时候大部分都是使用固定匹配想要直接执行对应的逻辑控制方法，因此beego提供给我们了可以自定义的自定义路由配置。方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;beego.Router(&amp;quot;/&amp;quot;,&amp;amp;IndexController{},&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以用的HTTP Method：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;quot;*&amp;quot;：包含以下所有的函数&lt;/li&gt;
&lt;li&gt;&amp;quot;get&amp;quot;：GET 请求&lt;/li&gt;
&lt;li&gt;&amp;quot;post&amp;quot;：POST 请求&lt;/li&gt;
&lt;li&gt;&amp;quot;put&amp;quot;：PUT 请求&lt;/li&gt;
&lt;li&gt;&amp;quot;delete&amp;quot;：DELETE 请求&lt;/li&gt;
&lt;li&gt;&amp;quot;patch&amp;quot;：PATCH 请求&lt;/li&gt;
&lt;li&gt;&amp;quot;options&amp;quot;：OPTIONS 请求&lt;/li&gt;
&lt;li&gt;&amp;quot;head&amp;quot;：HEAD 请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面这些对应的请求方法，在beego.Controller中，定义了很多的方法，比如Init，Prepare，Post，Get，Head，Delete等方法。以上分析的是beego框架的Router以及Controller运行逻辑。&lt;/p&gt;
&lt;h3 id=&#34;13-model层分析&#34;&gt;1.3 model层分析&lt;/h3&gt;
&lt;p&gt;在Web开发过程中，开发者操作数据，存储数据最常用的就是数据库操作，数据库操作是独立的一个模块，这个在后面具体的项目中会带着大家实现。&lt;/p&gt;
&lt;h3 id=&#34;14-view编写&#34;&gt;1.4 view编写&lt;/h3&gt;
&lt;p&gt;这里的实战项目静态的html模版文件以及一些其他的静态资源，是已经写好提供给开发者直接可以拿来放在项目中进行使用。在实际的开发过程中，要求大家需要掌握html，js语法以及简单的css语法要能看懂，能够时间简单的使用。更加复杂的前端页面或者静态页面，需要和前端开发人员进行对接。开发重心是在后台服务端，因此，只需要学会使用和调用调试即可。&lt;/p&gt;
&lt;h3 id=&#34;15-静态文件的设置&#34;&gt;1.5 静态文件的设置&lt;/h3&gt;
&lt;p&gt;在goweb项目中，上面说过是有一些静态资源文件的，如果用户要访问静态资源文件，我们应该也是能够访问的，这需要在我们的项目中进行静态资源设置。
设置方式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;beego.SetStaticPath(&amp;quot;/down1&amp;quot;,&amp;quot;download1&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的download目录是指的非goweb项目的static目录下目录，而是开发者重新新建的另外的目录。&lt;/p&gt;
&lt;h3 id=&#34;16-实战项目介绍&#34;&gt;1.6 实战项目介绍&lt;/h3&gt;
&lt;p&gt;在本系列课程中，我们一起使用Beego框架开发实现一个博客系统。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190515-124022@2x.png&#34; alt=&#34;项目效果1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190515-124056@2x.png&#34; alt=&#34;项目效果2&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190515-124145@2x.png&#34; alt=&#34;项目效果3&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190515-124339@2x.png&#34; alt=&#34;项目效果4&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;二数据库配置及连接测试&#34;&gt;二、数据库配置及连接测试&lt;/h1&gt;
&lt;h3 id=&#34;21-mysql数据库安装&#34;&gt;2.1 mysql数据库安装&lt;/h3&gt;
&lt;p&gt;mysql官方下载网站：&lt;a href=&#34;https://dev.mysql.com/downloads/&#34;&gt;https://dev.mysql.com/downloads/&lt;/a&gt;
我们使用的是5.7版本，下载链接：&lt;a href=&#34;https://dev.mysql.com/downloads/mysql/5.7.html#downloads&#34;&gt;https://dev.mysql.com/downloads/mysql/5.7.html#downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/mysql.png&#34; alt=&#34;mysql下载&#34;&gt;&lt;/p&gt;
&lt;p&gt;选择下载安装文件，并在本地进行安装。
安装过程中，若出现初始密码，要记住该密码，首次登陆时要使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【注意】windows安装说明：&lt;a href=&#34;https://jingyan.baidu.com/article/09ea3ededa53b7c0aede39b5.html&#34;&gt;https://jingyan.baidu.com/article/09ea3ededa53b7c0aede39b5.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装完毕后，将mysql的bin目录路径添加配置到环境变量，以便能够在终端命令行中进行使用登陆mysql。&lt;/p&gt;
&lt;p&gt;在终端中登陆mysql的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入安装时或者自己设置的密码即可登陆成功。如下所示：
&lt;img src=&#34;http://www.songx.fun/img/png/mysql_login_1.png&#34; alt=&#34;终端登录mysql&#34;&gt;
如上图所示表示登陆成功。为了使用自己的密码，可以自己设置一个自己熟悉的密码，方便自己记忆。&lt;/p&gt;
&lt;h3 id=&#34;22-mysql数据库常用命令&#34;&gt;2.2 mysql数据库常用命令&lt;/h3&gt;
&lt;p&gt;mysql数据库的一些命令使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查看数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show databases;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用某个数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;use databaseName;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;展示某个数据库表格列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show tables;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mysql中的一些其他命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/mysql_command.png&#34; alt=&#34;mysql常用命令安装&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上mysql数据操作都是命令行终端形式，为了方便我们日常操作，我们可以使用图形化界面工具，在这里我们使用的是navicat工具。我们现在来看如何进行安装。&lt;/p&gt;
&lt;h3 id=&#34;23-navicat安装&#34;&gt;2.3 Navicat安装&lt;/h3&gt;
&lt;p&gt;navicat工具下载地址：&lt;a href=&#34;https://www.navicat.com/en/download/navicat-for-mysql&#34;&gt;https://www.navicat.com/en/download/navicat-for-mysql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在上面的链接中，选择自己的系统版本，然后下载安装文件，进行安装，一直默认选下一步即可，最后安装成功。&lt;/p&gt;
&lt;p&gt;安装好了以后，在mysql数据库中创建一个新的数据库，比如名字为：&lt;strong&gt;myblog&lt;/strong&gt;;创建完数据库以后，我们来看一看在beego项目中如何使用mysql数据库。&lt;/p&gt;
&lt;h3 id=&#34;24-数据库驱动&#34;&gt;2.4 数据库驱动&lt;/h3&gt;
&lt;p&gt;我们之前给大家说过，数据库编程属于beego中的Models层，也称ORM模块。&lt;/p&gt;
&lt;p&gt;在beego中，目前支持三种数据库驱动，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MySQL：&lt;/strong&gt; &lt;a href=&#34;github.com/go-sql-driver/mysql&#34;&gt;github.com/go-sql-driver/mysql&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PostgreSQL：&lt;/strong&gt;&lt;a href=&#34;github.com/lib/pq&#34;&gt;github.com/lib/pq&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sqlite3：&lt;/strong&gt;&lt;a href=&#34;github.com/mattn/go-sqlite3&#34;&gt;github.com/mattn/go-sqlite3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;beego中的ORM所具备的几个特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支持Go语言的所有类型存储&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CRUD操作简单&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;自动Join关联表&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;允许直接使用SQL查询&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;25-beego项目中使用mysql&#34;&gt;2.5 beego项目中使用mysql&lt;/h3&gt;
&lt;h4 id=&#34;251-导入对应的数据库驱动&#34;&gt;2.5.1 导入对应的数据库驱动&lt;/h4&gt;
&lt;p&gt;比如mysql：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import _ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/driver_mysql.png&#34; alt=&#34;导入驱动&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;252-注册驱动连接数据库&#34;&gt;2.5.2 注册驱动，连接数据库&lt;/h4&gt;
&lt;p&gt;通过如下两句话注册数据库驱动，以及连接数据库的操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;orm.RegisterDriver(&amp;quot;mysql&amp;quot;,orm.DRMySQL)
orm.RegisterDataBase(aliasName,driverName,dbConn)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;详细代码如下：
&lt;img src=&#34;http://www.songx.fun/img/png/conn_mysql.png&#34; alt=&#34;注册驱动连接数据库&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;253-创建数据库并执行程序&#34;&gt;2.5.3 创建数据库并执行程序&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190515-150049@2x.png&#34; alt=&#34;创建数据库&#34;&gt;&lt;/p&gt;
&lt;p&gt;连接数据库代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package models
    
import (
	&amp;quot;github.com/astaxie/beego&amp;quot;
	&amp;quot;github.com/astaxie/beego/orm&amp;quot;
	&amp;quot;BlogProject/MysqlDemo/util&amp;quot;
	//切记：导入驱动包
	_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
)
    
func init() {
	driverName := beego.AppConfig.String(&amp;quot;driverName&amp;quot;)
    
	//注册数据库驱动
	orm.RegisterDriver(driverName, orm.DRMySQL)
    
	//数据库连接
	user := beego.AppConfig.String(&amp;quot;mysqluser&amp;quot;)
	pwd := beego.AppConfig.String(&amp;quot;mysqlpwd&amp;quot;)
	host := beego.AppConfig.String(&amp;quot;host&amp;quot;)
	port := beego.AppConfig.String(&amp;quot;port&amp;quot;)
	dbname := beego.AppConfig.String(&amp;quot;dbname&amp;quot;)
    
	//dbConn := &amp;quot;root:yu271400@tcp(127.0.0.1:3306)/cmsproject?charset=utf8&amp;quot;
	dbConn := user + &amp;quot;:&amp;quot; + pwd + &amp;quot;@tcp(&amp;quot; + host + &amp;quot;:&amp;quot; + port + &amp;quot;)/&amp;quot; + dbname + &amp;quot;?charset=utf8&amp;quot;
    
	err := orm.RegisterDataBase(&amp;quot;default&amp;quot;, driverName, dbConn)
	if err != nil {
		util.LogError(&amp;quot;连接数据库出错&amp;quot;)
		return
	}
	util.LogInfo(&amp;quot;连接数据库成功&amp;quot;)  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;254-程序执行结果&#34;&gt;2.5.4 程序执行结果&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190515-152119@2x.png&#34; alt=&#34;连接数据库测试结果&#34;&gt;&lt;/p&gt;
&lt;p&gt;注：文章采用了部分外部网页链接，内容均来自公开内容。侵删除。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E6%A1%86%E6%9E%B6/">框架</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>channel通道</title>
                <link>http://www.songx.fun/blog/day16-20go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/day18_channel%E9%80%9A%E9%81%93/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day16-20go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/day18_channel%E9%80%9A%E9%81%93/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;channel通道&#34;&gt;channel通道&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通道可以被认为是Goroutines通信的管道。类似于管道中的水从一端到另一端的流动，数据可以从一端发送到另一端，通过通道接收。&lt;/p&gt;
&lt;p&gt;在前面讲Go语言的并发时候，我们就说过，当多个Goroutine想实现共享数据的时候，虽然也提供了传统的同步机制，但是Go语言强烈建议的是使用Channel通道来实现Goroutines之间的通信。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;“不要通过共享内存来通信，而应该通过通信来共享内存” 这是一句风靡golang社区的经典语
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go语言中，要传递某个数据给另一个goroutine(协程)，可以把这个数据封装成一个对象，然后把这个对象的指针传入某个channel中，另外一个goroutine从这个channel中读出这个指针，并处理其指向的内存对象。Go从语言层面保证同一个时间只有一个goroutine能够访问channel里面的数据，为开发者提供了一种优雅简单的工具，所以Go的做法就是使用channel来通信，通过通信来传递内存数据，使得内存数据在不同的goroutine中传递，而不是使用共享内存来通信。&lt;/p&gt;
&lt;h2 id=&#34;一-什么是通道&#34;&gt;一、 什么是通道&lt;/h2&gt;
&lt;h3 id=&#34;11-通道的概念&#34;&gt;1.1 通道的概念&lt;/h3&gt;
&lt;p&gt;通道是什么，通道就是goroutine之间的通道。它可以让goroutine之间相互通信。&lt;/p&gt;
&lt;p&gt;每个通道都有与其相关的类型。该类型是通道允许传输的数据类型。(通道的零值为nil。nil通道没有任何用处，因此通道必须使用类似于map和切片的方法来定义。)&lt;/p&gt;
&lt;h3 id=&#34;12-通道的声明&#34;&gt;1.2 通道的声明&lt;/h3&gt;
&lt;p&gt;声明一个通道和定义一个变量的语法一样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//声明通道
var 通道名 chan 数据类型
//创建通道：如果通道为nil(就是不存在)，就需要先创建通道
通道名 = make(chan 数据类型)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	var a chan int
	if a == nil {
		fmt.Println(&amp;quot;channel 是 nil 的, 不能使用，需要先创建通道。。&amp;quot;)
		a = make(chan int)
		fmt.Printf(&amp;quot;数据类型是： %T&amp;quot;, a)
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
channel 是 nil 的, 不能使用，需要先创建通道。。
数据类型是： chan int
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以简短的声明：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a := make(chan int) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-channel的数据类型&#34;&gt;1.3 channel的数据类型&lt;/h3&gt;
&lt;p&gt;channel是引用类型的数据，在作为参数传递的时候，传递的是内存地址。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {
	ch1 := make(chan int)
	fmt.Printf(&amp;quot;%T,%p\n&amp;quot;,ch1,ch1)

	test1(ch1)

}

func test1(ch chan int){
	fmt.Printf(&amp;quot;%T,%p\n&amp;quot;,ch,ch)
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190812-154429.png&#34; alt=&#34;WX20190812-154429&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们能够看到，ch和ch1的地址是一样的，说明它们是同一个通道。&lt;/p&gt;
&lt;h3 id=&#34;14-通道的注意点&#34;&gt;1.4 通道的注意点&lt;/h3&gt;
&lt;p&gt;Channel通道在使用的时候，有以下几个注意点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.用于goroutine，传递消息的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.通道，每个都有相关联的数据类型,
nil chan，不能使用，类似于nil map，不能直接存储键值对&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.使用通道传递数据：&amp;lt;-
chan &amp;lt;- data,发送数据到通道。向通道中写数据
data &amp;lt;- chan,从通道中获取数据。从通道中读数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4.阻塞：
发送数据：chan &amp;lt;- data,阻塞的，直到另一条goroutine，读取数据来解除阻塞
读取数据：data &amp;lt;- chan,也是阻塞的。直到另一条goroutine，写出数据解除阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5.本身channel就是同步的，意味着同一时间，只能有一条goroutine来操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后：通道是goroutine之间的连接，所以通道的发送和接收必须处在不同的goroutine中。&lt;/p&gt;
&lt;h2 id=&#34;二通道的使用语法&#34;&gt;二、通道的使用语法&lt;/h2&gt;
&lt;h3 id=&#34;21-发送和接收&#34;&gt;2.1 发送和接收&lt;/h3&gt;
&lt;p&gt;发送和接收的语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;data := &amp;lt;- a // read from channel a  
a &amp;lt;- data // write to channel a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在通道上箭头的方向指定数据是发送还是接收。&lt;/p&gt;
&lt;p&gt;另外：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;v, ok := &amp;lt;- a //从一个channel中读取
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22-发送和接收默认是阻塞的&#34;&gt;2.2 发送和接收默认是阻塞的&lt;/h3&gt;
&lt;p&gt;一个通道发送和接收数据，默认是阻塞的。当一个数据被发送到通道时，在发送语句中被阻塞，直到另一个Goroutine从该通道读取数据。相对地，当从通道读取数据时，读取被阻塞，直到一个Goroutine将数据写入该通道。&lt;/p&gt;
&lt;p&gt;这些通道的特性是帮助Goroutines有效地进行通信，而无需像使用其他编程语言中非常常见的显式锁或条件变量。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	var ch1 chan bool       //声明，没有创建
	fmt.Println(ch1)        //&amp;lt;nil&amp;gt;
	fmt.Printf(&amp;quot;%T\n&amp;quot;, ch1) //chan bool
	ch1 = make(chan bool)   //0xc0000a4000,是引用类型的数据
	fmt.Println(ch1)

	go func() {
		for i := 0; i &amp;lt; 10; i++ {
			fmt.Println(&amp;quot;子goroutine中，i：&amp;quot;, i)
		}
		// 循环结束后，向通道中写数据，表示要结束了。。
		ch1 &amp;lt;- true

		fmt.Println(&amp;quot;结束。。&amp;quot;)

	}()

	data := &amp;lt;-ch1 // 从ch1通道中读取数据
	fmt.Println(&amp;quot;data--&amp;gt;&amp;quot;, data)
	fmt.Println(&amp;quot;main。。over。。。。&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190812-153205.png&#34; alt=&#34;WX20190812-153205&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上面的程序中，我们先创建了一个chan bool通道。然后启动了一条子Goroutine，并循环打印10个数字。然后我们向通道ch1中写入输入true。然后在主goroutine中，我们从ch1中读取数据。这一行代码是阻塞的，这意味着在子Goroutine将数据写入到该通道之前，主goroutine将不会执行到下一行代码。因此，我们可以通过channel实现子goroutine和主goroutine之间的通信。当子goroutine执行完毕前，主goroutine会因为读取ch1中的数据而阻塞。从而保证了子goroutine会先执行完毕。这就消除了对时间的需求。在之前的程序中，我们要么让主goroutine进入睡眠，以防止主要的Goroutine退出。要么通过WaitGroup来保证子goroutine先执行完毕，主goroutine才结束。&lt;/p&gt;
&lt;p&gt;示例代码：以下代码加入了睡眠，可以更好的理解channel的阻塞&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	ch1 := make(chan int)
	done := make(chan bool) // 通道
	go func() {
		fmt.Println(&amp;quot;子goroutine执行。。。&amp;quot;)
		time.Sleep(3 * time.Second)
		data := &amp;lt;-ch1 // 从通道中读取数据
		fmt.Println(&amp;quot;data：&amp;quot;, data)
		done &amp;lt;- true
	}()
	// 向通道中写数据。。
	time.Sleep(5 * time.Second)
	ch1 &amp;lt;- 100

	&amp;lt;-done
	fmt.Println(&amp;quot;main。。over&amp;quot;)

}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190812-154236.png&#34; alt=&#34;WX20190812-154236&#34;&gt;&lt;/p&gt;
&lt;p&gt;再一个例子，这个程序将打印一个数字的个位数的平方和。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func calcSquares(number int, squareop chan int) {  
    sum := 0
    for number != 0 {
        digit := number % 10
        sum += digit * digit
        number /= 10
    }
    squareop &amp;lt;- sum
}

func calcCubes(number int, cubeop chan int) {  
    sum := 0 
    for number != 0 {
        digit := number % 10
        sum += digit * digit * digit
        number /= 10
    }
    cubeop &amp;lt;- sum
} 
func main() {  
    number := 589
    sqrch := make(chan int)
    cubech := make(chan int)
    go calcSquares(number, sqrch)
    go calcCubes(number, cubech)
    squares, cubes := &amp;lt;-sqrch, &amp;lt;-cubech
    fmt.Println(&amp;quot;Final output&amp;quot;, squares + cubes)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Final output 1536
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-死锁&#34;&gt;2.3 死锁&lt;/h3&gt;
&lt;p&gt;使用通道时要考虑的一个重要因素是死锁。如果Goroutine在一个通道上发送数据，那么预计其他的Goroutine应该接收数据。如果这种情况不发生，那么程序将在运行时出现死锁。&lt;/p&gt;
&lt;p&gt;类似地，如果Goroutine正在等待从通道接收数据，那么另一些Goroutine将会在该通道上写入数据，否则程序将会死锁。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

func main() {  
    ch := make(chan int)
    ch &amp;lt;- 5
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:
main.main()
	/Users/ruby/go/src/l_goroutine/demo08_chan.go:5 +0x50
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在主流的编程语言中为了保证多线程之间共享数据安全性和一致性，都会提供一套基本的同步工具集，如锁，条件变量，原子操作等等。Go语言标准库也毫不意外的提供了这些同步机制，使用方式也和其他语言也差不多。
除了这些基本的同步手段，Go语言还提供了一种新的同步机制: Channel，它在Go语言中是一个像int, float32等的基本类型，一个channel可以认为是一个能够在多个Goroutine之间传递某一类型的数据的管道。Go中的channel无论是实现机制还是使用场景都和Java中的BlockingQueue很接近。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;三-关闭通道&#34;&gt;三、 关闭通道&lt;/h2&gt;
&lt;p&gt;发送者可以通过关闭信道，来通知接收方不会有更多的数据被发送到channel上。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;close(ch)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接收者可以在接收来自通道的数据时使用额外的变量来检查通道是否已经关闭。&lt;/p&gt;
&lt;p&gt;语法结构：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;v, ok := &amp;lt;- ch  
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;类似map操作，存储key，value键值对&lt;/p&gt;
&lt;p&gt;v,ok := map[key] //根据key从map中获取value，如果key存在， v就是对应的数据，如果key不存在，v是默认值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上面的语句中，如果ok的值是true，表示成功的从通道中读取了一个数据value。如果ok是false，这意味着我们正在从一个封闭的通道读取数据。从闭通道读取的值将是通道类型的零值。&lt;/p&gt;
&lt;p&gt;例如，如果通道是一个int通道，那么从封闭通道接收的值将为0。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main()  {
	ch1 := make(chan int)
	go sendData(ch1)
	/*
	子goroutine，写出数据10个
			每写一个，阻塞一次，主程序读取一次，解除阻塞

	主goroutine：循环读
			每次读取一个，堵塞一次，子程序，写出一个，解除阻塞

	发送发，关闭通道的---&amp;gt;接收方，接收到的数据是该类型的零值，以及false
	 */
	//主程序中获取通道的数据
	for{
		time.Sleep(1*time.Second)
		v, ok := &amp;lt;- ch1 //其他goroutine，显示的调用close方法关闭通道。
		if !ok{
			fmt.Println(&amp;quot;已经读取了所有的数据，&amp;quot;, ok)
			break
		}
		fmt.Println(&amp;quot;取出数据：&amp;quot;,v, ok)
	}

	fmt.Println(&amp;quot;main...over....&amp;quot;)
}
func sendData(ch1 chan int)  {
	// 发送方：10条数据
	for i:=0;i&amp;lt;10 ;i++  {
		ch1 &amp;lt;- i//将i写入通道中
	}
	close(ch1) //将ch1通道关闭了。
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190813-100521.png&#34; alt=&#34;WX20190813-100521&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上面的程序中，send Goroutine将0到9写入chl通道，然后关闭通道。主函数里有一个无限循环。它检查通道是否在发送数据后，使用变量ok关闭。如果ok是假的，则意味着通道关闭，因此循环结束。还可以打印接收到的值和ok的值。&lt;/p&gt;
&lt;h2 id=&#34;四通道上的范围循环&#34;&gt;四、通道上的范围循环&lt;/h2&gt;
&lt;p&gt;我们可以循环从通道上获取数据，直到通道关闭。for循环的for range形式可用于从通道接收值，直到它关闭为止。&lt;/p&gt;
&lt;p&gt;使用range循环，示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;time&amp;quot;
	&amp;quot;fmt&amp;quot;
)

func main()  {
	ch1 :=make(chan int)
	go sendData(ch1)
	// for循环的for range形式可用于从通道接收值，直到它关闭为止。
	for v := range ch1{
		fmt.Println(&amp;quot;读取数据：&amp;quot;,v)
	}
	fmt.Println(&amp;quot;main..over.....&amp;quot;)
}
func sendData(ch1 chan int)  {
	for i:=0;i&amp;lt;10 ; i++ {
		time.Sleep(1*time.Second)
		ch1 &amp;lt;- i
	}
	close(ch1)//通知对方，通道关闭
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190813-100915.png&#34; alt=&#34;WX20190813-100915&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;五非缓冲通道&#34;&gt;五、非缓冲通道&lt;/h2&gt;
&lt;p&gt;之前学习的所有通道基本上都没有缓冲。发送和接收到一个未缓冲的通道是阻塞的。&lt;/p&gt;
&lt;p&gt;一次发送操作对应一次接收操作，对于一个goroutine来讲，它的一次发送，在另一个goroutine接收之前都是阻塞的。同样的，对于接收来讲，在另一个goroutine发送之前，它也是阻塞的。&lt;/p&gt;
&lt;h2 id=&#34;六缓冲通道&#34;&gt;六、缓冲通道&lt;/h2&gt;
&lt;p&gt;缓冲通道就是指一个通道，带有一个缓冲区。发送到一个缓冲通道只有在缓冲区满时才被阻塞。类似地，从缓冲通道接收的信息只有在缓冲区为空时才会被阻塞。&lt;/p&gt;
&lt;p&gt;可以通过将额外的容量参数传递给make函数来创建缓冲通道，该函数指定缓冲区的大小。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch := make(chan type, capacity)  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述语法的容量应该大于0，以便通道具有缓冲区。默认情况下，无缓冲通道的容量为0，因此在之前创建通道时省略了容量参数。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;p&gt;以下的代码中，chan通道，是带有缓冲区的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	/*
	非缓存通道：make(chan T)
	缓存通道：make(chan T ,size)
		缓存通道，理解为是队列：

	非缓存，发送还是接受，都是阻塞的
	缓存通道,缓存区的数据满了，才会阻塞状态。。

	 */
	ch1 := make(chan int)           //非缓存的通道
	fmt.Println(len(ch1), cap(ch1)) //0 0
	//ch1 &amp;lt;- 100//阻塞的，需要其他的goroutine解除阻塞，否则deadlock

	ch2 := make(chan int, 5)        //缓存的通道，缓存区大小是5
	fmt.Println(len(ch2), cap(ch2)) //0 5
	ch2 &amp;lt;- 100                      //
	fmt.Println(len(ch2), cap(ch2)) //1 5

	//ch2 &amp;lt;- 200
	//ch2 &amp;lt;- 300
	//ch2 &amp;lt;- 400
	//ch2 &amp;lt;- 500
	//ch2 &amp;lt;- 600
	fmt.Println(&amp;quot;--------------&amp;quot;)
	ch3 := make(chan string, 4)
	go sendData3(ch3)
	for {
		time.Sleep(1*time.Second)
		v, ok := &amp;lt;-ch3
		if !ok {
			fmt.Println(&amp;quot;读完了，，&amp;quot;, ok)
			break
		}
		fmt.Println(&amp;quot;\t读取的数据是：&amp;quot;, v)
	}

	fmt.Println(&amp;quot;main...over...&amp;quot;)
}

func sendData3(ch3 chan string) {
	for i := 0; i &amp;lt; 10; i++ {
		ch3 &amp;lt;- &amp;quot;数据&amp;quot; + strconv.Itoa(i)
		fmt.Println(&amp;quot;子goroutine，写出第&amp;quot;, i, &amp;quot;个数据&amp;quot;)
	}
	close(ch3)
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190813-102230.png&#34; alt=&#34;WX20190813-102230&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;七双向通道&#34;&gt;七、双向通道&lt;/h2&gt;
&lt;p&gt;通道，channel，是用于实现goroutine之间的通信的。一个goroutine可以向通道中发送数据，另一条goroutine可以从该通道中获取数据。截止到现在我们所学习的通道，都是既可以发送数据，也可以读取数据，我们又把这种通道叫做双向通道。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;data := &amp;lt;- a // read from channel a  
a &amp;lt;- data // write to channel a
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;八单向通道&#34;&gt;八、单向通道&lt;/h2&gt;
&lt;p&gt;单向通道，也就是定向通道。&lt;/p&gt;
&lt;p&gt;之前我们学习的通道都是双向通道，我们可以通过这些通道接收或者发送数据。我们也可以创建单向通道，这些通道只能发送或者接收数据。&lt;/p&gt;
&lt;p&gt;双向通道，实例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main()  {
	/*
	双向：
		chan T --&amp;gt;
			chan &amp;lt;- data,写出数据，写
			data &amp;lt;- chan,获取数据，读
	单向：定向
		chan &amp;lt;- T,
			只支持写，
		&amp;lt;- chan T,
			只读
	 */
	ch1 := make(chan string) // 双向，可读，可写
	done := make(chan bool)
	go sendData(ch1, done)
	data :=&amp;lt;- ch1 //阻塞
	fmt.Println(&amp;quot;子goroutine传来：&amp;quot;, data)
	ch1 &amp;lt;- &amp;quot;我是main。。&amp;quot; // 阻塞

	&amp;lt;-done
	fmt.Println(&amp;quot;main...over....&amp;quot;)
}
//子goroutine--&amp;gt;写数据到ch1通道中
//main goroutine--&amp;gt;从ch1通道中取
func sendData(ch1 chan string, done chan bool)  {
	ch1 &amp;lt;- &amp;quot;我是小明&amp;quot;// 阻塞
	data := &amp;lt;-ch1 // 阻塞
	fmt.Println(&amp;quot;main goroutine传来：&amp;quot;,data)

	done &amp;lt;- true
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190814-101353.png&#34; alt=&#34;WX20190814-101353&#34;&gt;&lt;/p&gt;
&lt;p&gt;创建仅能发送数据的通道，示例代码：&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main()  {
	/*
		单向：定向
		chan &amp;lt;- T,
			只支持写，
		&amp;lt;- chan T,
			只读


		用于参数传递：
	 */
	ch1 := make(chan int)//双向，读，写
	//ch2 := make(chan &amp;lt;- int) // 单向，只写，不能读
	//ch3 := make(&amp;lt;- chan int) //单向，只读，不能写
	//ch1 &amp;lt;- 100
	//data :=&amp;lt;-ch1
	//ch2 &amp;lt;- 1000
	//data := &amp;lt;- ch2
	//fmt.Println(data)
	//	&amp;lt;-ch2 //invalid operation: &amp;lt;-ch2 (receive from send-only type chan&amp;lt;- int)
	//ch3 &amp;lt;- 100
	//	&amp;lt;-ch3
	//	ch3 &amp;lt;- 100 //invalid operation: ch3 &amp;lt;- 100 (send to receive-only type &amp;lt;-chan int)

	//go fun1(ch2)
	go fun1(ch1)
	data:= &amp;lt;- ch1
	fmt.Println(&amp;quot;fun1中写出的数据是：&amp;quot;,data)

	//fun2(ch3)
	go fun2(ch1)
	ch1 &amp;lt;- 200
	fmt.Println(&amp;quot;main。。over。。&amp;quot;)
}
//该函数接收，只写的通道
func fun1(ch chan &amp;lt;- int){
	// 函数内部，对于ch只能写数据，不能读数据
	ch &amp;lt;- 100
	fmt.Println(&amp;quot;fun1函数结束。。&amp;quot;)
}

func fun2(ch &amp;lt;-chan int){
	//函数内部，对于ch只能读数据，不能写数据
	data := &amp;lt;- ch
	fmt.Println(&amp;quot;fun2函数，从ch中读取的数据是：&amp;quot;,data)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190814-102655.png&#34; alt=&#34;WX20190814-102655&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;九time包中的通道相关函数&#34;&gt;九、time包中的通道相关函数&lt;/h2&gt;
&lt;p&gt;主要就是定时器，标准库中的Timer让用户可以定义自己的超时逻辑，尤其是在应对select处理多个channel的超时、单channel读写的超时等情形时尤为方便。&lt;/p&gt;
&lt;p&gt;Timer是一次性的时间触发事件，这点与Ticker不同，Ticker是按一定时间间隔持续触发时间事件。&lt;/p&gt;
&lt;p&gt;Timer常见的创建方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;t:= time.NewTimer(d)
t:= time.AfterFunc(d, f)
c:= time.After(d)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然说创建方式不同，但是原理是相同的。&lt;/p&gt;
&lt;p&gt;Timer有3个要素：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;定时时间：就是那个d
触发动作：就是那个f
时间channel： 也就是t.C
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;91timenewtimer&#34;&gt;9.1、time.NewTimer()&lt;/h3&gt;
&lt;p&gt;NewTimer()创建一个新的计时器，该计时器将在其通道上至少持续d之后发送当前时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190815-100148.png&#34; alt=&#34;WX20190815-100148&#34;&gt;&lt;/p&gt;
&lt;p&gt;它的返回值是一个Timer。&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// NewTimer creates a new Timer that will send
// the current time on its channel after at least duration d.
func NewTimer(d Duration) *Timer {
	c := make(chan Time, 1)
	t := &amp;amp;Timer{
		C: c,
		r: runtimeTimer{
			when: when(d),
			f:    sendTime,
			arg:  c,
		},
	}
	startTimer(&amp;amp;t.r)
	return t
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过源代码我们可以看出，首先创建一个channel，关联的类型为Time，然后创建了一个Timer并返回。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于在指定的Duration类型时间后调用函数或计算表达式。&lt;/li&gt;
&lt;li&gt;如果只是想指定时间之后执行,使用time.Sleep()&lt;/li&gt;
&lt;li&gt;使用NewTimer(),可以返回的Timer类型在计时器到期之前,取消该计时器&lt;/li&gt;
&lt;li&gt;直到使用&amp;lt;-timer.C发送一个值,该计时器才会过期&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;time&amp;quot;
	&amp;quot;fmt&amp;quot;
)

func main() {

	/*
		1.func NewTimer(d Duration) *Timer
			创建一个计时器：d时间以后触发，go触发计时器的方法比较特别，就是在计时器的channel中发送值
	 */
	//新建一个计时器：timer
	timer := time.NewTimer(3 * time.Second)
	fmt.Printf(&amp;quot;%T\n&amp;quot;, timer) //*time.Timer
	fmt.Println(time.Now())   //2019-08-15 10:41:21.800768 +0800 CST m=+0.000461190

	//此处在等待channel中的信号，执行此段代码时会阻塞3秒
	ch2 := timer.C     //&amp;lt;-chan time.Time
	fmt.Println(&amp;lt;-ch2) //2019-08-15 10:41:24.803471 +0800 CST m=+3.003225965

}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190815-104148.png&#34; alt=&#34;WX20190815-104148&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;92timerstop&#34;&gt;9.2、timer.Stop&lt;/h3&gt;
&lt;p&gt;计时器停止：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190815-102436.png&#34; alt=&#34;WX20190815-102436&#34;&gt;&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;time&amp;quot;
	&amp;quot;fmt&amp;quot;
)

func main() {

	/*
		1.func NewTimer(d Duration) *Timer
			创建一个计时器：d时间以后触发，go触发计时器的方法比较特别，就是在计时器的channel中发送值
	 */
	//新建一个计时器：timer
	//timer := time.NewTimer(3 * time.Second)
	//fmt.Printf(&amp;quot;%T\n&amp;quot;, timer) //*time.Timer
	//fmt.Println(time.Now())   //2019-08-15 10:41:21.800768 +0800 CST m=+0.000461190
	//
	////此处在等待channel中的信号，执行此段代码时会阻塞3秒
	//ch2 := timer.C     //&amp;lt;-chan time.Time
	//fmt.Println(&amp;lt;-ch2) //2019-08-15 10:41:24.803471 +0800 CST m=+3.003225965



	fmt.Println(&amp;quot;-------------------------------&amp;quot;)

	//新建计时器，一秒后触发

	timer2 := time.NewTimer(5 * time.Second)

	//新开启一个线程来处理触发后的事件

	go func() {

		//等触发时的信号

		&amp;lt;-timer2.C

		fmt.Println(&amp;quot;Timer 2 结束。。&amp;quot;)

	}()

	//由于上面的等待信号是在新线程中，所以代码会继续往下执行，停掉计时器

	time.Sleep(3*time.Second)
	stop := timer2.Stop()

	if stop {

		fmt.Println(&amp;quot;Timer 2 停止。。&amp;quot;)

	}

}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190815-104319.png&#34; alt=&#34;WX20190815-104319&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;93timeafter&#34;&gt;9.3、time.After()&lt;/h3&gt;
&lt;p&gt;在等待持续时间之后，然后在返回的通道上发送当前时间。它相当于NewTimer(d).C。在计时器触发之前，垃圾收集器不会恢复底层计时器。如果效率有问题，使用NewTimer代替，并调用Timer。如果不再需要计时器，请停止。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190815-093909.png&#34; alt=&#34;WX20190815-093909&#34;&gt;&lt;/p&gt;
&lt;p&gt;源码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// After waits for the duration to elapse and then sends the current time
// on the returned channel.
// It is equivalent to NewTimer(d).C.
// The underlying Timer is not recovered by the garbage collector
// until the timer fires. If efficiency is a concern, use NewTimer
// instead and call Timer.Stop if the timer is no longer needed.
func After(d Duration) &amp;lt;-chan Time {
	return NewTimer(d).C
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;time&amp;quot;
	&amp;quot;fmt&amp;quot;
)

func main() {

	/*
		func After(d Duration) &amp;lt;-chan Time
			返回一个通道：chan，存储的是d时间间隔后的当前时间。
	 */
	ch1 := time.After(3 * time.Second) //3s后
	fmt.Printf(&amp;quot;%T\n&amp;quot;, ch1) // &amp;lt;-chan time.Time
	fmt.Println(time.Now()) //2019-08-15 09:56:41.529883 +0800 CST m=+0.000465158
	time2 := &amp;lt;-ch1
	fmt.Println(time2) //2019-08-15 09:56:44.532047 +0800 CST m=+3.002662179


}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190815-095743.png&#34; alt=&#34;WX20190815-095743&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;十select语句&#34;&gt;十、select语句&lt;/h2&gt;
&lt;p&gt;select 是 Go 中的一个控制结构。select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。&lt;/p&gt;
&lt;p&gt;select语句的语法结构和switch语句很相似，也有case语句和default语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;select {
    case communication clause  :
       statement(s);      
    case communication clause  :
       statement(s); 
    /* 你可以定义任意数量的 case */
    default : /* 可选 */
       statement(s);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个case都必须是一个通信&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有channel表达式都会被求值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有被发送的表达式都会被求值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有多个case都可以运行，select会随机公平地选出一个执行。其他不会执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则：&lt;/p&gt;
&lt;p&gt;如果有default子句，则执行该语句。&lt;/p&gt;
&lt;p&gt;如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	/*
	分支语句：if，switch，select
	select 语句类似于 switch 语句，
		但是select会随机执行一个可运行的case。
		如果没有case可运行，它将阻塞，直到有case可运行。
	 */

	ch1 := make(chan int)
	ch2 := make(chan int)

	go func() {
		time.Sleep(2 * time.Second)
		ch2 &amp;lt;- 200
	}()
	go func() {
		time.Sleep(2 * time.Second)
		ch1 &amp;lt;- 100
	}()

	select {
	case num1 := &amp;lt;-ch1:
		fmt.Println(&amp;quot;ch1中取数据。。&amp;quot;, num1)
	case num2, ok := &amp;lt;-ch2:
		if ok {
			fmt.Println(&amp;quot;ch2中取数据。。&amp;quot;, num2)
		}else{
			fmt.Println(&amp;quot;ch2通道已经关闭。。&amp;quot;)
		}


	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：可能执行第一个case，打印100，也可能执行第二个case，打印200。(多运行几次，结果就不同了)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190816-104608.png&#34; alt=&#34;WX20190816-104608&#34;&gt;&lt;/p&gt;
&lt;p&gt;select语句结合time包的和chan相关函数，示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	ch1 := make(chan int)
	ch2 := make(chan int)

	//go func() {
	//	ch1 &amp;lt;- 100
	//}()

	select {
	case &amp;lt;-ch1:
		fmt.Println(&amp;quot;case1可以执行。。&amp;quot;)
	case &amp;lt;-ch2:
		fmt.Println(&amp;quot;case2可以执行。。&amp;quot;)
	case &amp;lt;-time.After(3 * time.Second):
		fmt.Println(&amp;quot;case3执行。。timeout。。&amp;quot;)

	//default:
	//	fmt.Println(&amp;quot;执行了default。。&amp;quot;)
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190816-104450.png&#34; alt=&#34;WX20190816-104450&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;十一go语言的csp模型&#34;&gt;十一、Go语言的CSP模型&lt;/h2&gt;
&lt;p&gt;go语言的最大两个亮点，一个是goroutine，一个就是chan了。二者合体的典型应用CSP，基本就是大家认可的并行开发神器，简化了并行程序的开发难度，我们来看一下CSP。&lt;/p&gt;
&lt;h3 id=&#34;111csp是什么&#34;&gt;11.1、CSP是什么&lt;/h3&gt;
&lt;p&gt;CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型，是一个很强大的并发数据模型，是上个世纪七十年代提出的，用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。相对于Actor模型，CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。&lt;/p&gt;
&lt;p&gt;严格来说，CSP 是一门形式语言（类似于 ℷ calculus），用于描述并发系统中的互动模式，也因此成为一众面向并发的编程语言的理论源头，并衍生出了 Occam/Limbo/Golang…&lt;/p&gt;
&lt;p&gt;而具体到编程语言，如 Golang，其实只用到了 CSP 的很小一部分，即理论中的 Process/Channel（对应到语言中的 goroutine/channel）：这两个并发原语之间没有从属关系， Process 可以订阅任意个 Channel，Channel 也并不关心是哪个 Process 在利用它进行通信；Process 围绕 Channel 进行读写，形成一套有序阻塞和可预测的并发模型。&lt;/p&gt;
&lt;h3 id=&#34;112golang-csp&#34;&gt;11.2、Golang CSP&lt;/h3&gt;
&lt;p&gt;与主流语言通过共享内存来进行并发控制方式不同，Go 语言采用了 CSP 模式。这是一种用于描述两个独立的并发实体通过共享的通讯 Channel（管道）进行通信的并发模型。&lt;/p&gt;
&lt;p&gt;Golang 就是借用CSP模型的一些概念为之实现并发进行理论支持，其实从实际上出发，go语言并没有，完全实现了CSP模型的所有理论，仅仅是借用了 process和channel这两个概念。process是在go语言上的表现就是 goroutine 是实际并发执行的实体，每个实体之间是通过channel通讯来实现数据共享。&lt;/p&gt;
&lt;p&gt;Go语言的CSP模型是由协程Goroutine与通道Channel实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Go协程goroutine: 是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程，它与Coroutine协程也有区别，能够在发现堵塞后启动新的微线程。&lt;/li&gt;
&lt;li&gt;通道channel: 类似Unix的Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是它们和Channel有着耦合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;113channel&#34;&gt;11.3、Channel&lt;/h3&gt;
&lt;p&gt;Goroutine 和 channel 是 Go 语言并发编程的 两大基石。Goroutine 用于执行并发任务，channel 用于 goroutine 之间的同步、通信。&lt;/p&gt;
&lt;p&gt;Channel 在 gouroutine 间架起了一条管道，在管道里传输数据，实现 gouroutine 间的通信；由于它是线程安全的，所以用起来非常方便；channel 还提供 “先进先出” 的特性；它还能影响 goroutine 的阻塞和唤醒。&lt;/p&gt;
&lt;p&gt;相信大家一定见过一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Do not communicate by sharing memory; instead, share memory by communicating.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要通过共享内存来通信，而要通过通信来实现内存共享。&lt;/p&gt;
&lt;p&gt;这就是 Go 的并发哲学，它依赖 CSP 模型，基于 channel 实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;channel 实现 CSP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Channel 是 Go 语言中一个非常重要的类型，是 Go 里的第一对象。通过 channel，Go 实现了通过通信来实现内存共享。Channel 是在多个 goroutine 之间传递数据和同步的重要手段。&lt;/p&gt;
&lt;p&gt;使用原子函数、读写锁可以保证资源的共享访问安全，但使用 channel 更优雅。&lt;/p&gt;
&lt;p&gt;channel 字面意义是 “通道”，类似于 Linux 中的管道。声明 channel 的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;chan T // 声明一个双向通道
chan&amp;lt;- T // 声明一个只能用于发送的通道
&amp;lt;-chan T // 声明一个只能用于接收的通道
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单向通道的声明，用 &lt;code&gt;&amp;lt;-&lt;/code&gt; 来表示，它指明通道的方向。你只要明白，代码的书写顺序是从左到右就马上能掌握通道的方向是怎样的。&lt;/p&gt;
&lt;p&gt;因为 channel 是一个引用类型，所以在它被初始化之前，它的值是 nil，channel 使用 make 函数进行初始化。可以向它传递一个 int 值，代表 channel 缓冲区的大小（容量），构造出来的是一个缓冲型的 channel；不传或传 0 的，构造的就是一个非缓冲型的 channel。&lt;/p&gt;
&lt;p&gt;两者有一些差别：非缓冲型 channel 无法缓冲元素，对它的操作一定顺序是 “发送 -&amp;gt; 接收 -&amp;gt; 发送 -&amp;gt; 接收 -&amp;gt; ……”，如果想连续向一个非缓冲 chan 发送 2 个元素，并且没有接收的话，第一次一定会被阻塞；对于缓冲型 channel 的操作，则要 “宽松” 一些，毕竟是带了 “缓冲” 光环。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/channel.png&#34; alt=&#34;channel&#34;&gt;&lt;/p&gt;
&lt;p&gt;对 chan 的发送和接收操作都会在编译期间转换成为底层的发送接收函数。&lt;/p&gt;
&lt;p&gt;Channel 分为两种：带缓冲、不带缓冲。对不带缓冲的 channel 进行的操作实际上可以看作 “同步模式”，带缓冲的则称为 “异步模式”。&lt;/p&gt;
&lt;p&gt;同步模式下，发送方和接收方要同步就绪，只有在两者都 ready 的情况下，数据才能在两者间传输（后面会看到，实际上就是内存拷贝）。否则，任意一方先行进行发送或接收操作，都会被挂起，等待另一方的出现才能被唤醒。&lt;/p&gt;
&lt;p&gt;异步模式下，在缓冲槽可用的情况下（有剩余容量），发送和接收操作都可以顺利进行。否则，操作的一方（如写入）同样会被挂起，直到出现相反操作（如接收）才会被唤醒。&lt;/p&gt;
&lt;p&gt;小结一下：同步模式下，必须要使发送方和接收方配对，操作才会成功，否则会被阻塞；异步模式下，缓冲槽要有剩余容量，操作才会成功，否则也会被阻塞。&lt;/p&gt;
&lt;p&gt;简单来说，CSP 模型由并发执行的实体（线程或者进程或者协程）所组成，实体之间通过发送消息进行通信，
这里发送消息时使用的就是通道，或者叫 channel。&lt;/p&gt;
&lt;p&gt;CSP 模型的关键是关注 channel，而不关注发送消息的实体。Go 语言实现了 CSP 部分理论，goroutine 对应 CSP 中并发执行的实体，channel 也就对应着 CSP 中的 channel。&lt;/p&gt;
&lt;h3 id=&#34;114goroutine&#34;&gt;11.4、Goroutine&lt;/h3&gt;
&lt;p&gt;Goroutine 是实际并发执行的实体，它底层是使用协程(coroutine)实现并发，coroutine是一种运行在用户态的用户线程，类似于 greenthread，go底层选择使用coroutine的出发点是因为，它具有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户空间 避免了内核态和用户态的切换导致的成本&lt;/li&gt;
&lt;li&gt;可以由语言和框架层进行调度&lt;/li&gt;
&lt;li&gt;更小的栈空间允许创建大量的实例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到第二条 用户空间线程的调度不是由操作系统来完成的，像在java 1.3中使用的greenthread的是由JVM统一调度的(后java已经改为内核线程)，还有在ruby中的fiber(半协程) 是需要在重新中自己进行调度的，而goroutine是在golang层面提供了调度器，并且对网络IO库进行了封装，屏蔽了复杂的细节，对外提供统一的语法关键字支持，简化了并发程序编写的成本。&lt;/p&gt;
&lt;h3 id=&#34;115goroutine-调度器&#34;&gt;11.5、Goroutine 调度器&lt;/h3&gt;
&lt;p&gt;Go并发调度: G-P-M模型&lt;/p&gt;
&lt;p&gt;在操作系统提供的内核线程之上，Go搭建了一个特有的两级线程模型。goroutine机制实现了M : N的线程模型，goroutine机制是协程（coroutine）的一种实现，golang内置的调度器，可以让多核CPU中每个CPU执行一个协程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/goroutine2.png&#34; alt=&#34;goroutine2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;116最后&#34;&gt;11.6、最后&lt;/h3&gt;
&lt;p&gt;Golang 的 channel 将 goroutine 隔离开，并发编程的时候可以将注意力放在 channel 上。在一定程度上，这个和消息队列的解耦功能还是挺像的。如果大家感兴趣，还是来看看 channel 的源码吧，对于更深入地理解 channel 还是挺有用的。&lt;/p&gt;
&lt;p&gt;Go 通过 channel 实现 CSP 通信模型，主要用于 goroutine 之间的消息传递和事件通知。&lt;/p&gt;
&lt;p&gt;有了 channel 和 goroutine 之后，Go 的并发编程变得异常容易和安全，得以让程序员把注意力留到业务上去，实现开发效率的提升。&lt;/p&gt;
&lt;p&gt;要知道，技术并不是最重要的，它只是实现业务的工具。一门高效的开发语言让你把节省下来的时间，留着去做更有意义的事情，比如写写文章。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CSP 最早是由 Tony Hoare在 1977 年提出，据说老爷子至今仍在更新这个理论模型，有兴趣的朋友可以自行查阅电子版本：http://www.usingcsp.com/cspbook.pdf。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文档：https://learnku.com/articles/32142&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;github知识库：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314&#34;&gt;https://github.com/rubyhan1314&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Golang网址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.qfgolang.com/&#34;&gt;https://www.qfgolang.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_goroutine&#34;&gt;https://github.com/rubyhan1314/go_goroutine&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B9%B6%E5%8F%91/">并发</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>day15 课堂资料</title>
                <link>http://www.songx.fun/blog/day23-24mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/day24%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day23-24mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/day24%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;day15-课堂资料&#34;&gt;day15 课堂资料&lt;/h1&gt;
&lt;h2 id=&#34;上节课回顾&#34;&gt;上节课回顾&lt;/h2&gt;
&lt;p&gt;mysql数据库&lt;/p&gt;
&lt;p&gt;登录：&lt;/p&gt;
&lt;p&gt;​	dos窗口：mysql&lt;/p&gt;
&lt;p&gt;​		-u 用户名&lt;/p&gt;
&lt;p&gt;​		-p 密码&lt;/p&gt;
&lt;p&gt;​	mysql自带的命令行：&lt;/p&gt;
&lt;p&gt;​		直接输入密码&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​	可视化工具：&lt;/p&gt;
&lt;p&gt;数据库的基本常识：&lt;/p&gt;
&lt;p&gt;​	关系型的数据库：以行和列来组织数据。(二维表)&lt;/p&gt;
&lt;p&gt;安装mysql后：&lt;/p&gt;
&lt;p&gt;​	创建数据库：(以项目为单位)&lt;/p&gt;
&lt;p&gt;​		创建数据表：table&lt;/p&gt;
&lt;p&gt;​			行：一条数据，或者叫一条记录&lt;/p&gt;
&lt;p&gt;​			列：字段，属性，field&lt;/p&gt;
&lt;p&gt;SQL语句：&lt;/p&gt;
&lt;p&gt;​	DDL：数据定义语言&lt;/p&gt;
&lt;p&gt;​		create database&lt;/p&gt;
&lt;p&gt;​		create table&lt;/p&gt;
&lt;p&gt;​		alter talble&lt;/p&gt;
&lt;p&gt;​		drop table&lt;/p&gt;
&lt;p&gt;1.创建数据库：&lt;/p&gt;
&lt;p&gt;2.显示所有的数据库：show databases;&lt;/p&gt;
&lt;p&gt;3.切换数据库：use 数据库名;&lt;/p&gt;
&lt;p&gt;4.创建数据表：&lt;/p&gt;
&lt;p&gt;​	id：int，主键(非空+唯一)--&amp;gt;唯一标识，自增：auto_increment&lt;/p&gt;
&lt;p&gt;​	数据类型：&lt;/p&gt;
&lt;p&gt;​		数值型：int(长度)，float，double。。。&lt;/p&gt;
&lt;p&gt;​		字符型：char，varchar&lt;/p&gt;
&lt;p&gt;​		日期型：date，time，datetime&lt;/p&gt;
&lt;p&gt;5.插入数据：&lt;/p&gt;
&lt;p&gt;​	insert into 表名(字段。。。)values (数值。。。);&lt;/p&gt;
&lt;p&gt;6.修改表结构：&lt;/p&gt;
&lt;p&gt;​	alter table 表名 add/modify/change/drop&lt;/p&gt;
&lt;p&gt;​	rename to&lt;/p&gt;
&lt;p&gt;7.删除数据表：&lt;/p&gt;
&lt;p&gt;​	drop table 表名;&lt;/p&gt;
&lt;p&gt;8.修改数据：&lt;/p&gt;
&lt;p&gt;​	update 表名 set 字段=数值，字段=数值 [where 修改条件]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;=，!=,&amp;lt;&amp;gt;
&amp;gt;,&amp;lt;,&amp;gt;=,&amp;lt;=
or,and,not
between...and, in()
null	is null/is not null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9.删除数据：&lt;/p&gt;
&lt;p&gt;​	delete from 表名 [where 删除条件];&lt;/p&gt;
&lt;h2 id=&#34;一约束&#34;&gt;一、约束&lt;/h2&gt;
&lt;p&gt;约束：用于限制数据表中某列的数据的存储内容。&lt;/p&gt;
&lt;p&gt;​	非空约束，唯一约束&lt;/p&gt;
&lt;p&gt;主键约束：非空+唯一&lt;/p&gt;
&lt;p&gt;​	用作这个表中，主键所在的字段是该表的唯一标识。&lt;/p&gt;
&lt;p&gt;外键约束：保证数据的完整性和有效性。&lt;/p&gt;
&lt;p&gt;​	两张表：&lt;/p&gt;
&lt;p&gt;​		父表：主表&lt;/p&gt;
&lt;p&gt;​			主键&lt;/p&gt;
&lt;p&gt;​		子表：从表&lt;/p&gt;
&lt;p&gt;​			外键&lt;/p&gt;
&lt;p&gt;子表中设置外键的列，是父表中主键。那么子表中外键的列，的数值，就会收到父表中主键的数值的约束。&lt;/p&gt;
&lt;p&gt;创建父表：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mysql&#34;&gt;mysql&amp;gt; create table class(
    -&amp;gt; classno int(4) primary key,
    -&amp;gt; classname varchar(20),
    -&amp;gt; local varchar(30));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建子表：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; create table student(
    -&amp;gt; sid int(4) primary key auto_increment,
    -&amp;gt; sname varchar(30),
    -&amp;gt; age int(3),
    -&amp;gt; sex varchar(3),
    -&amp;gt; classno int(4),
    -&amp;gt; constraint fk_stu foreign key (classno) references class(classno));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加数据：&lt;/p&gt;
&lt;p&gt;​	父表：1,2,3&lt;/p&gt;
&lt;p&gt;​	子表：classno：受到父表的限制&lt;/p&gt;
&lt;p&gt;级联操作：父表的数据删除时候，子表中引用的数值？ on delete xxx&lt;/p&gt;
&lt;p&gt;​	默认：&lt;/p&gt;
&lt;p&gt;​	cascade：子表的数据随着父表一起被删除&lt;/p&gt;
&lt;p&gt;​	set null：父表被删除，子表置为null&lt;/p&gt;
&lt;p&gt;​	no action：&lt;/p&gt;
&lt;p&gt;删除student中原来的外键约束&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table student drop foreign key fk_stu;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新增外键约束：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; alter table student add constraint fk_stu foreign key(classno) references class(classno) on delete cascade;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父表的数据删除，子表的也随之删除。&lt;/p&gt;
&lt;h2 id=&#34;二查询&#34;&gt;二、查询&lt;/h2&gt;
&lt;h3 id=&#34;21-简单查询&#34;&gt;2.1 简单查询&lt;/h3&gt;
&lt;p&gt;1.查询指定的列：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select 列1，列2，列3.。。 from 表名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.起别名：as 可以省略不写&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select 列1 as 别名 from 表名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.处理null&lt;/p&gt;
&lt;p&gt;使用ifnull(a,b)，如果a列为空，就取b的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select ifnull(comm,0) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.去重：distinct&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select distinct job from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22-条件查询&#34;&gt;2.2 条件查询&lt;/h3&gt;
&lt;p&gt;在检索数据库中的数据时候，需要满足某些条件，才能被检索到，使用where关键字，来限制检索的条件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;比较运算符：=，!+=,&amp;lt;&amp;gt;,&amp;gt;,&amp;lt;,&amp;gt;=,&amp;lt;=

逻辑运算符：and ，or， not

范围：between and，in

null：is null，is not null

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;练习1：查询1981年以后入职的员工信息&lt;/p&gt;
&lt;p&gt;练习2：查询部门编号为30或者工资大于2000的员工信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模糊查询：like&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;%：匹配0-多个任意的字符&lt;/p&gt;
&lt;p&gt;_：匹配1个任意字符&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;//名字的第三个字母为a的员工信息
mysql&amp;gt; select * from emp where ename like &#39;__a%&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;：orderby&lt;/p&gt;
&lt;p&gt;asc：升序，默认&lt;/p&gt;
&lt;p&gt;desc：降序&lt;/p&gt;
&lt;p&gt;select查询完后，排序要写在整个sql语句的最后。&lt;/p&gt;
&lt;h3 id=&#34;23-统计函数&#34;&gt;2.3 统计函数&lt;/h3&gt;
&lt;p&gt;也叫聚合函数，通常用于求整个表中某列的数据的：总和，平均值，最大值，最小值。通常不搭配表中的字段一起查询。&lt;/p&gt;
&lt;p&gt;sum(),&lt;/p&gt;
&lt;p&gt;avg(),&lt;/p&gt;
&lt;p&gt;max()&lt;/p&gt;
&lt;p&gt;min(),&lt;/p&gt;
&lt;p&gt;count(*/主键)&lt;/p&gt;
&lt;p&gt;练习1：求部门20中员工的平均工资，工资总和，工资最大值，最小值，人数。&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select ename,sum(sal),avg(sal),max(sal),min(sal) ,count(empno),count(comm)from emp where deptno=20;&lt;/p&gt;
&lt;h3 id=&#34;24-分组&#34;&gt;2.4 分组&lt;/h3&gt;
&lt;p&gt;group by 列&lt;/p&gt;
&lt;p&gt;按照某列分组，该列有几种取值，就分为几组。&lt;/p&gt;
&lt;p&gt;练习1：按照部门来分组，查询每个部门的最高工资，最低工资，平均工资。&lt;/p&gt;
&lt;p&gt;练习2：求每种工作的最高薪资，最低薪资，以及人数。&lt;/p&gt;
&lt;p&gt;练习3：查询部门人数超过5人的部门。&lt;/p&gt;
&lt;h3 id=&#34;25-分页&#34;&gt;2.5 分页&lt;/h3&gt;
&lt;p&gt;limit start，count。&lt;/p&gt;
&lt;p&gt;练习：按照工资排序，获取前5条数据。&lt;/p&gt;
&lt;h2 id=&#34;三多表联查&#34;&gt;三、多表联查&lt;/h2&gt;
&lt;h3 id=&#34;31-内连接&#34;&gt;3.1 内连接&lt;/h3&gt;
&lt;p&gt;查询出来的数据一定满足链接的规则。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select e.*,d.* from emp e inner join dept d on e.deptno=d.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32-左外链接&#34;&gt;3.2 左外链接&lt;/h3&gt;
&lt;p&gt;因为内连接的查询结果，并不是所有的数据，而是满足规则的数据。&lt;/p&gt;
&lt;p&gt;左外链接，右外连接是为了补充内连接的查询结果的。&lt;/p&gt;
&lt;p&gt;左表记录无论是否满足条件都会查询出来，而右表只有满足条件才能查询出来。左表中不满足条件的记录，右表部分都为NULL&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; select * from emp e left outer join dept d on e.deptno=d.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;33-右外连接&#34;&gt;3.3 右外连接&lt;/h3&gt;
&lt;p&gt;右表记录无论是否满足条件都会查询出来，而左表只有满足条件才能查询出来。右表中不满足条件的记录，左表部分都为NULL&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; select * from emp e right outer join dept d on e.deptno=d.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;练习1：查询所有的部门，以及对应的员工信息。&lt;/p&gt;
&lt;p&gt;练习2：查询每个员工的员工信息，工资等级。emp，salgrade&lt;/p&gt;
&lt;p&gt;练习3：查询每个员工的员工信息，部门名称，部门位置，工资等级&lt;/p&gt;
&lt;p&gt;练习4：查询在部门在纽约的员工信息，部门名称，工资等级。&lt;/p&gt;
&lt;p&gt;练习5：查询每个部门的人数，部门名称，部门编号。&lt;/p&gt;
&lt;p&gt;自连接：&lt;/p&gt;
&lt;p&gt;查询员工的姓名和上级的姓名：&lt;/p&gt;
&lt;p&gt;select e.empno,e.ename,e.mgr,m.empno,m.ename from emp e,emp m where e.mgr=m.empno;&lt;/p&gt;
&lt;h2 id=&#34;四子查询&#34;&gt;四、子查询&lt;/h2&gt;
&lt;p&gt;1.查询比allen工资高的员工信息。&lt;/p&gt;
&lt;p&gt;select * from emp where sal &amp;gt; (select sal from emp where ename=&#39;allen&#39;);&lt;/p&gt;
&lt;p&gt;练习1：查询工资不是最高的，也不是最低的员工信息。&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from emp where sal !=(select max(sal) from emp ) and sal !=(select min(sal) from emp);&lt;/p&gt;
&lt;p&gt;练习2：不是销售部的员工信息&lt;/p&gt;
&lt;p&gt;dname---&amp;gt;deptno&lt;/p&gt;
&lt;p&gt;思路一：&lt;/p&gt;
&lt;p&gt;select deptno from dept where dname=&#39;sales&#39;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from emp where deptno != (select deptno from dept where dname=&#39;sales&#39;);&lt;/p&gt;
&lt;p&gt;思路二：&lt;/p&gt;
&lt;p&gt;select deptno from dept where dname !=&#39;sales&#39;;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from emp where deptno in(select deptno from dept where dname !=&#39;sales&#39;);&lt;/p&gt;
&lt;p&gt;练习3：查询员工信息，要求工资高于部门编号为10的中的任意员工即可&lt;/p&gt;
&lt;p&gt;思路一：&lt;/p&gt;
&lt;p&gt;select mix(sal) from emp where deptno=10; //&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from emp where sal &amp;gt;(select min(sal) from emp where deptno=10);&lt;/p&gt;
&lt;p&gt;思路二：&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from emp where sal &amp;gt;any (select sal from emp where deptno=10);&lt;/p&gt;
&lt;p&gt;练习4：查询员工信息，工资大于30部门的所有人&lt;/p&gt;
&lt;p&gt;思路一：&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from emp where sal &amp;gt;(select max(sal) from emp where deptno=30);&lt;/p&gt;
&lt;p&gt;思路二：&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from emp where sal &amp;gt; all(select sal from emp where deptno=30);&lt;/p&gt;
&lt;p&gt;练习5：查询本公司工资最高的员工详细信息&lt;/p&gt;
&lt;p&gt;select max(sal) from emp;&lt;/p&gt;
&lt;p&gt;select * from emp e,dept d&lt;/p&gt;
&lt;p&gt;where sal=(select max(sal) from emp)  and e.deptno=d.deptno;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select e.&lt;em&gt;,d.&lt;/em&gt; from emp e,dept d where sal=(select min(sal) from emp) and e.deptno=d.deptno ;&lt;/p&gt;
&lt;h2 id=&#34;五总结&#34;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;主外键约束&lt;/p&gt;
&lt;p&gt;​	主键&lt;/p&gt;
&lt;p&gt;​	外键：两张表：父表，子表&lt;/p&gt;
&lt;p&gt;​	子表中的外键必须是父表中的主键。&lt;/p&gt;
&lt;p&gt;​		on delete set null/cascade/no action&lt;/p&gt;
&lt;p&gt;查询&lt;/p&gt;
&lt;p&gt;​	简单查询：去重，别名，加减乘除运算，ifnull(a, b)&lt;/p&gt;
&lt;p&gt;​	条件查询：where&lt;/p&gt;
&lt;p&gt;​				=，!=,&amp;lt;&amp;gt;,&amp;gt;,&amp;lt;,&amp;gt;=,&amp;lt;=&lt;/p&gt;
&lt;p&gt;​				and, or, not&lt;/p&gt;
&lt;p&gt;​				between and , in&lt;/p&gt;
&lt;p&gt;​				is null ,is not null&lt;/p&gt;
&lt;p&gt;​			排序：order by&lt;/p&gt;
&lt;p&gt;​				asc，desc&lt;/p&gt;
&lt;p&gt;​			模糊查询：like&lt;/p&gt;
&lt;p&gt;​				_,%&lt;/p&gt;
&lt;p&gt;​	聚合函数：max(),min(),count(),sum(),avg()&lt;/p&gt;
&lt;p&gt;​	分页：limit start，count&lt;/p&gt;
&lt;p&gt;​	分组：group by&lt;/p&gt;
&lt;p&gt;​		having&lt;/p&gt;
&lt;p&gt;多表联查：&lt;/p&gt;
&lt;p&gt;​	内连接：select 。。。 from 表1 别名 inner join 表2 别名 on 连接条件&lt;/p&gt;
&lt;p&gt;​	外连接：左外，右外&lt;/p&gt;
&lt;p&gt;​		select 。。 from 左表 别名 left outer join 右表 别名 on 连接条件&lt;/p&gt;
&lt;p&gt;​		select 。。 from 左表 别名 right outer join 右表 别名 on 连接条件&lt;/p&gt;
&lt;p&gt;子查询：&lt;/p&gt;
&lt;p&gt;​	select 的嵌套&lt;/p&gt;
&lt;p&gt;​	select 的查询结果：&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/mysql/">mysql</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/db/">db</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/mysql/">mysql</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>File文件操作</title>
                <link>http://www.songx.fun/blog/day16-20go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/day16_file%E6%93%8D%E4%BD%9C/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day16-20go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/day16_file%E6%93%8D%E4%BD%9C/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;一file文件操作&#34;&gt;一、File文件操作&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，file类是在os包中的，封装了底层的文件描述符和相关信息，同时封装了Read和Write的实现。&lt;/p&gt;
&lt;h2 id=&#34;1fileinfo接口&#34;&gt;1、FileInfo接口&lt;/h2&gt;
&lt;p&gt;FileInfo接口中定义了File信息相关的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type FileInfo interface {
	Name() string       // base name of the file 文件名.扩展名 aa.txt
	Size() int64        // 文件大小，字节数 12540
	Mode() FileMode     // 文件权限 -rw-rw-rw-
	ModTime() time.Time // 修改时间 2018-04-13 16:30:53 +0800 CST
	IsDir() bool        // 是否文件夹
	Sys() interface{}   // 基础数据源接口(can return nil)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2权限&#34;&gt;2、权限&lt;/h2&gt;
&lt;p&gt;至于操作权限perm，除非创建文件时才需要指定，不需要创建新文件时可以将其设定为０。虽然go语言给perm权限设定了很多的常量，但是习惯上也可以直接使用数字，如0666(具体含义和Unix系统的一致)。&lt;/p&gt;
&lt;p&gt;权限控制：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;linux 下有2种文件权限表示方式，即“符号表示”和“八进制表示”。

（1）符号表示方式:
-      ---         ---        ---
type   owner       group      others
文件的权限是这样子分配的 读 写 可执行 分别对应的是 r w x 如果没有那一个权限，用 - 代替
(-文件 d目录 |连接符号)
例如：-rwxr-xr-x


（2）八进制表示方式：	
r ——&amp;gt; 004
w ——&amp;gt; 002
x ——&amp;gt; 001
- ——&amp;gt; 000

0755
0777
0555
0444
0666
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3打开模式&#34;&gt;3、打开模式&lt;/h2&gt;
&lt;p&gt;文件打开模式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
    O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件
    O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件
    O_RDWR   int = syscall.O_RDWR   // 读写模式打开文件
    O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部
    O_CREATE int = syscall.O_CREAT  // 如果不存在将创建一个新文件
    O_EXCL   int = syscall.O_EXCL   // 和O_CREATE配合使用，文件必须不存在
    O_SYNC   int = syscall.O_SYNC   // 打开文件用于同步I/O
    O_TRUNC  int = syscall.O_TRUNC  // 如果可能，打开时清空文件
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4file操作&#34;&gt;4、File操作&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type File
//File代表一个打开的文件对象。

func Create(name string) (file *File, err error)
//Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件）。如果成功，返回的文件对象可用于I/O；对应的文件描述符具有O_RDWR模式。如果出错，错误底层类型是*PathError。

func Open(name string) (file *File, err error)
//Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。

func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
//OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。

func NewFile(fd uintptr, name string) *File
//NewFile使用给出的Unix文件描述符和名称创建一个文件。

func Pipe() (r *File, w *File, err error)
//Pipe返回一对关联的文件对象。从r的读取将返回写入w的数据。本函数会返回两个文件对象和可能的错误。

func (f *File) Name() string
//Name方法返回（提供给Open/Create等方法的）文件名称。

func (f *File) Stat() (fi FileInfo, err error)
//Stat返回描述文件f的FileInfo类型值。如果出错，错误底层类型是*PathError。

func (f *File) Fd() uintptr
//Fd返回与文件f对应的整数类型的Unix文件描述符。

func (f *File) Chdir() error
//Chdir将当前工作目录修改为f，f必须是一个目录。如果出错，错误底层类型是*PathError。

func (f *File) Chmod(mode FileMode) error
//Chmod修改文件的模式。如果出错，错误底层类型是*PathError。

func (f *File) Chown(uid, gid int) error
//Chown修改文件的用户ID和组ID。如果出错，错误底层类型是*PathError。

func (f *File) Close() error
//Close关闭文件f，使文件不能用于读写。它返回可能出现的错误。


func (f *File) Readdir(n int) (fi []FileInfo, err error)
//Readdir读取目录f的内容，返回一个有n个成员的[]FileInfo，这些FileInfo是被Lstat返回的，采用目录顺序。对本函数的下一次调用会返回上一次调用剩余未读取的内容的信息。如果n&amp;gt;0，Readdir函数会返回一个最多n个成员的切片。这时，如果Readdir返回一个空切片，它会返回一个非nil的错误说明原因。如果到达了目录f的结尾，返回值err会是io.EOF。如果n&amp;lt;=0，Readdir函数返回目录中剩余所有文件对象的FileInfo构成的切片。此时，如果Readdir调用成功（读取所有内容直到结尾），它会返回该切片和nil的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的FileInfo构成的切片和该错误。

func (f *File) Readdirnames(n int) (names []string, err error)
//Readdir读取目录f的内容，返回一个有n个成员的[]string，切片成员为目录中文件对象的名字，采用目录顺序。对本函数的下一次调用会返回上一次调用剩余未读取的内容的信息。如果n&amp;gt;0，Readdir函数会返回一个最多n个成员的切片。这时，如果Readdir返回一个空切片，它会返回一个非nil的错误说明原因。如果到达了目录f的结尾，返回值err会是io.EOF。如果n&amp;lt;=0，Readdir函数返回目录中剩余所有文件对象的名字构成的切片。此时，如果Readdir调用成功（读取所有内容直到结尾），它会返回该切片和nil的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的名字构成的切片和该错误。

func (f *File) Truncate(size int64) error
//Truncate改变文件的大小，它不会改变I/O的当前位置。 如果截断文件，多出的部分就会被丢弃。如果出错，错误底层类型是*PathError。



&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5示例代码&#34;&gt;5、示例代码&lt;/h2&gt;
&lt;p&gt;文件信息：FileInfo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;os&amp;quot;
	&amp;quot;fmt&amp;quot;
)

func main() {
	/*
	FileInfo：文件信息
		interface
			Name()，文件名
			Size()，文件大小，字节为单位
			IsDir()，是否是目录
			ModTime()，修改时间
			Mode()，权限

	 */
	fileInfo,err :=  os.Stat(&amp;quot;/Users/ruby/Documents/pro/a/aa.txt&amp;quot;)
	if err != nil{
		fmt.Println(&amp;quot;err :&amp;quot;,err)
		return
	}
	fmt.Printf(&amp;quot;%T\n&amp;quot;,fileInfo)
	//文件名
	fmt.Println(fileInfo.Name())
	//文件大小
	fmt.Println(fileInfo.Size())
	//是否是目录
	fmt.Println(fileInfo.IsDir()) //IsDirectory
	//修改时间
	fmt.Println(fileInfo.ModTime())
	//权限
	fmt.Println(fileInfo.Mode()) //-rw-r--r--
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/fileyunxing1.png&#34; alt=&#34;fileyunxing1&#34;&gt;&lt;/p&gt;
&lt;p&gt;文件操作实例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;path/filepath&amp;quot;
	&amp;quot;path&amp;quot;
	&amp;quot;os&amp;quot;
)

func main() {
	/*
	文件操作：
	1.路径：
		相对路径：relative
			ab.txt
			相对于当前工程
		绝对路径：absolute
			/Users/ruby/Documents/pro/a/aa.txt

		.当前目录
		..上一层
	2.创建文件夹，如果文件夹存在，创建失败
		os.MkDir()，创建一层
		os.MkDirAll()，可以创建多层

	3.创建文件，Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件）
		os.Create()，创建文件

	4.打开文件：让当前的程序，和指定的文件之间建立一个连接
		os.Open(filename)
		os.OpenFile(filename,mode,perm)

	5.关闭文件：程序和文件之间的链接断开。
		file.Close()

	5.删除文件或目录：慎用，慎用，再慎用
		os.Remove()，删除文件和空目录
		os.RemoveAll()，删除所有
	 */
	 //1.路径
	 fileName1:=&amp;quot;/Users/ruby/Documents/pro/a/aa.txt&amp;quot;
	 fileName2:=&amp;quot;bb.txt&amp;quot;
	 fmt.Println(filepath.IsAbs(fileName1)) //true
	 fmt.Println(filepath.IsAbs(fileName2)) //false
	 fmt.Println(filepath.Abs(fileName1))
	 fmt.Println(filepath.Abs(fileName2)) // /Users/ruby/go/src/l_file/bb.txt

	 fmt.Println(&amp;quot;获取父目录：&amp;quot;,path.Join(fileName1,&amp;quot;..&amp;quot;))

	 //2.创建目录
	 //err := os.Mkdir(&amp;quot;/Users/ruby/Documents/pro/a/bb&amp;quot;,os.ModePerm)
	 //if err != nil{
	 //	fmt.Println(&amp;quot;err:&amp;quot;,err)
	 //	return
	 //}
	 //fmt.Println(&amp;quot;文件夹创建成功。。&amp;quot;)
	 //err :=os.MkdirAll(&amp;quot;/Users/ruby/Documents/pro/a/cc/dd/ee&amp;quot;,os.ModePerm)
	 //if err != nil{
	 //	fmt.Println(&amp;quot;err:&amp;quot;,err)
	 //	return
	 //}
	 //fmt.Println(&amp;quot;多层文件夹创建成功&amp;quot;)

	 //3.创建文件:Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件）
	 //file1,err :=os.Create(&amp;quot;/Users/ruby/Documents/pro/a/ab.txt&amp;quot;)
	 //if err != nil{
	 //	fmt.Println(&amp;quot;err：&amp;quot;,err)
	 //	return
	 //}
	 //fmt.Println(file1)

	 //file2,err := os.Create(fileName2)//创建相对路径的文件，是以当前工程为参照的
	 //if err != nil{
	 //	fmt.Println(&amp;quot;err :&amp;quot;,err)
	 //	return
	 //}
	 //fmt.Println(file2)

	 //4.打开文件：
	 //file3 ,err := os.Open(fileName1) //只读的
	 //if err != nil{
	 //	fmt.Println(&amp;quot;err:&amp;quot;,err)
	 //	return
	 //}
	 //fmt.Println(file3)
	/*
	第一个参数：文件名称
	第二个参数：文件的打开方式
		const (
	// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.
		O_RDONLY int = syscall.O_RDONLY // open the file read-only.
		O_WRONLY int = syscall.O_WRONLY // open the file write-only.
		O_RDWR   int = syscall.O_RDWR   // open the file read-write.
		// The remaining values may be or&#39;ed in to control behavior.
		O_APPEND int = syscall.O_APPEND // append data to the file when writing.
		O_CREATE int = syscall.O_CREAT  // create a new file if none exists.
		O_EXCL   int = syscall.O_EXCL   // used with O_CREATE, file must not exist.
		O_SYNC   int = syscall.O_SYNC   // open for synchronous I/O.
		O_TRUNC  int = syscall.O_TRUNC  // truncate regular writable file when opened.
	)
	第三个参数：文件的权限：文件不存在创建文件，需要指定权限
	 */
	 //file4,err := os.OpenFile(fileName1,os.O_RDONLY|os.O_WRONLY,os.ModePerm)
	 //if err != nil{
	 //	fmt.Println(&amp;quot;err:&amp;quot;,err)
	 //	return
	 //}
	 //fmt.Println(file4)

	 //5关闭文件，
	 //file4.Close()

	 //6.删除文件或文件夹：
	 //删除文件
	//err :=  os.Remove(&amp;quot;/Users/ruby/Documents/pro/a/aa.txt&amp;quot;)
	//if err != nil{
	//	fmt.Println(&amp;quot;err:&amp;quot;,err)
	//	return
	//}
	//fmt.Println(&amp;quot;删除文件成功。。&amp;quot;)
	//删除目录
	err :=  os.RemoveAll(&amp;quot;/Users/ruby/Documents/pro/a/cc&amp;quot;)
	if err != nil{
		fmt.Println(&amp;quot;err:&amp;quot;,err)
		return
	}
	fmt.Println(&amp;quot;删除目录成功。。&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二io操作&#34;&gt;二、I/O操作&lt;/h1&gt;
&lt;p&gt;I/O操作也叫输入输出操作。其中I是指Input，O是指Output，用于读或者写数据的，有些语言中也叫流操作，是指数据通信的通道。&lt;/p&gt;
&lt;p&gt;Golang 标准库对 IO 的抽象非常精巧，各个组件可以随意组合，可以作为接口设计的典范。&lt;/p&gt;
&lt;h2 id=&#34;1io包&#34;&gt;1、io包&lt;/h2&gt;
&lt;p&gt;io包中提供I/O原始操作的一系列接口。它主要包装了一些已有的实现，如 os 包中的那些，并将这些抽象成为实用性的功能和一些其他相关的接口。&lt;/p&gt;
&lt;p&gt;由于这些接口和原始的操作以不同的实现包装了低级操作，客户不应假定它们对于并行执行是安全的。&lt;/p&gt;
&lt;p&gt;在io包中最重要的是两个接口：Reader和Writer接口，首先来介绍这两个接口．&lt;/p&gt;
&lt;p&gt;Reader接口的定义，Read()方法用于读取数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Reader interface {
        Read(p []byte) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &amp;lt;= n &amp;lt;= len(p)）以及任何遇到的错误。即使 Read 返回的 n &amp;lt; len(p)，它也会在调用过程中使用 p的全部作为暂存空间。若一些数据可用但不到 len(p) 个字节，Read 会照例返回可用的东西，而不是等待更多。

当 Read 在成功读取 n &amp;gt; 0 个字节后遇到一个错误或 EOF 情况，它就会返回读取的字节数。它会从相同的调用中返回（非nil的）错误或从随后的调用中返回错误（和 n == 0）。这种一般情况的一个例子就是 Reader 在输入流结束时会返回一个非零的字节数，可能的返回不是 err == EOF 就是 err == nil。无论如何，下一个 Read 都应当返回 0, EOF。

调用者应当总在考虑到错误 err 前处理 n &amp;gt; 0 的字节。这样做可以在读取一些字节，以及允许的 EOF 行为后正确地处理I/O错误。

Read 的实现会阻止返回零字节的计数和一个 nil 错误，调用者应将这种情况视作空操作。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Writer接口的定义，Write()方法用于写出数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Writer interface {
        Write(p []byte) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Write 将 len(p) 个字节从 p 中写入到基本数据流中。它返回从 p 中被写入的字节数n（0 &amp;lt;= n &amp;lt;= len(p)）以及任何遇到的引起写入提前停止的错误。若 Write 返回的n &amp;lt; len(p)，它就必须返回一个非nil的错误。Write 不能修改此切片的数据，即便它是临时的。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Seeker接口的定义，封装了基本的 Seek 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Seeker interface {
        Seek(offset int64, whence int) (int64, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Seeker 用来移动数据的读写指针
Seek 设置下一次读写操作的指针位置，每次的读写操作都是从指针位置开始的
whence 的含义：
	如果 whence 为 0：表示从数据的开头开始移动指针
	如果 whence 为 1：表示从数据的当前指针位置开始移动指针
	如果 whence 为 2：表示从数据的尾部开始移动指针
offset 是指针移动的偏移量
	返回移动后的指针位置和移动过程中遇到的任何错误
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ReaderFrom接口的定义，封装了基本的 ReadFrom 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ReaderFrom interface {
        ReadFrom(r Reader) (n int64, err error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ReadFrom 从 r 中读取数据到对象的数据流中
	直到 r 返回 EOF 或 r 出现读取错误为止
	返回值 n 是读取的字节数
	返回值 err 就是 r 的返回值 err
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;WriterTo接口的定义，封装了基本的 WriteTo 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type WriterTo interface {
        WriteTo(w Writer) (n int64, err error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;WriterTo 将对象的数据流写入到 w 中
	直到对象的数据流全部写入完毕或遇到写入错误为止
	返回值 n 是写入的字节数
	返回值 err 就是 w 的返回值 err
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义ReaderAt接口，ReaderAt 接口封装了基本的 ReadAt 方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ReaderAt interface {
        ReadAt(p []byte, off int64) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ReadAt 从对象数据流的 off 处读出数据到 p 中
	忽略数据的读写指针，从数据的起始位置偏移 off 处开始读取
	如果对象的数据流只有部分可用，不足以填满 p
	则 ReadAt 将等待所有数据可用之后，继续向 p 中写入
	直到将 p 填满后再返回
	在这点上 ReadAt 要比 Read 更严格
	返回读取的字节数 n 和读取时遇到的错误
	如果 n &amp;lt; len(p)，则需要返回一个 err 值来说明
	为什么没有将 p 填满（比如 EOF）
	如果 n = len(p)，而且对象的数据没有全部读完，则
	err 将返回 nil
	如果 n = len(p)，而且对象的数据刚好全部读完，则
	err 将返回 EOF 或者 nil（不确定）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义WriterAt接口，WriterAt 接口封装了基本的 WriteAt 方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type WriterAt interface {
        WriteAt(p []byte, off int64) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;WriteAt 将 p 中的数据写入到对象数据流的 off 处
	忽略数据的读写指针，从数据的起始位置偏移 off 处开始写入
	返回写入的字节数和写入时遇到的错误
	如果 n &amp;lt; len(p)，则必须返回一个 err 值来说明
	为什么没有将 p 完全写入
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他。。。&lt;/p&gt;
&lt;h2 id=&#34;2文件读写&#34;&gt;2、文件读写&lt;/h2&gt;
&lt;p&gt;file类是在os包中的，封装了底层的文件描述符和相关信息，同时封装了Read和Write的实现。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
func (f *File) Read(b []byte) (n int, err error)
//Read方法从f中读取最多len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取0个字节且返回值err为io.EOF。

func (f *File) ReadAt(b []byte, off int64) (n int, err error)
//ReadAt从指定的位置（相对于文件开始位置）读取len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。当n&amp;lt;len(b)时，本方法总是会返回错误；如果是因为到达文件结尾，返回值err会是io.EOF。

func (f *File) Write(b []byte) (n int, err error)
//Write向文件中写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。

func (f *File) WriteString(s string) (ret int, err error)
//WriteString类似Write，但接受一个字符串参数。

func (f *File) WriteAt(b []byte, off int64) (n int, err error)
//WriteAt在指定的位置（相对于文件开始位置）写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。

func (f *File) Seek(offset int64, whence int) (ret int64, err error)
//Seek设置下一次读/写的位置。offset为相对偏移量，而whence决定相对位置：0为相对文件开头，1为相对当前位置，2为相对文件结尾。它返回新的偏移量（相对开头）和可能的错误。

func (f *File) Sync() (err error)
//Sync递交文件的当前内容进行稳定的存储。一般来说，这表示将文件系统的最近写入的数据在内存中的拷贝刷新到硬盘中稳定保存。


&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3实例代码&#34;&gt;3、实例代码&lt;/h2&gt;
&lt;p&gt;读取文件中的数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;os&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
)

func main() {
	/*
	读取数据：
		Reader接口：
			Read(p []byte)(n int, error)
	 */
	 //读取本地aa.txt文件中的数据
	 //step1：打开文件
	 fileName := &amp;quot;/Users/ruby/Documents/pro/a/aa.txt&amp;quot;
	 file,err := os.Open(fileName)
	 if err != nil{
	 	fmt.Println(&amp;quot;err:&amp;quot;,err)
	 	return
	 }
	 //step3：关闭文件
	 defer file.Close()

	 //step2：读取数据
	 bs := make([]byte,4,4)
	 /*
	 //第一次读取
	 n,err :=file.Read(bs)
	 fmt.Println(err) //&amp;lt;nil&amp;gt;
	 fmt.Println(n) //4
	 fmt.Println(bs) //[97 98 99 100]
	fmt.Println(string(bs)) //abcd

	//第二次读取
	n,err = file.Read(bs)
	fmt.Println(err)//&amp;lt;nil&amp;gt;
	fmt.Println(n)//4
	fmt.Println(bs) //[101 102 103 104]
	fmt.Println(string(bs)) //efgh

	//第三次读取
	n,err = file.Read(bs)
	fmt.Println(err) //&amp;lt;nil&amp;gt;
	fmt.Println(n) //2
	fmt.Println(bs) //[105 106 103 104]
	fmt.Println(string(bs)) //ijgh

	//第四次读取
	n,err = file.Read(bs)
	fmt.Println(err) //EOF
	fmt.Println(n) //0
	 */
	 n := -1
	 for{
	 	n,err = file.Read(bs)
	 	if n == 0 || err == io.EOF{
	 		fmt.Println(&amp;quot;读取到了文件的末尾，结束读取操作。。&amp;quot;)
	 		break
		}
	 	fmt.Println(string(bs[:n]))
	 }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写出数据到本地文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;os&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
)

func main() {
	/*
	写出数据：
	 */

	 fileName := &amp;quot;/Users/ruby/Documents/pro/a/ab.txt&amp;quot;
	//step1：打开文件
	//step2：写出数据
	//step3：关闭文件
	//file,err := os.Open(fileName)
	file,err := os.OpenFile(fileName,os.O_CREATE|os.O_WRONLY|os.O_APPEND,os.ModePerm)
	if err != nil{
		fmt.Println(err)
		return
	}
	defer file.Close()

	//写出数据
	//bs :=[]byte{65,66,67,68,69,70}//A,B,C,D,E,F
	bs :=[] byte{97,98,99,100} //a,b,c,d
	//n,err := file.Write(bs)
	n,err := file.Write(bs[:2])
	fmt.Println(n)
	HandleErr(err)
	file.WriteString(&amp;quot;\n&amp;quot;)

	//直接写出字符串
	n,err = file.WriteString(&amp;quot;HelloWorld&amp;quot;)
	fmt.Println(n)
	HandleErr(err)

	file.WriteString(&amp;quot;\n&amp;quot;)
	n,err =file.Write([]byte(&amp;quot;today&amp;quot;))
	fmt.Println(n)
	HandleErr(err)

}

func HandleErr(err error){
	if err != nil{
		log.Fatal(err)
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;三文件复制&#34;&gt;三、文件复制&lt;/h1&gt;
&lt;p&gt;在io包中主要是操作流的一些方法，今天主要学习一下copy。就是把一个文件复制到另一个目录下。&lt;/p&gt;
&lt;p&gt;它的原理就是通过程序，从源文件读取文件中的数据，在写出到目标文件里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/copyfile.png&#34; alt=&#34;copyfile&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1方法一io包下的read和write方法实现&#34;&gt;1、方法一：io包下的Read()和Write()方法实现&lt;/h2&gt;
&lt;p&gt;我们可以通过io包下的Read()和Write()方法，边读边写，就能够实现文件的复制。这个方法是按块读取文件，块的大小也会影响到程序的性能。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;}
/*
该函数的功能：实现文件的拷贝，返回值是拷贝的总数量(字节),错误
 */
func copyFile1(srcFile,destFile string)(int,error){
	file1,err:=os.Open(srcFile)
	if err != nil{
		return 0,err
	}
	file2,err:=os.OpenFile(destFile,os.O_WRONLY|os.O_CREATE,os.ModePerm)
	if err !=nil{
		return 0,err
	}
	defer file1.Close()
	defer file2.Close()
	//拷贝数据
	bs := make([]byte,1024,1024)
	n :=-1//读取的数据量
	total := 0
	for {
		n,err = file1.Read(bs)
		if err == io.EOF || n == 0{
			fmt.Println(&amp;quot;拷贝完毕。。&amp;quot;)
			break
		}else if err !=nil{
			fmt.Println(&amp;quot;报错了。。。&amp;quot;)
			return total,err
		}
		total += n
		file2.Write(bs[:n])
	}
	return total,nil

}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2方法二io包下的copy方法实现&#34;&gt;2、方法二：io包下的Copy()方法实现&lt;/h2&gt;
&lt;p&gt;我们也可以直接使用io包下的Copy()方法。&lt;/p&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func copyFile2(srcFile, destFile string)(int64,error){
	file1,err:=os.Open(srcFile)
	if err != nil{
		return 0,err
	}
	file2,err:=os.OpenFile(destFile,os.O_WRONLY|os.O_CREATE,os.ModePerm)
	if err !=nil{
		return 0,err
	}
	defer file1.Close()
	defer file2.Close()

	return io.Copy(file2,file1)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;扩展内容&#34;&gt;扩展内容：&lt;/h3&gt;
&lt;p&gt;在io包（golang 版本 1.12）中，不止提供了Copy()方法，还有另外2个公开的copy方法：CopyN()，CopyBuffer()。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Copy（dst,src） 为复制src 全部到 dst 中。

CopyN(dst,src,n) 为复制src 中 n 个字节到 dst。

CopyBuffer（dst,src,buf）为指定一个buf缓存区，以这个大小完全复制。

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;他们的关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/20190316084535903.jpg&#34; alt=&#34;20190316084535903&#34;&gt;&lt;/p&gt;
&lt;p&gt;(图片来自网络)&lt;/p&gt;
&lt;p&gt;从图可以看出，无论是哪个copy方法最终都是由copyBuffer（）这个私有方法实现的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func copyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error) {
	// If the reader has a WriteTo method, use it to do the copy.
	// Avoids an allocation and a copy.
	if wt, ok := src.(WriterTo); ok {
		return wt.WriteTo(dst)
	}
	// Similarly, if the writer has a ReadFrom method, use it to do the copy.
	if rt, ok := dst.(ReaderFrom); ok {
		return rt.ReadFrom(src)
	}
	if buf == nil {
		size := 32 * 1024
		if l, ok := src.(*LimitedReader); ok &amp;amp;&amp;amp; int64(size) &amp;gt; l.N {
			if l.N &amp;lt; 1 {
				size = 1
			} else {
				size = int(l.N)
			}
		}
		buf = make([]byte, size)
	}
	for {
		nr, er := src.Read(buf)
		if nr &amp;gt; 0 {
			nw, ew := dst.Write(buf[0:nr])
			if nw &amp;gt; 0 {
				written += int64(nw)
			}
			if ew != nil {
				err = ew
				break
			}
			if nr != nw {
				err = ErrShortWrite
				break
			}
		}
		if er != nil {
			if er != EOF {
				err = er
			}
			break
		}
	}
	return written, err
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从这部分代码可以看出，复制主要分为3种。&lt;/p&gt;
&lt;p&gt;1.如果被复制的Reader（src）会尝试能否断言成writerTo，如果可以则直接调用下面的writerTo方法&lt;/p&gt;
&lt;p&gt;2.如果 Writer（dst） 会尝试能否断言成ReadFrom ，如果可以则直接调用下面的readfrom方法&lt;/p&gt;
&lt;p&gt;3.如果都木有实现，则调用底层read实现复制。&lt;/p&gt;
&lt;p&gt;其中，有这么一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if buf == nil {
		size := 32 * 1024
		if l, ok := src.(*LimitedReader); ok &amp;amp;&amp;amp; int64(size) &amp;gt; l.N {
			if l.N &amp;lt; 1 {
				size = 1
			} else {
				size = int(l.N)
			}
		}
		buf = make([]byte, size)
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这部分主要是实现了对Copy和CopyN的处理。通过上面的调用关系图，我们看出CopyN在调用后，会把Reader转成LimiteReader。&lt;/p&gt;
&lt;p&gt;区别是如果Copy，直接建立一个缓存区默认大小为 32* 1024 的buf，如果是CopyN 会先判断 要复制的字节数，如果小于默认大小，会创建一个等于要复制字节数的buf。&lt;/p&gt;
&lt;h2 id=&#34;3方法三ioutil包&#34;&gt;3、方法三：ioutil包&lt;/h2&gt;
&lt;p&gt;第三种方法是使用ioutil包中的 &lt;code&gt;ioutil.WriteFile()&lt;/code&gt;和 &lt;code&gt;ioutil.ReadFile()&lt;/code&gt;，但由于使用一次性读取文件，再一次性写入文件的方式，所以该方法不适用于大文件，容易内存溢出。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
func copyFile3(srcFile, destFile string)(int,error){
	input, err := ioutil.ReadFile(srcFile)
	if err != nil {
		fmt.Println(err)
		return 0,err
	}

	err = ioutil.WriteFile(destFile, input, 0644)
	if err != nil {
		fmt.Println(&amp;quot;操作失败：&amp;quot;, destFile)
		fmt.Println(err)
		return 0,err
	}

	return len(input),nil
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4总结&#34;&gt;4、总结&lt;/h2&gt;
&lt;p&gt;最后，我们来测试一下这3种拷贝需要花费时间，拷贝的文件都是一样的一个mp4文件(400M)，
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190702-124039.png&#34; alt=&#34;WX20190702-124039&#34;&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	/*
	复制文件：
	 */
	//srcFile := &amp;quot;/home/ruby/文档/pro/aa.txt&amp;quot;
	//destFile := &amp;quot;/home/ruby/文档/aa.txt&amp;quot;

	srcFile :=&amp;quot;/Users/ruby/Documents/pro/a/001_小程序入门.mp4&amp;quot;
	destFile:=&amp;quot;001_小程序入门.mp4&amp;quot;
	total,err:=copyFile1(srcFile,destFile)
	fmt.Println(err)
	fmt.Println(total)

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一种：io包下Read()和Write()直接读写：我们自己创建读取数据的切片的大小，直接影响性能。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;localhost:l_file ruby$ time go run demo05_copy.go 
拷贝完毕。。
&amp;lt;nil&amp;gt;
401386819

real    0m7.911s
user    0m2.900s
sys     0m7.661s


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种：io包下Copy()方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;localhost:l_file ruby$ time go run demo05_copy.go 
&amp;lt;nil&amp;gt;
401386819

real    0m1.594s
user    0m0.533s
sys     0m1.136s


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三种：ioutil包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;localhost:l_file ruby$ time go run demo05_copy.go 
&amp;lt;nil&amp;gt;
401386819

real    0m1.515s
user    0m0.339s
sys     0m0.625s

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190702-124719.png&#34; alt=&#34;WX20190702-124719&#34;&gt;&lt;/p&gt;
&lt;p&gt;这3种方式，在性能上，不管是还是io.Copy()还是ioutil包，性能都是还不错的。&lt;/p&gt;
&lt;h1 id=&#34;四断点续传&#34;&gt;四、断点续传&lt;/h1&gt;
&lt;h2 id=&#34;1seeker接口&#34;&gt;1、Seeker接口&lt;/h2&gt;
&lt;p&gt;Seeker是包装基本Seek方法的接口。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Seeker interface {
        Seek(offset int64, whence int) (int64, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;seek(offset,whence),设置指针光标的位置，随机读写文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一个参数：偏移量
第二个参数：如何设置			

			0：seekStart表示相对于文件开始，
			1：seekCurrent表示相对于当前偏移量，
			2：seek end表示相对于结束。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
	SeekStart   = 0 // seek relative to the origin of the file
	SeekCurrent = 1 // seek relative to the current offset
	SeekEnd     = 2 // seek relative to the end
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;p&gt;我们要读取本地/Users/ruby/Documents/pro/a 目录下的aa.txt文件，文件中的内容是：abcdefghij这几个字符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190703-155441.png&#34; alt=&#34;WX20190703-155441&#34;&gt;&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;os&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
)

func main() {
	/*
	seek(offset,whence),设置指针光标的位置
	第一个参数：偏移量
	第二个参数：如何设置
		0：seekStart表示相对于文件开始，
		1：seekCurrent表示相对于当前偏移量，
		2：seek end表示相对于结束。


	const (
	SeekStart   = 0 // seek relative to the origin of the file
	SeekCurrent = 1 // seek relative to the current offset
	SeekEnd     = 2 // seek relative to the end
)

	随机读取文件：
		可以设置指针光标的位置
	 */

	file,_:=os.OpenFile(&amp;quot;/Users/ruby/Documents/pro/a/aa.txt&amp;quot;,os.O_RDWR,0)
	defer file.Close()
	bs :=[]byte{0}

	file.Read(bs)
	fmt.Println(string(bs))

	file.Seek(4,io.SeekStart)
	file.Read(bs)
	fmt.Println(string(bs))
	file.Seek(2,0) //也是SeekStart
	file.Read(bs)
	fmt.Println(string(bs))

	file.Seek(3,io.SeekCurrent)
	file.Read(bs)
	fmt.Println(string(bs))

	file.Seek(0,io.SeekEnd)
	file.WriteString(&amp;quot;ABC&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190703-155739.png&#34; alt=&#34;WX20190703-155739&#34;&gt;&lt;/p&gt;
&lt;p&gt;本地文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190703-155821.png&#34; alt=&#34;WX20190703-155821&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2断点续传&#34;&gt;2、断点续传&lt;/h2&gt;
&lt;p&gt;首先思考几个问题
Q1：如果你要传的文件，比较大，那么是否有方法可以缩短耗时？
Q2：如果在文件传递过程中，程序因各种原因被迫中断了，那么下次再重启时，文件是否还需要重头开始？
Q3：传递文件的时候，支持暂停和恢复么？即使这两个操作分布在程序进程被杀前后。&lt;/p&gt;
&lt;p&gt;通过断点续传可以实现，不同的语言有不同的实现方式。我们看看Go语言中，通过Seek()方法如何实现：&lt;/p&gt;
&lt;p&gt;先说一下思路：想实现断点续传，主要就是记住上一次已经传递了多少数据，那我们可以创建一个临时文件，记录已经传递的数据量，当恢复传递的时候，先从临时文件中读取上次已经传递的数据量，然后通过Seek()方法，设置到该读和该写的位置，再继续传递数据。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;io&amp;quot;
)

func main() {
	/*
	断点续传：
		文件传递：文件复制
			/Users/ruby/Documents/pro/a/guliang.jpeg

		复制到
			guliang4.jpeg

	思路：
		边复制，边记录复制的总量
	 */

	srcFile:=&amp;quot;/Users/ruby/Documents/pro/a/guliang.jpeg&amp;quot;
	destFile:=&amp;quot;guliang4.jpeg&amp;quot;
	tempFile:=destFile+&amp;quot;temp.txt&amp;quot;
	//fmt.Println(tempFile)
	file1,_:=os.Open(srcFile)
	file2,_:=os.OpenFile(destFile,os.O_CREATE|os.O_WRONLY,os.ModePerm)
	file3,_:=os.OpenFile(tempFile,os.O_CREATE|os.O_RDWR,os.ModePerm)


	defer file1.Close()
	defer file2.Close()
	//1.读取临时文件中的数据，根据seek
	file3.Seek(0,io.SeekStart)
	bs:=make([]byte,100,100)
	n1,err:=file3.Read(bs)
	fmt.Println(n1)
	countStr:=string(bs[:n1])
	fmt.Println(countStr)
	//count,_:=strconv.Atoi(countStr)
	count,_:=strconv.ParseInt(countStr,10,64)
	fmt.Println(count)

	//2. 设置读，写的偏移量
	file1.Seek(count,0)
	file2.Seek(count,0)
	data:=make([]byte,1024,1024)
	n2:=-1// 读取的数据量
	n3:=-1//写出的数据量
	total :=int(count)//读取的总量

	for{
		//3.读取数据
		n2,err=file1.Read(data)
		if err ==io.EOF{
			fmt.Println(&amp;quot;文件复制完毕。。&amp;quot;)
			file3.Close()
			os.Remove(tempFile)
			break
		}
		//将数据写入到目标文件
		n3,_=file2.Write(data[:n2])
		total += n3
		//将复制总量，存储到临时文件中
		file3.Seek(0,io.SeekStart)
		file3.WriteString(strconv.Itoa(total))


		//假装断电
		//if total&amp;gt;8000{
		//	panic(&amp;quot;假装断电了。。。，假装的。。。&amp;quot;)
		//}
	}

}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;五bufio包&#34;&gt;五、bufio包&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;生命不止，继续Go go go。。&lt;/p&gt;
&lt;p&gt;Go语言在io操作中，还提供了一个bufio的包，使用这个包可以大幅提高文件读写的效率。&lt;/p&gt;
&lt;h2 id=&#34;1bufio包原理&#34;&gt;1、bufio包原理&lt;/h2&gt;
&lt;p&gt;bufio 是通过缓冲来提高效率。&lt;/p&gt;
&lt;p&gt;io操作本身的效率并不低，低的是频繁的访问本地磁盘的文件。所以bufio就提供了缓冲区(分配一块内存)，读和写都先在缓冲区中，最后再读写文件，来降低访问本地磁盘的次数，从而提高效率。&lt;/p&gt;
&lt;p&gt;简单的说就是，把文件读取进缓冲（内存）之后再读取的时候就可以避免文件系统的io 从而提高速度。同理，在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。看完以上解释有人可能会表示困惑了，直接把 内容-&amp;gt;文件 和 内容-&amp;gt;缓冲-&amp;gt;文件相比， 缓冲区好像没有起到作用嘛。其实缓冲区的设计是为了存储多次的写入，最后一口气把缓冲区内容写入文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190704-113648.png&#34; alt=&#34;WX20190704-113648&#34;&gt;&lt;/p&gt;
&lt;p&gt;bufio 封装了io.Reader或io.Writer接口对象，并创建另一个也实现了该接口的对象。&lt;/p&gt;
&lt;p&gt;io.Reader或io.Writer 接口实现read() 和 write() 方法，对于实现这个接口的对象都是可以使用这两个方法的。&lt;/p&gt;
&lt;p&gt;Reader对象&lt;/p&gt;
&lt;p&gt;bufio.Reader 是bufio中对io.Reader 的封装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Reader implements buffering for an io.Reader object.
type Reader struct {
	buf          []byte
	rd           io.Reader // reader provided by the client
	r, w         int       // buf read and write positions
	err          error
	lastByte     int // last byte read for UnreadByte; -1 means invalid
	lastRuneSize int // size of last rune read for UnreadRune; -1 means invalid
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bufio.Read(p []byte) 相当于读取大小len(p)的内容，思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当缓存区有内容的时，将缓存区内容全部填入p并清空缓存区&lt;/li&gt;
&lt;li&gt;当缓存区没有内容的时候且len(p)&amp;gt;len(buf),即要读取的内容比缓存区还要大，直接去文件读取即可&lt;/li&gt;
&lt;li&gt;当缓存区没有内容的时候且len(p)&amp;lt;len(buf),即要读取的内容比缓存区小，缓存区从文件读取内容充满缓存区，并将p填满（此时缓存区有剩余内容）&lt;/li&gt;
&lt;li&gt;以后再次读取时缓存区有内容，将缓存区内容全部填入p并清空缓存区（此时和情况1一样）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;源码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Read reads data into p.
// It returns the number of bytes read into p.
// The bytes are taken from at most one Read on the underlying Reader,
// hence n may be less than len(p).
// To read exactly len(p) bytes, use io.ReadFull(b, p).
// At EOF, the count will be zero and err will be io.EOF.
func (b *Reader) Read(p []byte) (n int, err error) {
	n = len(p)
	if n == 0 {
		return 0, b.readErr()
	}
	if b.r == b.w {
		if b.err != nil {
			return 0, b.readErr()
		}
		if len(p) &amp;gt;= len(b.buf) {
			// Large read, empty buffer.
			// Read directly into p to avoid copy.
			n, b.err = b.rd.Read(p)
			if n &amp;lt; 0 {
				panic(errNegativeRead)
			}
			if n &amp;gt; 0 {
				b.lastByte = int(p[n-1])
				b.lastRuneSize = -1
			}
			return n, b.readErr()
		}
		// One read.
		// Do not use b.fill, which will loop.
		b.r = 0
		b.w = 0
		n, b.err = b.rd.Read(b.buf)
		if n &amp;lt; 0 {
			panic(errNegativeRead)
		}
		if n == 0 {
			return 0, b.readErr()
		}
		b.w += n
	}

	// copy as much as we can
	n = copy(p, b.buf[b.r:b.w])
	b.r += n
	b.lastByte = int(b.buf[b.r-1])
	b.lastRuneSize = -1
	return n, nil
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;reader内部通过维护一个r, w 即读入和写入的位置索引来判断是否缓存区内容被全部读出。&lt;/p&gt;
&lt;p&gt;Writer对象&lt;/p&gt;
&lt;p&gt;bufio.Writer 是bufio中对io.Writer 的封装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Writer implements buffering for an io.Writer object.
// If an error occurs writing to a Writer, no more data will be
// accepted and all subsequent writes, and Flush, will return the error.
// After all data has been written, the client should call the
// Flush method to guarantee all data has been forwarded to
// the underlying io.Writer.
type Writer struct {
	err error
	buf []byte
	n   int
	wr  io.Writer
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bufio.Write(p []byte) 的思路如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断buf中可用容量是否可以放下 p&lt;/li&gt;
&lt;li&gt;如果能放下，直接把p拼接到buf后面，即把内容放到缓冲区&lt;/li&gt;
&lt;li&gt;如果缓冲区的可用容量不足以放下，且此时缓冲区是空的，直接把p写入文件即可&lt;/li&gt;
&lt;li&gt;如果缓冲区的可用容量不足以放下，且此时缓冲区有内容，则用p把缓冲区填满，把缓冲区所有内容写入文件，并清空缓冲区&lt;/li&gt;
&lt;li&gt;判断p的剩余内容大小能否放到缓冲区，如果能放下（此时和步骤1情况一样）则把内容放到缓冲区&lt;/li&gt;
&lt;li&gt;如果p的剩余内容依旧大于缓冲区，（注意此时缓冲区是空的，情况和步骤3一样）则把p的剩余内容直接写入文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下是源码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
// Write writes the contents of p into the buffer.
// It returns the number of bytes written.
// If nn &amp;lt; len(p), it also returns an error explaining
// why the write is short.
func (b *Writer) Write(p []byte) (nn int, err error) {
	for len(p) &amp;gt; b.Available() &amp;amp;&amp;amp; b.err == nil {
		var n int
		if b.Buffered() == 0 {
			// Large write, empty buffer.
			// Write directly from p to avoid copy.
			n, b.err = b.wr.Write(p)
		} else {
			n = copy(b.buf[b.n:], p)
			b.n += n
			b.Flush()
		}
		nn += n
		p = p[n:]
	}
	if b.err != nil {
		return nn, b.err
	}
	n := copy(b.buf[b.n:], p)
	b.n += n
	nn += n
	return nn, nil
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;b.wr 存储的是一个io.writer对象，实现了Write()的接口，所以可以使用b.wr.Write(p) 将p的内容写入文件。&lt;/p&gt;
&lt;p&gt;b.flush() 会将缓存区内容写入文件，当所有写入完成后，因为缓存区会存储内容，所以需要手动flush()到文件。&lt;/p&gt;
&lt;p&gt;b.Available() 为buf可用容量，等于len(buf) - n。&lt;/p&gt;
&lt;p&gt;下图解释的是其中一种情况，即缓存区有内容，剩余p大于缓存区&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190704-122357.png&#34; alt=&#34;WX20190704-122357&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2bufio包&#34;&gt;2、bufio包&lt;/h2&gt;
&lt;p&gt;bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，创建另一个也实现了该接口，且同时还提供了缓冲和一些文本I/O的帮助函数的对象。&lt;/p&gt;
&lt;p&gt;bufio.Reader：&lt;/p&gt;
&lt;p&gt;bufio.Reader 实现了如下接口：
io.Reader
io.WriterTo
io.ByteScanner
io.RuneScanner&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// NewReaderSize 将 rd 封装成一个带缓存的 bufio.Reader 对象，
// 缓存大小由 size 指定（如果小于 16 则会被设置为 16）。
// 如果 rd 的基类型就是有足够缓存的 bufio.Reader 类型，则直接将
// rd 转换为基类型返回。
func NewReaderSize(rd io.Reader, size int) *Reader

// NewReader 相当于 NewReaderSize(rd, 4096)
func NewReader(rd io.Reader) *Reader

// Peek 返回缓存的一个切片，该切片引用缓存中前 n 个字节的数据，
// 该操作不会将数据读出，只是引用，引用的数据在下一次读取操作之
// 前是有效的。如果切片长度小于 n，则返回一个错误信息说明原因。
// 如果 n 大于缓存的总大小，则返回 ErrBufferFull。
func (b *Reader) Peek(n int) ([]byte, error)

// Read 从 b 中读出数据到 p 中，返回读出的字节数和遇到的错误。
// 如果缓存不为空，则只能读出缓存中的数据，不会从底层 io.Reader
// 中提取数据，如果缓存为空，则：
// 1、len(p) &amp;gt;= 缓存大小，则跳过缓存，直接从底层 io.Reader 中读
// 出到 p 中。
// 2、len(p) &amp;lt; 缓存大小，则先将数据从底层 io.Reader 中读取到缓存
// 中，再从缓存读取到 p 中。
func (b *Reader) Read(p []byte) (n int, err error)

// Buffered 返回缓存中未读取的数据的长度。
func (b *Reader) Buffered() int

// ReadBytes 功能同 ReadSlice，只不过返回的是缓存的拷贝。
func (b *Reader) ReadBytes(delim byte) (line []byte, err error)

// ReadString 功能同 ReadBytes，只不过返回的是字符串。
func (b *Reader) ReadString(delim byte) (line string, err error)

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bufio.Writer：&lt;/p&gt;
&lt;p&gt;bufio.Writer 实现了如下接口：
io.Writer
io.ReaderFrom
io.ByteWriter&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// NewWriterSize 将 wr 封装成一个带缓存的 bufio.Writer 对象，
// 缓存大小由 size 指定（如果小于 4096 则会被设置为 4096）。
// 如果 wr 的基类型就是有足够缓存的 bufio.Writer 类型，则直接将
// wr 转换为基类型返回。
func NewWriterSize(wr io.Writer, size int) *Writer

// NewWriter 相当于 NewWriterSize(wr, 4096)
func NewWriter(wr io.Writer) *Writer

// WriteString 功能同 Write，只不过写入的是字符串
func (b *Writer) WriteString(s string) (int, error)

// WriteRune 向 b 写入 r 的 UTF-8 编码，返回 r 的编码长度。
func (b *Writer) WriteRune(r rune) (size int, err error)

// Flush 将缓存中的数据提交到底层的 io.Writer 中
func (b *Writer) Flush() error

// Available 返回缓存中未使用的空间的长度
func (b *Writer) Available() int

// Buffered 返回缓存中未提交的数据的长度
func (b *Writer) Buffered() int

// Reset 将 b 的底层 Writer 重新指定为 w，同时丢弃缓存中的所有数据，复位
// 所有标记和错误信息。相当于创建了一个新的 bufio.Writer。
func (b *Writer) Reset(w io.Writer)

...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3实例代码-1&#34;&gt;3、实例代码&lt;/h2&gt;
&lt;p&gt;读取数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;os&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;bufio&amp;quot;
)

func main() {
	/*
	bufio:高效io读写
		buffer缓存
		io：input/output

	将io包下的Reader，Write对象进行包装，带缓存的包装，提高读写的效率

		ReadBytes()
		ReadString()
		ReadLine()

	 */

	 fileName:=&amp;quot;/Users/ruby/Documents/pro/a/english.txt&amp;quot;
	 file,err := os.Open(fileName)
	 if err != nil{
	 	fmt.Println(err)
	 	return
	 }
	 defer file.Close()

	 //创建Reader对象
	 //b1 := bufio.NewReader(file)
	 //1.Read()，高效读取
	 //p := make([]byte,1024)
	 //n1,err := b1.Read(p)
	 //fmt.Println(n1)
	 //fmt.Println(string(p[:n1]))

	 //2.ReadLine()
	 //data,flag,err := b1.ReadLine()
	 //fmt.Println(flag)
	 //fmt.Println(err)
	 //fmt.Println(data)
	 //fmt.Println(string(data))

	 //3.ReadString()
	// s1,err :=b1.ReadString(&#39;\n&#39;)
	// fmt.Println(err)
	// fmt.Println(s1)
	//
	// s1,err = b1.ReadString(&#39;\n&#39;)
	// fmt.Println(err)
	// fmt.Println(s1)
	//
	//s1,err = b1.ReadString(&#39;\n&#39;)
	//fmt.Println(err)
	//fmt.Println(s1)
	//
	//for{
	//	s1,err := b1.ReadString(&#39;\n&#39;)
	//	if err == io.EOF{
	//		fmt.Println(&amp;quot;读取完毕。。&amp;quot;)
	//		break
	//	}
	//	fmt.Println(s1)
	//}

	//4.ReadBytes()
	//data,err :=b1.ReadBytes(&#39;\n&#39;)
	//fmt.Println(err)
	//fmt.Println(string(data))


	//Scanner
	//s2 := &amp;quot;&amp;quot;
	//fmt.Scanln(&amp;amp;s2)
	//fmt.Println(s2)

	b2 := bufio.NewReader(os.Stdin)
	s2, _ := b2.ReadString(&#39;\n&#39;)
	fmt.Println(s2)

}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本地文件：english.txt文件内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190704-172759.png&#34; alt=&#34;WX20190704-172759&#34;&gt;&lt;/p&gt;
&lt;p&gt;写数据示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;os&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;bufio&amp;quot;
)

func main() {
	/*
	bufio:高效io读写
		buffer缓存
		io：input/output

	将io包下的Reader，Write对象进行包装，带缓存的包装，提高读写的效率

		func (b *Writer) Write(p []byte) (nn int, err error)
		func (b *Writer) WriteByte(c byte) error
		func (b *Writer) WriteRune(r rune) (size int, err error)
		func (b *Writer) WriteString(s string) (int, error)

	 */

	 fileName := &amp;quot;/Users/ruby/Documents/pro/a/cc.txt&amp;quot;
	 file,err := os.OpenFile(fileName,os.O_CREATE|os.O_WRONLY,os.ModePerm)
	 if err != nil{
	 	fmt.Println(err)
	 	return
	 }
	 defer file.Close()

	 w1 := bufio.NewWriter(file)
	 //n,err := w1.WriteString(&amp;quot;helloworld&amp;quot;)
	 //fmt.Println(err)
	 //fmt.Println(n)
	 //w1.Flush() //刷新缓冲区

	 for i:=1;i&amp;lt;=1000;i++{
	 	w1.WriteString(fmt.Sprintf(&amp;quot;%d:hello&amp;quot;,i))
	 }
	 w1.Flush()
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;六ioutil包&#34;&gt;六、ioutil包&lt;/h1&gt;
&lt;p&gt;除了io包可以读写数据，Go语言中还提供了一个辅助的工具包就是ioutil，里面的方法虽然不多，但是都还蛮好用的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;io/ioutil&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该包的介绍只有一句话：Package ioutil implements some I/O utility functions。&lt;/p&gt;
&lt;h2 id=&#34;1ioutil包的方法&#34;&gt;1、ioutil包的方法&lt;/h2&gt;
&lt;p&gt;下面我们来看一下里面的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Discard 是一个 io.Writer 接口，调用它的 Write 方法将不做任何事情
// 并且始终成功返回。
var Discard io.Writer = devNull(0)

// ReadAll 读取 r 中的所有数据，返回读取的数据和遇到的错误。
// 如果读取成功，则 err 返回 nil，而不是 EOF，因为 ReadAll 定义为读取
// 所有数据，所以不会把 EOF 当做错误处理。
func ReadAll(r io.Reader) ([]byte, error)

// ReadFile 读取文件中的所有数据，返回读取的数据和遇到的错误。
// 如果读取成功，则 err 返回 nil，而不是 EOF
func ReadFile(filename string) ([]byte, error)

// WriteFile 向文件中写入数据，写入前会清空文件。
// 如果文件不存在，则会以指定的权限创建该文件。
// 返回遇到的错误。
func WriteFile(filename string, data []byte, perm os.FileMode) error

// ReadDir 读取指定目录中的所有目录和文件（不包括子目录）。
// 返回读取到的文件信息列表和遇到的错误，列表是经过排序的。
func ReadDir(dirname string) ([]os.FileInfo, error)

// NopCloser 将 r 包装为一个 ReadCloser 类型，但 Close 方法不做任何事情。
func NopCloser(r io.Reader) io.ReadCloser

// TempFile 在 dir 目录中创建一个以 prefix 为前缀的临时文件，并将其以读
// 写模式打开。返回创建的文件对象和遇到的错误。
// 如果 dir 为空，则在默认的临时目录中创建文件（参见 os.TempDir），多次
// 调用会创建不同的临时文件，调用者可以通过 f.Name() 获取文件的完整路径。
// 调用本函数所创建的临时文件，应该由调用者自己删除。
func TempFile(dir, prefix string) (f *os.File, err error)

// TempDir 功能同 TempFile，只不过创建的是目录，返回目录的完整路径。
func TempDir(dir, prefix string) (name string, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2示例代码&#34;&gt;2、示例代码：&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
)

func main() {
	/*
	ioutil包：
		ReadFile()
		WriteFile()
		ReadDir()
		..
	 */

	//1.读取文件中的所有的数据
	//fileName1 := &amp;quot;/Users/ruby/Documents/pro/a/aa.txt&amp;quot;
	//data, err := ioutil.ReadFile(fileName1)
	//fmt.Println(err)
	//fmt.Println(string(data))

	//2.写出数据
	//fileName2:=&amp;quot;/Users/ruby/Documents/pro/a/bbb.txt&amp;quot;
	//s1:=&amp;quot;helloworld面朝大海春暖花开&amp;quot;
	//err:=ioutil.WriteFile(fileName2,[]byte(s1),0777)
	//fmt.Println(err)

	//3.
	//s2:=&amp;quot;qwertyuiopsdfghjklzxcvbnm&amp;quot;
	//r1:=strings.NewReader(s2)
	//data,_:=ioutil.ReadAll(r1)
	//fmt.Println(data)

	//4.ReadDir(),读取一个目录下的子内容：子文件和子目录，但是仅有一层
	//dirName:=&amp;quot;/Users/ruby/Documents/pro/a&amp;quot;
	//fileInfos,_:=ioutil.ReadDir(dirName)
	//fmt.Println(len(fileInfos))
	//for i:=0;i&amp;lt;len(fileInfos);i++{
	//	//fmt.Printf(&amp;quot;%T\n&amp;quot;,fileInfos[i])
	//	fmt.Println(i,fileInfos[i].Name(),fileInfos[i].IsDir())
	//
	//}


	// 5.创建临时目录
	dir, err := ioutil.TempDir(&amp;quot;/Users/ruby/Documents/pro/a&amp;quot;, &amp;quot;Test&amp;quot;)
	if err != nil {
		fmt.Println(err)
	}
	defer os.Remove(dir) // 用完删除
	fmt.Printf(&amp;quot;%s\n&amp;quot;, dir)

	// 创建临时文件
	f, err := ioutil.TempFile(dir, &amp;quot;Test&amp;quot;)
	if err != nil {
		fmt.Println(err)
	}
	defer os.Remove(f.Name()) // 用完删除
	fmt.Printf(&amp;quot;%s\n&amp;quot;, f.Name())

}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;七遍历文件夹&#34;&gt;七、遍历文件夹&lt;/h1&gt;
&lt;p&gt;学习io之后，尤其是文件操作，我们就可以遍历给定的目录文件夹了。可以使用ioutil包下的readDir()方法，这个方法可以获取指定目录下的内容，返回文件和子目录。&lt;/p&gt;
&lt;p&gt;因为文件夹下还有子文件夹，而ioutil包的ReadDir()只能获取一层目录，所以我们需要自己去设计算法来实现，最容易实现的思路就是使用递归。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
)

func main() {
	/**
	遍历文件夹：
	 */

	dirname := &amp;quot;/Users/ruby/Documents/pro&amp;quot;
	listFiles(dirname, 0)

}

func listFiles(dirname string, level int) {
	// level用来记录当前递归的层次
	// 生成有层次感的空格
	s := &amp;quot;|--&amp;quot;
	for i := 0; i &amp;lt; level; i++ {
		s = &amp;quot;|   &amp;quot; + s
	}

	fileInfos, err := ioutil.ReadDir(dirname)
	if err != nil{
		log.Fatal(err)
	}
	for _, fi := range fileInfos {
		filename := dirname + &amp;quot;/&amp;quot; + fi.Name()
		fmt.Printf(&amp;quot;%s%s\n&amp;quot;, s, filename)
		if fi.IsDir() {
			//继续遍历fi这个目录
			listFiles(filename, level+1)
		}
	}
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190720-210316.png&#34; alt=&#34;WX20190720-210316&#34;&gt;&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频：
&lt;a href=&#34;https://www.bilibili.com/video/av56945376&#34;&gt;https://www.bilibili.com/video/av56945376&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码已上传github：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_advanced&#34;&gt;https://github.com/rubyhan1314/go_advanced&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>go-micro介绍及环境搭建</title>
                <link>http://www.songx.fun/blog/day83-85go-micro%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day83_go-micro%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day83-85go-micro%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day83_go-micro%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;go-micro介绍及环境搭建&#34;&gt;go-micro介绍及环境搭建&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一micro框架介绍&#34;&gt;一、micro框架介绍&lt;/h2&gt;
&lt;h3 id=&#34;11背景&#34;&gt;1.1、背景&lt;/h3&gt;
&lt;p&gt;在本课程的前面的内容中，已经学习了微服务之间通信采用的通信协议，如何实现服务的注册和发现，搭建服务管理集群，以及服务与服务之间的RPC通信方式。具体的内容包括：protobuf协议，consul及docker部署consul集群，gRPC框架的使用等具体的实现方案。&lt;/p&gt;
&lt;p&gt;以上这些具体的方案都是为了解决微服务实践过程中具体的某个问题而提出的，实现微服务架构的项目开发。但是，在具体的项目开发过程中，开发者聚焦的是业务逻辑的开发和功能的实现，大量的环境配置，调试搭建等基础性工作会耗费相当一部分的精力，因此有必要将微服务架构中所涉及到的，相关的解决方案做集中管理和维护。这就是我们要学习的Micro。&lt;/p&gt;
&lt;h3 id=&#34;12概述&#34;&gt;1.2、概述&lt;/h3&gt;
&lt;p&gt;Micro是一个简化分布式开发的微服务生态系统，该系统为开发分布式应用程序提供了高效，便捷的模块构建。主要目的是简化分布式系统的开发。&lt;/p&gt;
&lt;p&gt;学习完该框架以后，可以方便开发者们非常简单的开发出微服务架构的项目，并且随着业务模块的增加和功能的增加，Micro还能够提供管理微服务环境的工具和功能。&lt;/p&gt;
&lt;h3 id=&#34;13micro组成&#34;&gt;1.3、micro组成&lt;/h3&gt;
&lt;p&gt;micro是一个微服务工具包，是由一系列的工具包组成的，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/micro%E5%B9%B3%E5%8F%B0%E7%BB%84%E6%88%90.png&#34; alt=&#34;micro&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**Go Micro：**用于在Go中编写微服务的插件式RPC框架。它提供了用于服务发现，客户端负载平衡，编码，同步和异步通信库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;API：&lt;/strong&gt; API主要负责提供将HTTP请求路由到相应微服务的API网关。它充当单个入口点，可以用作反向代理或将HTTP请求转换为RPC。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**Sidecar：**一种对语言透明的RPC代理，具有go-micro作为HTTP端点的所有功能。虽然Go是构建微服务的伟大语言，但您也可能希望使用其他语言，因此Sidecar提供了一种将其他应用程序集成到Micro世界的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**Web：**用于Micro Web应用程序的仪表板和反向代理。我们认为应该基于微服务建立web应用，因此被视为微服务领域的一等公民。它的行为非常像API反向代理，但也包括对web sockets的支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**CLI：**一个直接的命令行界面来与你的微服务进行交互。它还使您可以利用Sidecar作为代理，您可能不想直接连接到服务注册表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**Bot：**Hubot风格的bot，位于您的微服务平台中，可以通过Slack，HipChat，XMPP等进行交互。它通过消息传递提供CLI的功能。可以添加其他命令来自动执行常见的操作任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14工具包介绍&#34;&gt;1.4、工具包介绍&lt;/h3&gt;
&lt;h4 id=&#34;141api&#34;&gt;1.4.1、API&lt;/h4&gt;
&lt;p&gt;启用API作为一个网关或代理，来作为微服务访问的单一入口。它应该在您的基础架构的边缘运行。它将HTTP请求转换为RPC并转发给相应的服务。
&lt;img src=&#34;http://www.songx.fun/img/png/api.png&#34; alt=&#34;API工具&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;142web&#34;&gt;1.4.2、Web&lt;/h4&gt;
&lt;p&gt;UI是go-micro的web版本，允许通过UI交互访问环境。在未来，它也将是一种聚合Micro Web服务的方式。它包含一种Web应用程序的代理方式。将/[name]通过注册表路由到相应的服务。Web UI将前缀“go.micro.web。”（可以配置）添加到名称中，在注册表中查找它，然后将进行反向代理。
&lt;img src=&#34;http://www.songx.fun/img/png/web.png&#34; alt=&#34;web工具&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;143sidecar&#34;&gt;1.4.3、Sidecar&lt;/h4&gt;
&lt;p&gt;该Sidecar是go-micro的HTTP接口版本。这是将非Go应用程序集成到Micro环境中的一种方式。
&lt;img src=&#34;http://www.songx.fun/img/png/car.png&#34; alt=&#34;sidecar工具&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;144bot&#34;&gt;1.4.4、Bot&lt;/h4&gt;
&lt;p&gt;Bot是一个Hubot风格的工具，位于您的微服务平台中，可以通过Slack，HipChat，XMPP等进行交互。它通过消息传递提供CLI的功能。可以添加其他命令来自动执行常用操作任务。
&lt;img src=&#34;http://www.songx.fun/img/png/bot.png&#34; alt=&#34;bot工具&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;145cli&#34;&gt;1.4.5、CLI&lt;/h4&gt;
&lt;p&gt;Micro CLI是go-micro的命令行版本，它提供了一种观察和与运行环境交互的方式。&lt;/p&gt;
&lt;h4 id=&#34;146go-micro&#34;&gt;1.4.6、Go-Micro&lt;/h4&gt;
&lt;p&gt;Go-micro是微服务的独立RPC框架。它是该工具包的核心，并受到上述所有组件的影响。在这里，我们将看看go-micro的每个特征。
&lt;img src=&#34;http://www.songx.fun/img/png/go-micro.png&#34; alt=&#34;go-micro&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;15go-micro特性&#34;&gt;1.5、Go-Micro特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Registry：主要负责服务注册和发现功能。我们之前学习过的consul，就可以和此处的Registry结合起来，实现服务的发现功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Selector：selector主要的作用是实现服务的负载均衡功能。当某个客户端发起请求时，将首先查询服务注册表，返回当前系统中可用的服务列表，然后从中选择其中一个节点进行查询，保证节点可用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Broker：Broker是go-micro框架中事件发布和订阅的接口，主要是用消息队列的方式实现信息的接收和发布，用于处理系统间的异步功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Codec：go-micro中数据传输过程中的编码和解码接口。go-micro中有多重编码方式，默认的实现方式是protobuf，除此之外，还有json等格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transport：go-micro框架中的通信接口，有很多的实现方案可以选择，默认使用的是http形式的通信方式，除此以外，还有grpc等通信方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Client和Server：分别是go-micro中的客户端接口和服务端接口。client负责调用，server负责等待请求处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;16环境安装&#34;&gt;1.6、环境安装&lt;/h3&gt;
&lt;h4 id=&#34;161安装consul&#34;&gt;1.6.1、安装consul&lt;/h4&gt;
&lt;p&gt;consul环境是go-micro默认使用的服务发现方式。在之前的课程中已经安装过。&lt;/p&gt;
&lt;h4 id=&#34;162安装protobuf和依赖&#34;&gt;1.6.2、安装protobuf和依赖&lt;/h4&gt;
&lt;p&gt;关于protobuf相关知识，我们之前也已经安装并学习过，此处不再赘述。&lt;/p&gt;
&lt;h4 id=&#34;163micro工具包安装可选择&#34;&gt;1.6.3、micro工具包安装（可选择）&lt;/h4&gt;
&lt;p&gt;前面说过，micro是一个微服务系统，提供了很多工具包，可以帮助我们进行开发和调试。
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190815-102639@2x.png&#34; alt=&#34;microg工具包&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以使用如下命令安装micro的一系列的工具包：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go get -u github.com/micro/micro
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1641go-micro安装&#34;&gt;1.6.4、1Go-micro安装&lt;/h4&gt;
&lt;p&gt;使用go-micro框架之前，首先需要安装go-micro框架，使用如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go get github.com/micro/go-micro
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完毕后，能够在$GOPATH目录下面找到go-micro的源码，如下图所示：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190705-164152@2x.png&#34; alt=&#34;安装go-micro&#34;&gt;&lt;/p&gt;
&lt;p&gt;go-micro的源码在github上可以找到，链接如下：&lt;a href=&#34;https://github.com/micro/go-micro&#34;&gt;https://github.com/micro/go-micro&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;二创建微服务&#34;&gt;二、创建微服务&lt;/h2&gt;
&lt;h3 id=&#34;21服务的定义&#34;&gt;2.1、服务的定义&lt;/h3&gt;
&lt;p&gt;在micro框架中，服务用接口来进行定义，服务被定义为Service，完整的接口定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Service interface {
	Init(...Option)
	Options() Options
	Client() client.Client
	Server() server.Server
	Run() error
	String() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在该接口中，定义了一个服务实例具体要包含的方法，分别是：Init、Options、Client、Server、Run、String等6个方法。&lt;/p&gt;
&lt;h3 id=&#34;22初始化服务实例&#34;&gt;2.2、初始化服务实例&lt;/h3&gt;
&lt;p&gt;micro框架，除了提供Service的定义外，提供创建服务实例的方法供开发者调用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;service := micro.NewService()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上是最简单一种创建service实例的方式。NewService可以接受一个Options类型的可选项参数。NewService的定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewService(opts ...Option) Service {
	return newService(opts...)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;221options可选项配置&#34;&gt;2.2.1、Options可选项配置&lt;/h4&gt;
&lt;p&gt;关于Options可配置选项，有很多可以选择的设置项。micro框架包中包含了options.go文件，定义了详细的可选项配置的内容。最基本常见的配置项有：服务名称，服务的版本，服务的地址，服务：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//服务名称
func Name(n string) Option {
	return func(o *Options) {
		o.Server.Init(server.Name(n))
	}
}

//服务版本
func Version(v string) Option {
	return func(o *Options) {
		o.Server.Init(server.Version(v))
	}
}

//服务部署地址
func Address(addr string) Option {
	return func(o *Options) {
		o.Server.Init(server.Address(addr))
	}
}

//元数据项设置
func Metadata(md map[string]string) Option {
	return func(o *Options) {
		o.Server.Init(server.Metadata(md))
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完整的实例化对象代码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	//创建一个新的服务对象实例
	service := micro.NewService(
		micro.Name(&amp;quot;helloservice&amp;quot;),
		micro.Version(&amp;quot;v1.0.0&amp;quot;),
	)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开发者可以直接调用micro.Name为服务设置名称，设置版本号等信息。在对应的函数内部，调用了server.Server.Init函数对配置项进行初始化。&lt;/p&gt;
&lt;h3 id=&#34;23定义服务接口实现服务业务逻辑&#34;&gt;2.3、定义服务接口,实现服务业务逻辑&lt;/h3&gt;
&lt;p&gt;在前面的课程中，已经学习掌握了使用protobuf定义服务接口，并对服务进行具体实现。使用protobuf定义服务接口并自动生成go语言文件,需要经过以下几个步骤，我们通过示例进行说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font size=2 color=&#39;gray&#39;&gt;我们依然通过案例来讲解相关的知识点：在学校的教务系统中，有学生信息管理的需求。学生信息包含学生姓名，学生班级，学习成绩组成；可以根据学生姓名查询学生的相关信息，我们通过rpc调用和学生服务来实现该案例。&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;231定义proto文件&#34;&gt;2.3.1、定义.proto文件&lt;/h4&gt;
&lt;p&gt;使用proto3语法定义数据结构体和服务方法。具体定义内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;syntax = &#39;proto3&#39;;
package message;

//学生数据体
message Student {
    string name = 1; //姓名
    string classes = 2; //班级
    int32 grade = 3; //分数
}

//请求数据体定义
message StudentRequest {
    string name = 1;
}

//学生服务
service StudentService {
    //查询学生信息服务
    rpc GetStudent (StudentRequest) returns (Student);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;232编译proto文件&#34;&gt;2.3.2、编译.proto文件&lt;/h4&gt;
&lt;p&gt;在原来学习gRPC框架时，我们是将.proto文件按照grpc插件的标准来进行编译。而现在，我们学习的是go-micro，因此我们可以按照micro插件来进行编译。micro框架中的protobuf插件，我们需要单独安装。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装micro框架的protobuf插件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go get github.com/micro/protobuf/{proto,protoc-gen-go}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过上述命令可以成功安装proto插件,安装成功后可以在本地环境中的$GOPATH目录中的src/github.com/micro/protobuf中看到新安装的插件。源码目录如下图所示：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190826-113159@2x.png&#34; alt=&#34;micro中的protobuf插件&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定micro插件进行编译&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;protoc --go_out=plugins=micro:. message.proto
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述编译命令执行成功，可以在项目目录下的message目录下生成message.pb.go文件，该文件是由protoc编译器自动编译生成，开发者不能修改。message.pb.go如图所示：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190826-113429@2x.png&#34; alt=&#34;编译后的文件&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;233编码实现服务功能&#34;&gt;2.3.3、编码实现服务功能&lt;/h4&gt;
&lt;p&gt;在项目目录下，实现StudentService定义的rpc GetStudent功能。新建studentManager.go文件，具体实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//学生服务管理实现
type StudentManager struct {
}

//获取学生信息的服务接口实现
func GetStudent(ctx context.Context, request *message.StudentRequest, response *message.Student) error {

	studentMap := map[string]message.Student{
		&amp;quot;davie&amp;quot;:  message.Student{Name: &amp;quot;davie&amp;quot;, Classes: &amp;quot;软件工程专业&amp;quot;, Grade: 80},
		&amp;quot;steven&amp;quot;: message.Student{Name: &amp;quot;steven&amp;quot;, Classes: &amp;quot;计算机科学与技术&amp;quot;, Grade: 90},
		&amp;quot;tony&amp;quot;:   message.Student{Name: &amp;quot;tony&amp;quot;, Classes: &amp;quot;计算机网络工程&amp;quot;, Grade: 85},
		&amp;quot;jack&amp;quot;:   message.Student{Name: &amp;quot;jack&amp;quot;, Classes: &amp;quot;工商管理&amp;quot;, Grade: 96},
	}

	if request.Name == &amp;quot;&amp;quot; {
		return errors.New(&amp;quot; 请求参数错误,请重新请求。&amp;quot;)
	}

	student := studentMap[request.Name]
	
	if student.Name != &amp;quot;&amp;quot; {
		response = &amp;amp;student
	}
	return errors.New(&amp;quot; 未查询当相关学生信息 &amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;24运行服务&#34;&gt;2.4、运行服务&lt;/h3&gt;
&lt;p&gt;在之前的学习过程中，我们是通过自己编写server.go程序,注册服务，并实现请求的监听。现在，我们用micro框架来实现服务的运行。完整的运行服务的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

	//创建一个新的服务对象实例
	service := micro.NewService(
		micro.Name(&amp;quot;student_service&amp;quot;),
		micro.Version(&amp;quot;v1.0.0&amp;quot;),
	)

	//服务初始化
	service.Init()

	//注册
message.RegisterStudentServiceHandler(service.Server(), new(StudentManager))
	
	//运行
	err := service.Run()
	if err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;25客户端调用&#34;&gt;2.5、客户端调用&lt;/h3&gt;
&lt;p&gt;客户端可以构造请求对象，并访问对应的服务方法。具体方法实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

	service := micro.NewService(
		micro.Name(&amp;quot;student.client&amp;quot;),
	)
	service.Init()

	studentService := message.NewStudentServiceClient(&amp;quot;student_service&amp;quot;, service.Client())

	res, err := studentService.GetStudent(context.TODO(), &amp;amp;message.StudentRequest{Name: &amp;quot;davie&amp;quot;})
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(res.Name)
	fmt.Println(res.Classes)
	fmt.Println(res.Grade)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;26运行结果&#34;&gt;2.6、运行结果&lt;/h3&gt;
&lt;h4 id=&#34;261运行服务端&#34;&gt;2.6.1、运行服务端&lt;/h4&gt;
&lt;p&gt;运行main.go文件中的main函数,服务注册成功，并输出如下日志：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190826-231749@2x.png&#34; alt=&#34;服务注册&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;2019/08/26 22:50:18 Transport [http] Listening on [::]:54343
2019/08/26 22:50:18 Broker [http] Connected to [::]:54344
2019/08/26 22:50:19 Registry [mdns] Registering node: student_service-346b454c-998d-4e85-a8cc-befbc0198eef
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;262运行客户端&#34;&gt;2.6.2、运行客户端&lt;/h4&gt;
&lt;p&gt;客户端负责发起请求和功能调用,运行client.go程序，程序正常输出。&lt;/p&gt;
&lt;h3 id=&#34;27注册服务到consul&#34;&gt;2.7、注册服务到consul&lt;/h3&gt;
&lt;h4 id=&#34;271默认注册到mdns&#34;&gt;2.7.1、默认注册到mdns&lt;/h4&gt;
&lt;p&gt;在我们运行服务端的程序时，我们可以看到Registry [mdns] Registering node:xxx这个日志,该日志显示go-micro框架将我们的服务使用默认的配置注册到了mdns中。mdns是可简单翻译为mdns，是go-micro的默认配置选项。&lt;/p&gt;
&lt;h4 id=&#34;272注册到consul&#34;&gt;2.7.2、注册到consul&lt;/h4&gt;
&lt;p&gt;在前面的微服务理论课程中，我们已经学习过consul。consul是服务注册与发现的组件,因此，如果我们本地系统已经安装了consul环境，我们可以选择将我们的服务注册到consul中。指定注册到consul时，需要先将consul进行启动。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;启动consul
启动命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;consul agent -dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过上述命令，我们可以在终端中启动consul。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指定服务注册到consul
通过命令运行服务程序，并指定注册到consul，详细命令如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go run main.go --registry=consul
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过--registry选项，指定要注册到的服务发现组件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查看服务
由于consul给我们提供了ui界面，因此我们可以通过浏览器界面来访问consul节点页面。访问本地8500端口,浏览器地址是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;http://localhost:8500
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190827-083248@2x.png&#34; alt=&#34;服务注册到consul&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/rpc/">RPC</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/grpc/">GRPC</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>go-micro使用(二)</title>
                <link>http://www.songx.fun/blog/day83-85go-micro%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day85_go-micro%E4%BD%BF%E7%94%A8%E4%BA%8C/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day83-85go-micro%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day85_go-micro%E4%BD%BF%E7%94%A8%E4%BA%8C/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;go-micro使用二&#34;&gt;go-micro使用(二)&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;micro负载均衡组件--selector&#34;&gt;Micro负载均衡组件--Selector&lt;/h2&gt;
&lt;h3 id=&#34;背景&#34;&gt;背景&lt;/h3&gt;
&lt;p&gt;在Go-micro中的介绍课程中，我们说过go-micro具备负载均衡功能。所谓负载均衡，英文为Load Balance，其意思是将负载进行平衡、分摊到多个操作单元上进行执行。例如Web服务器，应用服务器，微服务程序服务器等，以此来完成达到高并发的目的。&lt;/p&gt;
&lt;p&gt;当只有一台服务部署程序时，是不存在负载均衡问题的，此时所有的请求都由同一台服务器进行处理。随着业务复杂度的增加和功能迭代，单一的服务器无法满足业务增长需求，需要靠分布式来提高系统的扩展性，随着而来的就是负载均衡的问题。因此需要加入负载均衡组件或者功能，两者的区别和负载均衡的作用如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190908-174630@2x.png&#34; alt=&#34;负载均衡器的作用&#34;&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，用户先访问负载均衡器，再由负载均衡器对请求进行处理，进而分发到不同的服务器上的服务程序进行处理。&lt;/p&gt;
&lt;p&gt;负载均衡器主要处理四种请求，分别是：HTTP、HTTPS、TCP、UDP。&lt;/p&gt;
&lt;h3 id=&#34;负载均衡算法&#34;&gt;负载均衡算法&lt;/h3&gt;
&lt;p&gt;负载均衡器的作用既然是负责接收请求，并实现请求的分发，因此需要按照一定的规则进行转发处理。负载均衡器可以按照不同的规则实现请求的转发，其遵循的转发规则称之为负载均衡算法。常用的负载均衡算法有以下几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Round Robin（轮训算法）：所谓轮训算法，其含义很简单，就是按照一定的顺序进行依次排队分发。当有请求队列需要转发时，为第一个请求选择可用服务列表中的第一个服务器，为下一个请求选择服务列表中的第二个服务器。按照此规则依次向下进行选择分发，直到选择到服务器列表的最后一个。当第一次列表转发完毕后，重新选择第一个服务器进行分发，此为轮训。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Least Connections（最小连接）：因为分布式系统中有多台服务器程序在运行，每台服务器在某一个时刻处理的连接请求数量是不一样的。因此，当有新的请求需要转发时，按照最小连接数原则，负载均衡器会有限选择当前连接数最小的服务器，以此来作为转发的规则。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Source（源）：还有一种常见的方式是将请求的IP进行hash计算，根据结算结果来匹配要转发的服务器，然后进行转发。这种方式可以一定程度上保证特定用户能够连接到相同的服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mico的selector&#34;&gt;Mico的Selector&lt;/h3&gt;
&lt;p&gt;Selector的英文是选择器的意思，在Micro中实现了Selector组件，运行在客户端实现负载均衡功能。当客户端需要调用服务端方法时，客户端会根据其内部的selector组件中指定的负载均衡策略选择服务注册中中的一个服务实例。Go-micro中的Selector是基于Register模块构建的，提供负载均衡策略，同时还提供过滤、缓存和黑名单等功能。&lt;/p&gt;
&lt;h3 id=&#34;selector定义&#34;&gt;Selector定义&lt;/h3&gt;
&lt;p&gt;首先，让我们来看一下Selector的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Selector interface {
	Init(opts ...Option) error
	Options() Options
	// Select returns a function which should return the next node
	Select(service string, opts ...SelectOption) (Next, error)
	// Mark sets the success/error against a node
	Mark(service string, node *registry.Node, err error)
	// Reset returns state back to zero for a service
	Reset(service string)
	// Close renders the selector unusable
	Close() error
	// Name of the selector
	String() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上是go-micro框架中的Selector的定义，Selector接口定义中包含Init、Options、Mark、Reset、Close、String方法。其中Select是核心方法，可以实现自定义的负载均衡策略，Mark方法用于标记服务节点的状态,String方法返回自定义负载均衡器的名称。&lt;/p&gt;
&lt;h3 id=&#34;defaultselector&#34;&gt;DefaultSelector&lt;/h3&gt;
&lt;p&gt;在selector包下，除Selector接口定义外，还包含DefaultSelector的定义，作为go-micro默认的负载均衡器而被使用。DefaultSelector是通过NewSelector函数创建生成的。NewSelector函数实现如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewSelector(opts ...Option) Selector {
	sopts := Options{
		Strategy: Random,
	}

	for _, opt := range opts {
		opt(&amp;amp;sopts)
	}

	if sopts.Registry == nil {
		sopts.Registry = registry.DefaultRegistry
	}

	s := &amp;amp;registrySelector{
		so: sopts,
	}
	s.rc = s.newCache()

	return s
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在NewSelector中，实例化了registrySelector对象并进行了返回,在实例化的过程中，配置了Selector的Options选项，默认的配置是Random。我们进一步查看会发现Random是一个func，定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Random(services []*registry.Service) Next {
	var nodes []*registry.Node

	for _, service := range services {
		nodes = append(nodes, service.Nodes...)
	}

	return func() (*registry.Node, error) {
		if len(nodes) == 0 {
			return nil, ErrNoneAvailable
		}

		i := rand.Int() % len(nodes)
		return nodes[i], nil
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该算法是go-micro中默认的负载均衡器，会随机选择一个服务节点进行分发；除了Random算法外，还可以看到RoundRobin算法，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func RoundRobin(services []*registry.Service) Next {
	var nodes []*registry.Node

	for _, service := range services {
		nodes = append(nodes, service.Nodes...)
	}

	var i = rand.Int()
	var mtx sync.Mutex

	return func() (*registry.Node, error) {
		if len(nodes) == 0 {
			return nil, ErrNoneAvailable
		}

		mtx.Lock()
		node := nodes[i%len(nodes)]
		i++
		mtx.Unlock()
		return node, nil
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;registryselector&#34;&gt;registrySelector&lt;/h3&gt;
&lt;p&gt;registrySelector是selector包下default.go文件中的结构体定义，具体定义如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type registrySelector struct {
	so Options
	rc cache.Cache
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;缓存cache&#34;&gt;缓存Cache&lt;/h4&gt;
&lt;p&gt;目前已经有了负载均衡器，我们可以看到在Selector的定义中，还包含一个cache.Cache结构体类型，这是什么作用呢？&lt;/p&gt;
&lt;p&gt;有了Selector以后，我们每次请求负载均衡器都要去Register组件中查询一次，这样无形之中就增加了成本，降低了效率，没有办法达到高可用。为了解决以上这种问题，在设计Selector的时候设计一个缓存，Selector将自己查询到的服务列表数据缓存到本地Cache中。当需要处理转发时，先到缓存中查找，如果能找到即分发；如果缓存当中没有，会执行请求服务发现注册组件，然后缓存到本地。
具体的实现机制如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Cache interface {
	// embed the registry interface
	registry.Registry
	// stop the cache watcher
	Stop()
}

func (c *cache) watch(w registry.Watcher) error {
	// used to stop the watch
	stop := make(chan bool)

	// manage this loop
	go func() {
		defer w.Stop()

		select {
		// wait for exit
		case &amp;lt;-c.exit:
			return
		// we&#39;ve been stopped
		case &amp;lt;-stop:
			return
		}
	}()

	for {
		res, err := w.Next()
		if err != nil {
			close(stop)
			return err
		}
		c.update(res)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过watch实现缓存的更新、创建、移除等操作。&lt;/p&gt;
&lt;h4 id=&#34;黑名单&#34;&gt;黑名单&lt;/h4&gt;
&lt;p&gt;在了解完了缓存后，我们再看看Selector中其他的方法。在Selector接口的定义中，还可以看到有Mark和Resetf昂发的声明。具体声明如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Mark sets the success/error against a node
Mark(service string, node *registry.Node, err error)
// Reset returns state back to zero for a service
Reset(service string)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mark方法可以用于标记服务注册和发现组件中的某一个节点的状态，这是因为在某些情况下，负载均衡器跟踪请求的执行情况。如果请求被转发到某天服务节点上，多次执行失败，就意味着该节点状态不正常，此时可以通过Mark方法设置节点变成黑名单，以过滤掉掉状态不正常的节点。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/rpc/">RPC</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/grpc/">GRPC</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>go-micro使用(一)</title>
                <link>http://www.songx.fun/blog/day83-85go-micro%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day84_go-micro%E4%BD%BF%E7%94%A8%E4%B8%80/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day83-85go-micro%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day84_go-micro%E4%BD%BF%E7%94%A8%E4%B8%80/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;go-micro使用一&#34;&gt;go-micro使用(一)&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一心跳机制与可选项配置&#34;&gt;一、心跳机制与可选项配置&lt;/h2&gt;
&lt;h3 id=&#34;11背景&#34;&gt;1.1、背景&lt;/h3&gt;
&lt;p&gt;在前面一节课中,我们指定了consul作为微服务的注册组件，并在consul中看到了注册的新服务。这其中还包含其他内容，本节课我们继续来看。&lt;/p&gt;
&lt;h3 id=&#34;12代码实现consul配置&#34;&gt;1.2、代码实现consul配置&lt;/h3&gt;
&lt;p&gt;上节课中，我们使用的--registry选项配置的形式来指定注册到consul组件中，其实这一配置也可以在代码中进行实现。上节课说了go-micro在创建服务时提供了很多可选项配置，其中就包含服务组件的指定。指定注册到consul的编程代码实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...
   //创建一个新的服务对象实例
	service := micro.NewService(
		micro.Name(&amp;quot;student_service&amp;quot;),
		micro.Version(&amp;quot;v1.0.0&amp;quot;),
		micro.Registry(consul.NewRegistry()),
	)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过micro.Registry可以指定要注册的发现组件，这里我们注册到consul，因此调用consul.NewRegistry。&lt;/p&gt;
&lt;h3 id=&#34;13插件化&#34;&gt;1.3、插件化&lt;/h3&gt;
&lt;p&gt;在前面的go-micro介绍课中，我们提到过go-micro是支持插件化的基础的微服务框架，不仅仅是go-micro，整个的micro都被设计成为“可插拔”的机制。&lt;/p&gt;
&lt;p&gt;在上一节课的案例中，我们使用--registry选项指定将服务注册到对应的服务发现组件，我们选择的是注册到consul中。这里的--registry就是是“可插拔”的插件化机制的体现。因为在2019年最新的代码中，go-micro中默认将服务注册到mdns中，同时支持开发者手动指定特定的服务发现组件。&lt;/p&gt;
&lt;p&gt;我们可以看到在这个过程中，我们的服务的程序没有发生任何变化，但是却轻松的实现了服务注册发现组件的更换，这就是插件化的优势，利用插件化能最大限度的解耦。&lt;/p&gt;
&lt;p&gt;在go-micro框架中，支持consul，etcd，zookeeper，dns等组件实现服务注册和发现的功能。如果有需要，开发者可以根据自己的需要进行服务发现组件的替换。&lt;/p&gt;
&lt;h3 id=&#34;14服务注册发现的原理&#34;&gt;1.4、服务注册发现的原理&lt;/h3&gt;
&lt;p&gt;让我们再回顾一下服务注册与发现的原理：服务注册发现是将所有的服务注册到注册组件中心，各服务在进行互相调用功能时，先通过查询方法获取到要调用的服务的状态信息和地址，然后向对应的微服务模块发起调用。我们学习过consul的工作原理和环境搭建，congsul的工作原理图如下所示：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190828-152536@2x.png&#34; alt=&#34;consul注册与发现&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;15未发现服务错误&#34;&gt;1.5、未发现服务错误&lt;/h3&gt;
&lt;p&gt;回顾完了服务注册发现的原理，我们就可以知道，如果请求发起端程序不能在服务组件中发现对应的服务，则会产生错误。接下来我们利用程序演示错误。&lt;/p&gt;
&lt;p&gt;首先，通过终端命令启动consul节点服务，以方便服务注册：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;consul agent -dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;151指定服务程序注册到consul&#34;&gt;1.5.1、指定服务程序注册到consul&lt;/h4&gt;
&lt;p&gt;我们利用已经学习过的服务注册可选项指定注册到consul组件，详细命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go run main.go --registry=consul
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过该命令，可以成功将服务注册到consul组件，并启动服务开始运行。&lt;/p&gt;
&lt;h4 id=&#34;152运行客户端服务&#34;&gt;1.5.2、运行客户端服务&lt;/h4&gt;
&lt;p&gt;由于服务端程序已经注册到consul,因此客户端程序在执行时也需要到consul中查询才能正确执行。运行客户端并注册到consul组件的命令是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go run client.go --registry=consul
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过以上命令，程序可以正确得到执行，并输出正确结果。&lt;/p&gt;
&lt;h4 id=&#34;153未发现服务错误&#34;&gt;1.5.3、未发现服务错误&lt;/h4&gt;
&lt;p&gt;我们可以主动让程序发生错误，来验证未发现的错误，以此来验证我们所学习的服务注册与发现的原理。在执行客户端程序时，我们不指定--registry选项，默认使用mdns，则命令为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go run client.go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们执行上述命令，运行客户端程序。由于我们的客户端程序会连接对应的服务的方法，但是对应的服务并没有注册到mdns中，因此，程序会发生错误。本案例中，客户端程序执行错误如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{&amp;quot;id&amp;quot;:&amp;quot;go.micro.client&amp;quot;,&amp;quot;code&amp;quot;:500,&amp;quot;detail&amp;quot;:&amp;quot;error selecting student_service node: not found&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;Internal Server Error&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以看到，程序返回了错误信息，提示我们服务未找到。&lt;/p&gt;
&lt;p&gt;通过这个主动错误的示范，我们能更加深刻的理解go-micro与consul的插件式协同工作和微服务内部的原理。&lt;/p&gt;
&lt;h3 id=&#34;16弊端与解决方法&#34;&gt;1.6、弊端与解决方法&lt;/h3&gt;
&lt;p&gt;服务实例与发现组件的工作机制是：当服务开启时，将自己的相关信息注册到发现组件中，当服务关闭时，发送卸载或者移除请求。在实际生产环境中，服务可能会出现很多异常情况，发生宕机或者其他等情况，往往服务进程会被销毁，或者网络出现故障也会导致通信链路发生问题，在这些情况下，服务实例会在服务发现组件中被移除。&lt;/p&gt;
&lt;h4 id=&#34;161ttl和间隔时间&#34;&gt;1.6.1、TTL和间隔时间&lt;/h4&gt;
&lt;p&gt;为了解决这个问题，go-micro框架提供了TTL机制和间隔时间注册机制。TTL是Time-To-Live的缩写，指定一次注册在注册组件中的有效期，过期后便会删除。而间隔时间注册则表示定时向注册组件中重新注册以确保服务在线。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指令方式
这两种注册方式都可以通过可选项指令来实现配置，具体的命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go run main.go --registry=consul --register_ttl=10 --register_interval=5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该命令表示我们每间隔5秒钟向服务注册组件注册一次，每次有效期限是10秒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编码方式
除了使用指令的方式以外，还可以在代码中实现这两种参数的设定，在微服务创建时通过配置来完成。具体代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...
service := micro.NewService(
  	micro.Name(&amp;quot;student_service&amp;quot;),
  	micro.Version(&amp;quot;v1.0.0&amp;quot;),
  	micro.RegisterTTL(10*time.Second),
  	micro.RegisterInterval(5*time.Second),
  )
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分别通过micro.RegisterTTL和micro.RegisterInterval来实现两个选项的设置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二解耦利器--事件驱动机制&#34;&gt;二、解耦利器--事件驱动机制&lt;/h2&gt;
&lt;p&gt;前面我们已经学习了创建微服务和启动微服务的可选项配置，今天我们来学习事件驱动机制&lt;/p&gt;
&lt;h3 id=&#34;21背景&#34;&gt;2.1、背景&lt;/h3&gt;
&lt;p&gt;之前的课程中我们已经学习了使用go-micro创建微服务，并实现了服务的调用。我们具体的实现是实例化了client对象，并调用了对应服务的相关方法。这种方式可以实现系统功能，但有比较大的缺点。&lt;/p&gt;
&lt;p&gt;我们通过举例来说明：在某个系统中存在用户服务（user service)、产品服务（product service)和消息服务（message service）。如果用户服务中要调用消息服务中的功能方法，则具体的实现方式可用下图所示方法表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190831-163801@2x.png&#34; alt=&#34;高耦合调用方式&#34;&gt;&lt;/p&gt;
&lt;p&gt;按照正常的实现是在user service模块的程序中实例化message service的一个client，然后进行RPC调用，调用sendMessage来实现发送消息。&lt;/p&gt;
&lt;h4 id=&#34;211缺点&#34;&gt;2.1.1、缺点&lt;/h4&gt;
&lt;p&gt;这种实现方式代码耦合度高，用户服务的模块中出现了消息服务模块的代码，不利于系统的扩展和功能的迭代开发。&lt;/p&gt;
&lt;h3 id=&#34;22发布订阅机制&#34;&gt;2.2、发布/订阅机制&lt;/h3&gt;
&lt;h4 id=&#34;221事件驱动&#34;&gt;2.2.1、事件驱动&lt;/h4&gt;
&lt;p&gt;依然是上述的案例，用户服务在用户操作的过程中，需要调用消息服务的某个方法，假设为发送验证码消息的一个方法。为了使系统代码能够实现解耦，用户服务并不直接调用消息服务的具体的方法，而是将用户信息等相关数据发送到一个中间组件，该组件负责存储消息，而消息服务会按照特定的频率访问中间的消息存储组件，并取出其中的消息,然后执行发送验证码等操作。具体的示意图如下所示：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190831-170056@2x.png&#34; alt=&#34;事件驱动&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上述的架构图中，我们可以看到，相较于之前的实现，多了一个中间的消息组件系统。&lt;/p&gt;
&lt;h4 id=&#34;222事件发布&#34;&gt;2.2.2、事件发布&lt;/h4&gt;
&lt;p&gt;只有当用户服务中的某个功能执行时，才会触发相应的事件，并将对应的用户数据等消息发送到消息队列组件中，这个过程我们称之为事件发布。&lt;/p&gt;
&lt;h4 id=&#34;223事件订阅&#34;&gt;2.2.3、事件订阅&lt;/h4&gt;
&lt;p&gt;与事件发布对应的是事件订阅。我们增加消息队列组件的目的是实现模块程序的解耦，原来是程序调用端主动进行程序调用，现在需要由另外一方模块的程序到消息队列组件中主动获取需要相关数据并进行相关功能调用。这个主动获取的过程称之为订阅。&lt;/p&gt;
&lt;p&gt;基于消息发布/订阅的消息系统有很多种框架的实现，常见的有：Kafka、RabbitMQ、ActiveMQ、Kestrel、NSQ等。&lt;/p&gt;
&lt;h3 id=&#34;23broker&#34;&gt;2.3、Broker&lt;/h3&gt;
&lt;p&gt;在我们介绍go-micro的时已经提到过，go-micro整个框架都是插件式的设计。没错，这里的发布/订阅也是通过接口设计来实现的。&lt;/p&gt;
&lt;h4 id=&#34;231定义&#34;&gt;2.3.1、定义&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Broker interface {
	Init(...Option) error
	Options() Options
	Address() string
	Connect() error
	Disconnect() error
	Publish(topic string, m *Message, opts ...PublishOption) error
	Subscribe(topic string, h Handler, opts ...SubscribeOption) (Subscriber, error)
	String() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们要具体实现事件的发布和订阅功能，只需要安装对应支持的go-plugins插件实现就可以了。go-plugins里支持的消息队列方式有：kafka、nsq、rabbitmq、redis等。同时，go-micro本身支持三种broker，分别是http、nats、memory，默认的broker是http，在实际使用过程中往往使用第三方的插件来进行消息发布/订阅的实现。&lt;/p&gt;
&lt;p&gt;在本课程中，我们演示RabbitMQ插件实现的事件订阅和发布机制。&lt;/p&gt;
&lt;h3 id=&#34;24安装go-plugins&#34;&gt;2.4、安装go-plugins&lt;/h3&gt;
&lt;p&gt;在go-micro框架的学习过程中，需要频繁的用到相关的插件。因此，首先安装go-plugins插件库，在go-plugins插件库中，封装提供了go-micro框架中的插件机制的实现方案。&lt;/p&gt;
&lt;h4 id=&#34;241源码库&#34;&gt;2.4.1、源码库&lt;/h4&gt;
&lt;p&gt;在github网站上能够找到对应的go-plugins插件库的源码，源码地址是：&lt;a href=&#34;https://github.com/micro/go-plugins&#34;&gt;https://github.com/micro/go-plugins&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;242安装&#34;&gt;2.4.2、安装&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go get github.com/micro/go-plugins
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190902-162841@2x.png&#34; alt=&#34;go-plugins&#34;&gt;
可以通过上述的命令安装micro的插件库，安装以后可以在当前系统的$GOPATH/src/github.com/micro目录中找到对应的插件库源码。&lt;/p&gt;
&lt;h4 id=&#34;243broker实现&#34;&gt;2.4.3、Broker实现&lt;/h4&gt;
&lt;p&gt;在已经安装和下载的go-plugins插件库中,我们可以看到有一个broker目录，其中就封装了go-micro框架的broker机制支持的解决方案。&lt;/p&gt;
&lt;p&gt;我们在本案例中，以mqtt进行讲解。&lt;/p&gt;
&lt;h3 id=&#34;25mqtt介绍及环境搭建&#34;&gt;2.5、MQTT介绍及环境搭建&lt;/h3&gt;
&lt;h4 id=&#34;251mqtt简介&#34;&gt;2.5.1、MQTT简介&lt;/h4&gt;
&lt;p&gt;MQTT全称是Message Queuing Telemetry Transport，翻译为消息队列遥测传输协议，是一种基于发布/订阅模式的&amp;quot;轻量级&amp;quot;的通讯协议，该协议基于TCP/IP协议，由IBM在1999年发布。MQTT的最大优点在于，可以用极少的代码和有限的宽带,为连接远程设备提供提供实时可靠的消息服务。&lt;/p&gt;
&lt;h4 id=&#34;252mqtt安装&#34;&gt;2.5.2、MQTT安装&lt;/h4&gt;
&lt;p&gt;在MacOS系统下，安装MQTT的服务器Mosquitto。可以在MacOS终端中使用命令进行安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;brew install mosquitto
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;253运行mosquitto&#34;&gt;2.5.3、运行mosquitto&lt;/h4&gt;
&lt;p&gt;在MacOS系统中安装成功以后，可以通过命令进行启动mosquitto，具体操作命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$cd /usr/local/
$./sbin/mosquitto -c etc/mosquitto/mosquitto.conf -d -v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动成功后，会在终端中有如下所示的日志输出：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190903-140930@2x.png&#34; alt=&#34;启动mosquitto&#34;&gt;
出现如上图所示的输出内容，即表示mqtt启动成功。&lt;/p&gt;
&lt;p&gt;windows系统上的mqtt的安装和启动，可以到&lt;a href=&#34;https://activemq.apache.org/&#34;&gt;https://activemq.apache.org/&lt;/a&gt;中下载最新的安装文件，然后进行安装和运行。&lt;/p&gt;
&lt;h3 id=&#34;26编程实现&#34;&gt;2.6、编程实现&lt;/h3&gt;
&lt;p&gt;接下来进行订阅和发布机制的编程的实现。&lt;/p&gt;
&lt;h4 id=&#34;261消息组件初始化&#34;&gt;2.6.1、消息组件初始化&lt;/h4&gt;
&lt;p&gt;如果要想使用消息组件完成消息的发布和订阅，首先应该让消息组件正常工作。因此，需要先对消息组件进行初始化。我们可以在服务创建时，对消息组件进行初始化，并进行可选项配置,设置使用mqtt作为消息组件。代码实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...
server := micro.NewService(
		micro.Name(&amp;quot;go.micro.srv&amp;quot;),
		micro.Version(&amp;quot;latest&amp;quot;),
		micro.Broker(mqtt.NewBroker()),
)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用micro.Broker来指定特定的消息组件，并通过mqtt.NewBroker初始化一个mqtt实例对象,作为broker参数。&lt;/p&gt;
&lt;h4 id=&#34;262消息订阅&#34;&gt;2.6.2、消息订阅&lt;/h4&gt;
&lt;p&gt;因为是时间驱动机制，消息的发送方随时可能发布相关事件。因此需要消息的接收方先进行订阅操作，避免遗漏消息。go-micro框架中可以通过broker.Subscribe实现消息订阅。编程代码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...
pubSub := service.Server().Options().Broker
_, err := pubSub.Subscribe(&amp;quot;go.micro.srv.message&amp;quot;, func(event broker.Event) error {
		var req *message.StudentRequest
		if err := json.Unmarshal(event.Message().Body, &amp;amp;req); err != nil {
			return err
		}
		fmt.Println(&amp;quot; 接收到信息：&amp;quot;, req)
		//去执行其他操作
		
		return nil
	})
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;263消息发布&#34;&gt;2.6.3、消息发布&lt;/h4&gt;
&lt;p&gt;完成了消息的订阅，我们再来实现消息的发布。在客户端实现消息的发布。在go-micro框架中，可以使用broker.Publish来进行消息的发布,具体的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...

brok := service.Server().Options().Broker
if err := brok.Connect(); err != nil {
	log.Fatal(&amp;quot; broker connection failed, error : &amp;quot;, err.Error())
}

student := &amp;amp;message.Student{Name: &amp;quot;davie&amp;quot;, Classes: &amp;quot;软件工程专业&amp;quot;, Grade: 80, Phone: &amp;quot;12345678901&amp;quot;}
msgBody, err := json.Marshal(student)
if err != nil {
	log.Fatal(err.Error())
}
msg := &amp;amp;broker.Message{
	Header: map[string]string{
		&amp;quot;name&amp;quot;: student.Name,
	},
	Body: msgBody,
}

err = brok.Publish(&amp;quot;go.micro.srv.message&amp;quot;, msg)
if err != nil {
	log.Fatal(&amp;quot; 消息发布失败：%s\n&amp;quot;, err.Error())
} else {
	log.Print(&amp;quot;消息发布成功&amp;quot;)
}
	
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;27运行程序&#34;&gt;2.7、运行程序&lt;/h3&gt;
&lt;h4 id=&#34;271启动mqtt服务器&#34;&gt;2.7.1、启动mqtt服务器&lt;/h4&gt;
&lt;p&gt;mqtt服务器默认会在1883端口进行监听。&lt;/p&gt;
&lt;h4 id=&#34;272启动server程序&#34;&gt;2.7.2、启动server程序&lt;/h4&gt;
&lt;p&gt;首先运行server端程序的main.go文件中的main函数。&lt;/p&gt;
&lt;h4 id=&#34;273错误&#34;&gt;2.7.3、错误&lt;/h4&gt;
&lt;p&gt;在运行main.go程序时，会报如下错误：cannot find package &amp;quot;github.com/eclipse/paho.mqtt.golang&amp;quot;：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190903-113613@2x.png&#34; alt=&#34;错误&#34;&gt;&lt;/p&gt;
&lt;p&gt;需要我们安装对应的包源码，该包的源码地址在github地址代码库中：&lt;a href=&#34;https://github.com/eclipse/paho.mqtt.golang&#34;&gt;https://github.com/eclipse/paho.mqtt.golang&lt;/a&gt;，安装命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go get github.com/eclipse/paho.mqtt.golang
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;包安装后，可以执行server.go文件中的main函数，启动程序如下：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190903-145638@2x.png&#34; alt=&#34;server.go函数&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;274启动client程序&#34;&gt;2.7.4、启动client程序&lt;/h4&gt;
&lt;p&gt;server程序启动后，启动客户端程序client.go，可以输出正确日志。另外可以在mqtt终端中输出相关的消息订阅和发布的日志，如下图所示：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190903-150034@2x.png&#34; alt=&#34;mqtt日志&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;28弊端&#34;&gt;2.8、弊端&lt;/h3&gt;
&lt;p&gt;在服务端通过fmt.println日志，可以输出event.Message().Body)数据，其格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{&amp;quot;name&amp;quot;:&amp;quot;davie&amp;quot;,&amp;quot;classes&amp;quot;:&amp;quot;软件工程专业&amp;quot;,&amp;quot;grade&amp;quot;:80,&amp;quot;phone&amp;quot;:&amp;quot;12345678901&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以看到在服务实例之间传输的数据格式是json格式。根据之前学习proto知识可以知道，在进行消息通信时，采用JSON格式进行数据传输，其效率比较低。&lt;/p&gt;
&lt;p&gt;因此，这意味着，当我们在使用第三方消息组件进行消息发布/订阅时，会失去对protobuf的使用。这对追求高消息的开发者而言，是需要解决和改进的问题。因为使用protobuf可以直接在多个服务之间使用二进制流数据进行传输，要比json格式高效的多。&lt;/p&gt;
&lt;h3 id=&#34;29googlepubsub&#34;&gt;2.9、googlepubsub&lt;/h3&gt;
&lt;p&gt;在go-micro框架中内置的Broker插件中，有google提供的googlepubsub插件实现，位于代理层之上，同时还省略了使用第三方代理消息组件（如mqtt)。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;a href=&#34;https://cloud.google.com/pubsub/&#34;&gt;https://cloud.google.com/pubsub/&lt;/a&gt;。感兴趣的同学可以自己动手实现，此处我们作为拓展思路，不再进行实现。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/rpc/">RPC</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/grpc/">GRPC</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Go的执行原理以及Go的命令</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC9%E8%8A%82_go%E7%9A%84%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8Ago%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC9%E8%8A%82_go%E7%9A%84%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8Ago%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;go的执行原理以及go的命令&#34;&gt;Go的执行原理以及Go的命令&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一go的源码文件&#34;&gt;一、Go的源码文件&lt;/h2&gt;
&lt;p&gt;Go 的源码文件分类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/yuanmawenjian1.png&#34; alt=&#34;yuanmawenjian1&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图，分为三类：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、命令源码文件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;声明自己属于 main 代码包、包含无参数声明和结果声明的 main 函数。&lt;/p&gt;
&lt;p&gt;命令源码文件被安装以后，GOPATH 如果只有一个工作区，那么相应的可执行文件会被存放当前工作区的 bin 文件夹下；如果有多个工作区，就会安装到 GOBIN 指向的目录下。&lt;/p&gt;
&lt;p&gt;命令源码文件是 Go 程序的入口。&lt;/p&gt;
&lt;p&gt;同一个代码包中最好也不要放多个命令源码文件。多个命令源码文件虽然可以分开单独 go run 运行起来，但是无法通过 go build 和 go install。&lt;/p&gt;
&lt;p&gt;我们先打开上次课的hello目录，然后复制helloworld.go为helloworld2.go文件，并修改里面的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;
func main(){
	fmt.Println(&amp;quot;我是第二个helloworld文件&amp;quot;)
	fmt.Print(&amp;quot;Go Go Go !!!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;hello目录下有两个go文件了，一个是helloworld.go，一个是helloworld2.go。先说明一下，在上述文件夹中放了两个命令源码文件，同时都声明自己属于 main 代码包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/gomingling1.png&#34; alt=&#34;gomingling1&#34;&gt;&lt;/p&gt;
&lt;p&gt;打开终端，进入hello这个目录，也可以看到这两个文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;localhost:~ ruby cd go/src/hello
localhost:hello ruby ls
helloworld.go	helloworld2.go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们分别执行go run命令，可以看到两个go文件都可以被执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;localhost:hello ruby$ go run helloworld.go
HelloWorld
Go Go Go !!!localhost:hello ruby$ go run helloworld2.go
我是第二个helloworld文件
Go Go Go !!!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/gomingling2.png&#34; alt=&#34;gomingling2&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来执行 go build 和 go install ，看看会发生什么：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;localhost:hello ruby$ go build 
# hello
./helloworld2.go:3:6: main redeclared in this block
	previous declaration at ./helloworld.go:3:6
localhost:hello ruby$ go install
# hello
./helloworld2.go:3:6: main redeclared in this block
	previous declaration at ./helloworld.go:3:6
localhost:hello ruby$ 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/gomingling3.png&#34; alt=&#34;gomingling3&#34;&gt;&lt;/p&gt;
&lt;p&gt;这也就证明了多个命令源码文件虽然可以分开单独 go run 运行起来，但是无法通过 go build 和 go install。&lt;/p&gt;
&lt;p&gt;同理，如果命令源码文件和库源码文件也会出现这样的问题，库源码文件不能通过 go build 和 go install 这种常规的方法编译和安装。具体例子和上述类似，这里就不再贴代码了。&lt;/p&gt;
&lt;p&gt;所以命令源码文件应该是被单独放在一个代码包中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、库源码文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;库源码文件就是不具备命令源码文件上述两个特征的源码文件。存在于某个代码包中的普通的源码文件。&lt;/p&gt;
&lt;p&gt;库源码文件被安装后，相应的归档文件（.a 文件）会被存放到当前工作区的 pkg 的平台相关目录下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、测试源码文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;名称以 _test.go 为后缀的代码文件，并且必须包含 Test 或者 Benchmark 名称前缀的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestXXX( t *testing.T) {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;名称以 Test 为名称前缀的函数，只能接受 *testing.T 的参数，这种测试函数是功能测试函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func BenchmarkXXX( b *testing.B) {

}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;名称以 Benchmark 为名称前缀的函数，只能接受 *testing.B 的参数，这种测试函数是性能测试函数。&lt;/p&gt;
&lt;p&gt;现在答案就很明显了：&lt;/p&gt;
&lt;p&gt;命令源码文件是可以单独运行的。可以使用 go run 命令直接运行，也可以通过 go build 或 go install 命令得到相应的可执行文件。所以命令源码文件是可以在机器的任何目录下运行的。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;p&gt;比如平时我们在 LeetCode 上刷算法题，这时候写的就是一个程序，这就是命令源码文件，可以在电脑的任意一个文件夹新建一个 go 文件就可以开始刷题了，写完就可以运行，对比执行结果，答案对了就可以提交代码。&lt;/p&gt;
&lt;p&gt;但是公司项目里面的代码就不能这样了，只能存放在 GOPATH 目录下。因为公司项目不可能只有命令源码文件的，肯定是包含库源码文件，甚至包含测试源码文件的。&lt;/p&gt;
&lt;h2 id=&#34;二go的命令&#34;&gt;二、Go的命令&lt;/h2&gt;
&lt;p&gt;目前Go的最新版1.12里面基本命令有以下17个。&lt;/p&gt;
&lt;p&gt;我们可以打开终端输入：go help即可看到Go的这些命令以及简介。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;	bug         start a bug report
	build       compile packages and dependencies
	clean       remove object files and cached files
	doc         show documentation for package or symbol
	env         print Go environment information
	fix         update packages to use new APIs
	fmt         gofmt (reformat) package sources
	generate    generate Go files by processing source
	get         download and install packages and dependencies
	install     compile and install packages and dependencies
	list        list packages or modules
	mod         module maintenance
	run         compile and run Go program
	test        test packages
	tool        run specified go tool
	version     print Go version
	vet         report likely mistakes in packages
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中和编译相关的有build、get、install、run这4个。接下来就依次看看这四个的作用。&lt;/p&gt;
&lt;p&gt;在详细分析这4个命令之前，先罗列一下通用的命令标记，以下这些命令都可适用的：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-a&lt;/td&gt;
&lt;td&gt;用于强制重新编译所有涉及的 Go 语言代码包（包括 Go 语言标准库中的代码包），即使它们已经是最新的了。该标记可以让我们有机会通过改动底层的代码包做一些实验。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;使命令仅打印其执行过程中用到的所有命令，而不去真正执行它们。如果不只想查看或者验证命令的执行过程，而不想改变任何东西，使用它正好合适。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-race&lt;/td&gt;
&lt;td&gt;用于检测并报告指定 Go 语言程序中存在的数据竞争问题。当用 Go 语言编写并发程序的时候，这是很重要的检测手段之一。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;用于打印命令执行过程中涉及的代码包。这一定包括我们指定的目标代码包，并且有时还会包括该代码包直接或间接依赖的那些代码包。这会让你知道哪些代码包被执行过了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-work&lt;/td&gt;
&lt;td&gt;用于打印命令执行时生成和使用的临时工作目录的名字，且命令执行完成后不删除它。这个目录下的文件可能会对你有用，也可以从侧面了解命令的执行过程。如果不添加此标记，那么临时工作目录会在命令执行完毕前删除。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-x&lt;/td&gt;
&lt;td&gt;使命令打印其执行过程中用到的所有命令，并同时执行它们。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;1-go-run&#34;&gt;1. go run&lt;/h3&gt;
&lt;p&gt;专门用来运行命令源码文件的命令，&lt;strong&gt;注意，这个命令不是用来运行所有 Go 的源码文件的！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;go run 命令只能接受一个命令源码文件以及若干个库源码文件（必须同属于 main 包）作为文件参数，且&lt;strong&gt;不能接受测试源码文件&lt;/strong&gt;。它在执行时会检查源码文件的类型。如果参数中有多个或者没有命令源码文件，那么 go run 命令就只会打印错误提示信息并退出，而不会继续执行。&lt;/p&gt;
&lt;p&gt;这个命令具体干了些什么事情呢？来分析分析，我们先重新创建一个新文件：mytest.go，并加入以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;
func main(){
	fmt.Println(&amp;quot;HelloWorld&amp;quot;)
	fmt.Println(&amp;quot;你好，Go!!!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行go run 配合-n：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;localhost:hello ruby$ go run -n mytest.go 

#
# command-line-arguments
#

mkdir -p $WORK/b001/
cat &amp;gt;$WORK/b001/importcfg &amp;lt;&amp;lt; &#39;EOF&#39; # internal
# import config
packagefile fmt=/usr/local/go/pkg/darwin_amd64/fmt.a
packagefile runtime=/usr/local/go/pkg/darwin_amd64/runtime.a
EOF
cd /Users/ruby/go/src/hello
/usr/local/go/pkg/tool/darwin_amd64/compile -o $WORK/b001/_pkg_.a -trimpath $WORK/b001 -p main -complete -buildid ieg41NOobNF0eqq3xgnP/ieg41NOobNF0eqq3xgnP -dwarf=false -goversion go1.12.1 -D _/Users/ruby/go/src/hello -importcfg $WORK/b001/importcfg -pack -c=4 ./mytest.go
/usr/local/go/pkg/tool/darwin_amd64/buildid -w $WORK/b001/_pkg_.a # internal
cat &amp;gt;$WORK/b001/importcfg.link &amp;lt;&amp;lt; &#39;EOF&#39; # internal
... # 此处省略
EOF
mkdir -p $WORK/b001/exe/
cd .
/usr/local/go/pkg/tool/darwin_amd64/link -o $WORK/b001/exe/mytest -importcfg $WORK/b001/importcfg.link -s -w -buildmode=exe -buildid=vpgT856LhbZPXp6WeHib/ieg41NOobNF0eqq3xgnP/ieg41NOobNF0eqq3xgnP/vpgT856LhbZPXp6WeHib -extld=clang $WORK/b001/_pkg_.a
$WORK/b001/exe/mytest
localhost:hello ruby$ 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/gomingling4.gif&#34; alt=&#34;gomingling4&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里可以看到创建了两个临时文件夹 b001 和 exe，先执行了 compile 命令，然后 link，生成了归档文件.a 和 最终可执行文件，最终的可执行文件放在 exe 文件夹里面。命令的最后一步就是执行了可执行文件。&lt;/p&gt;
&lt;p&gt;总结一下如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/gomingling5.jpg&#34; alt=&#34;gomingling5&#34;&gt;&lt;/p&gt;
&lt;p&gt;举个例子，生成的临时文件可以用&lt;code&gt;go run -work&lt;/code&gt;看到，比如当前生成的临时文件夹是如下的路径：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;localhost:hello ruby$ go run -work mytest.go 
WORK=/var/folders/kt/nlhsnpgn6lgd_q16f8j83sbh0000gn/T/go-build593750496
HelloWorld
你好，Go!!!
localhost:hello ruby$ 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们进入：&lt;code&gt;/var/folders/kt/nlhsnpgn6lgd_q16f8j83sbh0000gn/T/go-build593750496&lt;/code&gt;目录，可以看到如下目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/gomingling6.png&#34; alt=&#34;gomingling6&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，最终&lt;code&gt;go run&lt;/code&gt;命令是生成了2个文件，一个是归档文件，一个是可执行文件。&lt;/p&gt;
&lt;p&gt;go run 命令在第二次执行的时候，如果发现导入的代码包没有发生变化，那么 go run 不会再次编译这个导入的代码包。直接静态链接进来。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;localhost:hello ruby$ go run -n mytest.go 
mkdir -p $WORK/b001/
cat &amp;gt;$WORK/b001/importcfg.link &amp;lt;&amp;lt; &#39;EOF&#39; # internal
packagefile command-line-arguments=/Users/ruby/Library/Caches/go-build/6b/6b9577027c8da20b0ae6da790267f558b3b71eea1feb44039fb933b35eaef6f9-d
packagefile fmt=/usr/local/go/pkg/darwin_amd64/fmt.a
...
EOF
mkdir -p $WORK/b001/exe/
cd .
/usr/local/go/pkg/tool/darwin_amd64/link -o $WORK/b001/exe/mytest -importcfg $WORK/b001/importcfg.link -s -w -buildmode=exe -buildid=goiqf_1cemqljgOYzSRA/ieg41NOobNF0eqq3xgnP/MVbHdxOky1BGK6Aq_4bM/goiqf_1cemqljgOYzSRA -extld=clang /Users/ruby/Library/Caches/go-build/6b/6b9577027c8da20b0ae6da790267f558b3b71eea1feb44039fb933b35eaef6f9-d
$WORK/b001/exe/mytest
localhost:hello ruby$ 

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-go-build&#34;&gt;2. go build&lt;/h3&gt;
&lt;p&gt;go build 命令主要是用于测试编译。在包的编译过程中，若有必要，会同时编译与之相关联的包。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果是普通包，当你执行go build命令后，不会产生任何文件。&lt;/li&gt;
&lt;li&gt;如果是main包，当只执行go build命令后，会在当前目录下生成一个可执行文件。如果需要在$GOPATH/bin目录下生成相应的exe文件，需要执行go install 或者使用 go build -o 路径/可执行文件。&lt;/li&gt;
&lt;li&gt;如果某个文件夹下有多个文件，而你只想编译其中某一个文件，可以在 go build 之后加上文件名，例如 go build a.go；go build 命令默认会编译当前目录下的所有go文件。&lt;/li&gt;
&lt;li&gt;你也可以指定编译输出的文件名。比如，我们可以指定go build -o 可执行文件名，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。&lt;/li&gt;
&lt;li&gt;go build 会忽略目录下以”_”或者”.”开头的go文件。&lt;/li&gt;
&lt;li&gt;如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当代码包中有且仅有一个命令源码文件的时候，在文件夹所在目录中执行 go build 命令，会在该目录下生成一个与目录同名的可执行文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;// 假设当前文件夹名叫 hello
localhost:hello ruby$ pwd
/Users/ruby/go/src/hello
localhost:hello ruby$ ls
helloworld.go
localhost:hello ruby$ go build
localhost:hello ruby$ ls
hello		helloworld.go
localhost:hello ruby$ 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是在当前目录直接生成了以当前文件夹为名的可执行文件（ 在 Mac 平台下是 Unix executable 文件，在 Windows 平台下是 exe 文件）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/gomingling7.png&#34; alt=&#34;gomingling7&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是这种情况下，如果使用 go install 命令，如果 GOPATH 里面只有一个工作区，就会在当前工作区的 bin 目录下生成相应的可执行文件。如果 GOPATH 下有多个工作区，则是在 GOBIN 下生成对应的可执行文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;localhost:hello ruby$ go install
go install hello: open /usr/local/go/bin/hello: permission denied
localhost:hello ruby$ 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/gomingling8.png&#34; alt=&#34;gomingling8&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个问题是因为它需要创建bin目录，然后把可刚才的可执行文件放进去，而目前我们在gopath下还没有bin目录，那么就需要先创建这个文件，而普通用户没有直接创建文件夹的权限，这个和Go语言的命令是没有关系的。我们可以加上sodu 来执行这个命令，表示使用管理员的身份执行，然后输入密码，那么就可以创建bin这个文件夹了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再次执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;localhost:hello ruby$ sudo go install
Password:
localhost:hello ruby$ 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行完 go install 会发现可执行文件不见了！去哪里了呢？其实是被移动到了 bin 目录下了（如果 GOPATH 下有多个工作区，就会放在GOBIN 目录下）。&lt;/p&gt;
&lt;p&gt;查看目录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/gomingling9.png&#34; alt=&#34;gomingling9&#34;&gt;&lt;/p&gt;
&lt;p&gt;那 go build 和 go install 究竟干了些什么呢？&lt;/p&gt;
&lt;p&gt;先来说说 go build。go build 用于编译我们指定的源码文件或代码包以及它们的依赖包。但是&lt;strong&gt;注意如果用来编译非命令源码文件，即库源码文件，go build 执行完是不会产生任何结果的。这种情况下，go build 命令只是检查库源码文件的有效性，只会做检查性的编译，而不会输出任何结果文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;go build 编译命令源码文件，则会在该命令的执行目录中生成一个可执行文件，上面的例子也印证了这个过程。&lt;/p&gt;
&lt;p&gt;go build 后面不追加目录路径的话，它就把当前目录作为代码包并进行编译。go build 命令后面如果跟了代码包导入路径作为参数，那么该代码包及其依赖都会被编译。&lt;/p&gt;
&lt;p&gt;go build 命令究竟做了些什么呢？我们可以执行-n这个命令来查看：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;localhost:hello ruby$ go build -n

#
# hello
#

mkdir -p $WORK/b001/
cat &amp;gt;$WORK/b001/importcfg &amp;lt;&amp;lt; &#39;EOF&#39; # internal
# import config
packagefile fmt=/usr/local/go/pkg/darwin_amd64/fmt.a
packagefile runtime=/usr/local/go/pkg/darwin_amd64/runtime.a
EOF
cd /Users/ruby/go/src/hello
/usr/local/go/pkg/tool/darwin_amd64/compile -o $WORK/b001/_pkg_.a -trimpath $WORK/b001 -p main -complete -buildid PXDetO1R1NhLFMK5QGUc/PXDetO1R1NhLFMK5QGUc -goversion go1.12.1 -D &amp;quot;&amp;quot; -importcfg $WORK/b001/importcfg -pack -c=4 ./helloworld.go
/usr/local/go/pkg/tool/darwin_amd64/buildid -w $WORK/b001/_pkg_.a # internal
cat &amp;gt;$WORK/b001/importcfg.link &amp;lt;&amp;lt; &#39;EOF&#39; # internal
packagefile hello=$WORK/b001/_pkg_.a
...
EOF
mkdir -p $WORK/b001/exe/
cd .
/usr/local/go/pkg/tool/darwin_amd64/link -o $WORK/b001/exe/a.out -importcfg $WORK/b001/importcfg.link -buildmode=exe -buildid=diTh1q6kcbGRIX3aj3mU/PXDetO1R1NhLFMK5QGUc/PXDetO1R1NhLFMK5QGUc/diTh1q6kcbGRIX3aj3mU -extld=clang $WORK/b001/_pkg_.a
/usr/local/go/pkg/tool/darwin_amd64/buildid -w $WORK/b001/exe/a.out # internal
mv $WORK/b001/exe/a.out hello
localhost:hello ruby$ 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，执行过程和 go run 大体相同，唯一不同的就是在最后一步，go run 是执行了可执行文件，但是 go build 命令，只是把库源码文件编译了一遍，然后把可执行文件移动到了当前目录的文件夹中。&lt;/p&gt;
&lt;p&gt;总结一下如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/gomingling10.jpg&#34; alt=&#34;gomingling10&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/zhixingyuanli.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-go-install&#34;&gt;3. go install&lt;/h3&gt;
&lt;p&gt;go install 命令是用来编译并安装代码包或者源码文件的。&lt;/p&gt;
&lt;p&gt;go install 命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到&lt;code&gt;$GOPATH/pkg&lt;/code&gt;或者​&lt;code&gt;$GOPATH/bin&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可执行文件： 一般是 go install 带main函数的go文件产生的，有函数入口，所有可以直接运行。&lt;/p&gt;
&lt;p&gt;.a应用包： 一般是 go install 不包含main函数的go文件产生的，没有函数入口，只能被调用。&lt;/p&gt;
&lt;p&gt;go install 用于编译并安装指定的代码包及它们的依赖包。当指定的代码包的依赖包还没有被编译和安装时，该命令会先去处理依赖包。与 go build 命令一样，传给 go install 命令的代码包参数应该以导入路径的形式提供。并且，go build 命令的绝大多数标记也都可以用于
实际上，go install 命令只比 go build 命令多做了一件事，即：安装编译后的结果文件到指定目录。&lt;/p&gt;
&lt;p&gt;安装代码包会在当前工作区的 pkg 的平台相关目录下生成归档文件（即 .a 文件）。
安装命令源码文件会在当前工作区的 bin 目录（如果 GOPATH 下有多个工作区，就会放在 GOBIN 目录下）生成可执行文件。&lt;/p&gt;
&lt;p&gt;同样，go install 命令如果后面不追加任何参数，它会把当前目录作为代码包并安装。这和 go build 命令是完全一样的。&lt;/p&gt;
&lt;p&gt;go install 命令后面如果跟了代码包导入路径作为参数，那么该代码包及其依赖都会被安装。&lt;/p&gt;
&lt;p&gt;go install 命令后面如果跟了命令源码文件以及相关库源码文件作为参数的话，只有这些文件会被编译并安装。&lt;/p&gt;
&lt;p&gt;go install 命令究竟做了些什么呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;localhost:hello ruby$ go install -n

#
# hello
#

mkdir -p $WORK/b001/
cat &amp;gt;$WORK/b001/importcfg &amp;lt;&amp;lt; &#39;EOF&#39; # internal
# import config
packagefile fmt=/usr/local/go/pkg/darwin_amd64/fmt.a
packagefile runtime=/usr/local/go/pkg/darwin_amd64/runtime.a
EOF
cd /Users/ruby/go/src/hello
/usr/local/go/pkg/tool/darwin_amd64/compile -o $WORK/b001/_pkg_.a -trimpath $WORK/b001 -p main -complete -buildid E1CTs4eXkD5M28s_FQXT/E1CTs4eXkD5M28s_FQXT -goversion go1.12.1 -D &amp;quot;&amp;quot; -importcfg $WORK/b001/importcfg -pack -c=4 ./helloworld.go
/usr/local/go/pkg/tool/darwin_amd64/buildid -w $WORK/b001/_pkg_.a # internal
cat &amp;gt;$WORK/b001/importcfg.link &amp;lt;&amp;lt; &#39;EOF&#39; # internal
packagefile hello=$WORK/b001/_pkg_.a
packagefile fmt=/usr/local/go/pkg/darwin_amd64/fmt.a
...
EOF
mkdir -p $WORK/b001/exe/
cd .
/usr/local/go/pkg/tool/darwin_amd64/link -o $WORK/b001/exe/a.out -importcfg $WORK/b001/importcfg.link -buildmode=exe -buildid=FJ6kJTmN9rcWcwLhqfiQ/E1CTs4eXkD5M28s_FQXT/E1CTs4eXkD5M28s_FQXT/FJ6kJTmN9rcWcwLhqfiQ -extld=clang $WORK/b001/_pkg_.a
/usr/local/go/pkg/tool/darwin_amd64/buildid -w $WORK/b001/exe/a.out # internal
mkdir -p /usr/local/go/bin/
mv $WORK/b001/exe/a.out /usr/local/go/bin/hello
localhost:hello ruby$ 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前面几步依旧和 go run 、go build 完全一致，只是最后一步的差别，go install 会把命令源码文件安装到当前工作区的 bin 目录（如果 GOPATH 下有多个工作区，就会放在 GOBIN 目录下）。如果是库源码文件，就会被安装到当前工作区的 pkg 的平台相关目录下。&lt;/p&gt;
&lt;p&gt;总结一下如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/gomingling11.jpg&#34; alt=&#34;gomingling11&#34;&gt;&lt;/p&gt;
&lt;p&gt;在安装多个库源码文件时有可能遇到如下的问题：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;localhost:hello ruby$  go install envir.go fpath.go ipath.go pnode.go util.go
go install: no install location for .go files listed on command line (GOBIN not set)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而且，在我们为环境变量 GOBIN 设置了正确的值之后，这个错误提示信息仍然会出现。这是因为，只有在安装命令源码文件的时候，命令程序才会将环境变量 GOBIN 的值作为结果文件的存放目录。而在安装库源码文件时，在命令程序内部的代表结果文件存放目录路径的那个变量不会被赋值。最后，命令程序会发现它依然是个无效的空值。所以，命令程序会同样返回一个关于“无安装位置”的错误。这就引出一个结论，我们只能使用安装代码包的方式来安装库源码文件，而不能在 go install 命令罗列并安装它们。另外，go install 命令目前无法接受标记&lt;code&gt;-o&lt;/code&gt;以自定义结果文件的存放位置。这也从侧面说明了
go install 命令不支持针对库源码文件的安装操作。&lt;/p&gt;
&lt;h3 id=&#34;4-go-get&#34;&gt;4. go get&lt;/h3&gt;
&lt;p&gt;go get 命令用于从远程代码仓库（比如 Github ）上下载并安装代码包。&lt;strong&gt;注意，go get 命令会把当前的代码包下载到 $GOPATH 中的第一个工作区的 src 目录中，并安装。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 go get 下载第三方包的时候，依旧会下载到 $GOPATH 的第一个工作空间，而非 vendor 目录。当前工作链中并没有真正意义上的包依赖管理，不过好在有不少第三方工具可选。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果在 go get 下载过程中加入&lt;code&gt;-d&lt;/code&gt; 标记，那么下载操作只会执行下载动作，而不执行安装动作。比如有些非常特殊的代码包在安装过程中需要有特殊的处理，所以我们需要先下载下来，所以就会用到&lt;code&gt;-d&lt;/code&gt; 标记。&lt;/p&gt;
&lt;p&gt;还有一个很有用的标记是&lt;code&gt;-u&lt;/code&gt;标记，加上它可以利用网络来更新已有的代码包及其依赖包。如果已经下载过一个代码包，但是这个代码包又有更新了，那么这时候可以直接用&lt;code&gt;-u&lt;/code&gt;标记来更新本地的对应的代码包。如果不加这个&lt;code&gt;-u&lt;/code&gt;标记，执行 go get 一个已有的代码包，会发现命令什么都不执行。只有加了&lt;code&gt;-u&lt;/code&gt;标记，命令会去执行 git pull 命令拉取最新的代码包的最新版本，下载并安装。&lt;/p&gt;
&lt;p&gt;命令 go get 还有一个很值得称道的功能——智能下载。在使用它检出或更新代码包之后，它会寻找与本地已安装 Go 语言的版本号相对应的标签（tag）或分支（branch）。比如，本机安装 Go 语言的版本是1.x，那么 go get 命令会在该代码包的远程仓库中寻找名为 “go1” 的标签或者分支。如果找到指定的标签或者分支，则将本地代码包的版本切换到此标签或者分支。如果没有找到指定的标签或者分支，则将本地代码包的版本切换到主干的最新版本。&lt;/p&gt;
&lt;p&gt;go get 常用的一些标记如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标记名称&lt;/th&gt;
&lt;th&gt;标记描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;让命令程序只执行下载动作，而不执行安装动作。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;仅在使用&lt;code&gt;-u&lt;/code&gt;标记时才有效。该标记会让命令程序忽略掉对已下载代码包的导入路径的检查。如果下载并安装的代码包所属的项目是你从别人那里 Fork 过来的，那么这样做就尤为重要了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-fix&lt;/td&gt;
&lt;td&gt;让命令程序在下载代码包后先执行修正动作，而后再进行编译和安装。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-insecure&lt;/td&gt;
&lt;td&gt;允许命令程序使用非安全的 scheme（如 HTTP ）去下载指定的代码包。如果你用的代码仓库（如公司内部的 Gitlab ）没有HTTPS 支持，可以添加此标记。请在确定安全的情况下使用它。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;让命令程序同时下载并安装指定的代码包中的测试源码文件中依赖的代码包。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-u&lt;/td&gt;
&lt;td&gt;让命令利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;go get 命令究竟做了些什么呢？我们还是来打印一下每一步的执行过程。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;localhost:hello ruby$ go get -x github.com/go-errors/errors
cd .
git clone https://github.com/go-errors/errors /Users/ruby/go/src/github.com/go-errors/errors
cd /Users/ruby/go/src/github.com/go-errors/errors
git submodule update --init --recursive
cd /Users/ruby/go/src/github.com/go-errors/errors
git show-ref
cd /Users/ruby/go/src/github.com/go-errors/errors
git submodule update --init --recursive
WORK=/var/folders/kt/nlhsnpgn6lgd_q16f8j83sbh0000gn/T/go-build188558329
localhost:hello ruby$ 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/gomingling12.png&#34; alt=&#34;gomingling12&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里可以很明显的看到，执行完 go get 命令以后，会调用 git clone 方法下载源码，并编译，最终会把库源码文件编译成归档文件安装到 pkg 对应的相关平台目录下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/gomingling13.png&#34; alt=&#34;gomingling13&#34;&gt;&lt;/p&gt;
&lt;p&gt;总结一下如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/gomingling14.jpg&#34; alt=&#34;gomingling14&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;5-其他命令&#34;&gt;5. 其他命令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;go clean&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;go clean 命令是用来移除当前源码包里面编译生成的文件，这些文件包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;_obj/ 旧的object目录，由Makefiles遗留&lt;/li&gt;
&lt;li&gt;_test/ 旧的test目录，由Makefiles遗留&lt;/li&gt;
&lt;li&gt;_testmain.go 旧的gotest文件，由Makefiles遗留&lt;/li&gt;
&lt;li&gt;test.out 旧的test记录，由Makefiles遗留&lt;/li&gt;
&lt;li&gt;build.out 旧的test记录，由Makefiles遗留&lt;/li&gt;
&lt;li&gt;*.[568ao] object文件，由Makefiles遗留&lt;/li&gt;
&lt;li&gt;DIR(.exe) 由 go build 产生&lt;/li&gt;
&lt;li&gt;DIR.test(.exe) 由 go test -c 产生&lt;/li&gt;
&lt;li&gt;MAINFILE(.exe) 由 go build MAINFILE.go产生&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;go fmt&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;go fmt 命令主要是用来帮你格式化所写好的代码文件。&lt;/p&gt;
&lt;p&gt;比如我们写了一个格式很糟糕的 test.go 文件，我们只需要使用 fmt go test.go 命令，就可以让go帮我们格式化我们的代码文件。但是我们一般很少使用这个命令，因为我们的开发工具一般都带有保存时自动格式化功能，这个功能底层其实就是调用了 go fmt 命令而已。&lt;/p&gt;
&lt;p&gt;使用go fmt命令，更多时候是用gofmt，而且需要参数-w，否则格式化结果不会写入文件。gofmt -w src，可以格式化整个项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;go test&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;go test 命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考go help testflag&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;go doc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;go doc 命令其实就是一个很强大的文档工具。&lt;/p&gt;
&lt;p&gt;如何查看相应package的文档呢？ 例如builtin包，那么执行go doc builtin；如果是http包，那么执行go doc net/http；查看某一个包里面的函数，那么执行go doc fmt Printf；也可以查看相应的代码，执行go doc -src fmt Printf；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看net/http包
localhost:hello ruby$ go doc net/http
# 查看time包
localhost:hello ruby$ go doc time
# 查看某个包里的指定函数
localhost:hello ruby$ go doc fmt Printf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过命令在命令行执行 go doc -http=:端口号，比如godoc -http=:8080。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档，这对于经常被限制访问的用户来说是一个不错的选择。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;localhost:hello ruby$ godoc -http=:9527
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go fix 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1&lt;/p&gt;
&lt;p&gt;go version 查看go当前的版本&lt;/p&gt;
&lt;p&gt;go env 查看当前go的环境变量&lt;/p&gt;
&lt;p&gt;go list 列出当前全部安装的package&lt;/p&gt;
&lt;p&gt;本文部门文字和图片引自：https://www.jianshu.com/p/35a4ec1b3067&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Go语言logo和版本</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC3%E8%8A%82_go%E8%AF%AD%E8%A8%80logo%E5%92%8C%E7%89%88%E6%9C%AC/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC3%E8%8A%82_go%E8%AF%AD%E8%A8%80logo%E5%92%8C%E7%89%88%E6%9C%AC/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;go语言logo和版本&#34;&gt;Go语言logo和版本&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一-go的logo&#34;&gt;一、 Go的logo&lt;/h2&gt;
&lt;h3 id=&#34;11-go语言的logo&#34;&gt;1.1 Go语言的logo&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/go_logo_meitu_1.jpg&#34; alt=&#34;go_logo_meitu_1&#34;&gt;&lt;/p&gt;
&lt;p&gt;Go语言的logo就是很简洁的GO两个字母。&lt;/p&gt;
&lt;h3 id=&#34;12-go的吉祥物&#34;&gt;1.2 Go的吉祥物&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/go_logo2.jpeg&#34; alt=&#34;go_logo2&#34;&gt;&lt;/p&gt;
&lt;p&gt;Go之所以叫Go，是想表达这门语言的运行速度、开发速度、学习速度（develop）都像gopher一样快。&lt;/p&gt;
&lt;p&gt;gopher是一种生活在加拿大的小动物，go的吉祥物就是这个小动物， 它的中文名叫做囊地鼠，他们最大的特点就是挖洞速度特别快，当然可能不止是挖洞啦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/tuboshu.jpeg&#34; alt=&#34;tuboshu&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;二go的官网httpsgolanggooglecn&#34;&gt;二、&lt;a href=&#34;https://golang.google.cn/&#34;&gt;Go的官网&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/goguanwang.png&#34; alt=&#34;goguanwang&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;三-go语言主要发展过程&#34;&gt;三、 Go语言主要发展过程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2007年9月，雏形设计 ，Rob Pike（罗伯.派克） 正式命名为Go；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2008年5月，Google全力支持该项目；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2009年11月10日，首次公开发布，Go将代码全部开源，它获得了当年的年度语言；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2011年3月16日，Go语言的第一个稳定(stable)版本r56发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2012年3月28日，Go语言的第一个正式版本Go1发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013年4月04日，Go语言的第一个Go 1.1beta1测试版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013年4月08日，Go语言的第二个Go 1.1beta2测试版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013年5月02日，Go语言Go 1.1RC1版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013年5月07日，Go语言Go 1.1RC2版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013年5月09日，Go语言Go 1.1RC3版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013年5月13日，Go语言Go 1.1正式版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013年9月20日，Go语言Go 1.2RC1版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013年12月1日，Go语言Go 1.2正式版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2014年6月18日，Go语言Go 1.3版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2014年12月10日，Go语言Go 1.4版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2015年8月19日，Go语言Go 1.5版发布，本次更新中移除了”最后残余的C代码”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016年2月17日，Go语言Go 1.6版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016年8月15日，Go语言Go 1.7版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2017年2月17日，Go语言Go 1.8版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2017年8月24日，Go语言Go 1.9版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2018年2月16日，Go语言Go 1.10版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2018年8月24日，Go语言Go 1.11版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2019年2月25日，GO语言Go1.12版发布。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。&lt;/p&gt;
&lt;p&gt;其实可以看到，Go语言的历史不算很短。&lt;/p&gt;
&lt;p&gt;2009年11月 GO语言第一个版本发布。2012年3月 第一个正式版本Go1.0发布。&lt;/p&gt;
&lt;p&gt;2015年8月 go1.5发布，这个版本被认为是历史性的。完全移除C语言部分，使用GO编译GO，少量代码使用汇编实现。另外，他们请来了内存管理方面的权威专家Rick Hudson，对GC进行了重新设计，支持并发GC，解决了一直以来广为诟病的GC时延（STW）问题。并且在此后的版本中，又对GC做了更进一步的优化。到go1.8时，相同业务场景下的GC时延已经可以从go1.1的数秒，控制在1ms以内。GC问题的解决，可以说GO语言在服务端开发方面，几乎抹平了所有的弱点。&lt;/p&gt;
&lt;p&gt;直到今年的2月25日，Go语言发布最新的版本是Go 1.12。&lt;/p&gt;
&lt;p&gt;在GO语言的版本迭代过程中，语言特性基本上没有太大的变化，基本上维持在GO1.1的基准上，并且官方承诺，新版本对老版本下开发的代码完全兼容。事实上，GO开发团队在新增语言特性上显得非常谨慎，而在稳定性、编译速度、执行效率以及GC性能等方面进行了持续不断的优化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Go稳定版发布时，Go Team承诺后续的版本都会兼容之前的版本。这对于开发者来说非常重要，Go后续的版本也一直在提升内功，从而可以让用户无缝的升级Go版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/image.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;本文部分图片来自网络，侵删&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934/&#34;&gt;https://www.bilibili.com/video/av56018934/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Go语言的核心特性</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC4%E8%8A%82_go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC4%E8%8A%82_go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;go语言的核心特性&#34;&gt;Go语言的核心特性&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Go语言，作为编程语言的后生，站在巨人的肩膀上，吸收了其他一些编程语言的特点。&lt;/p&gt;
&lt;p&gt;Go 编程语言是一个开源项目，它使程序员更具生产力。Go 语言具有很强的表达能力，它简洁、清晰而高效。得益于其并发机制， 用它编写的程序能够非常有效地利用多核与联网的计算机，其新颖的类型系统则使程序结构变得灵活而模块化。 Go 代码编译成机器码不仅非常迅速，还具有方便的垃圾收集机制和强大的运行时反射机制。 它是一个快速的、静态类型的编译型语言，感觉却像动态类型的解释型语言。(摘取自官网)&lt;/p&gt;
&lt;h2 id=&#34;一思想&#34;&gt;一、思想&lt;/h2&gt;
&lt;p&gt;Less can be more&lt;/p&gt;
&lt;p&gt;大道至简,小而蕴真&lt;/p&gt;
&lt;p&gt;让事情变得复杂很容易，让事情变得简单才难&lt;/p&gt;
&lt;p&gt;深刻的工程文化&lt;/p&gt;
&lt;h2 id=&#34;二核心特性&#34;&gt;二、核心特性&lt;/h2&gt;
&lt;p&gt;Go语言之所以厉害，是因为它在服务端的开发中，总能抓住程序员的痛点，以最直接、简单、高效、稳定的方式来解决问题。这里我们并不会深入讨论GO语言的具体语法，只会将语言中关键的、对简化编程具有重要意义的方面介绍给大家，体验Go的核心特性。&lt;/p&gt;
&lt;h3 id=&#34;21-并发编程&#34;&gt;2.1 并发编程&lt;/h3&gt;
&lt;p&gt;Go语言在并发编程方面比绝大多数语言要简洁不少，这一点是其最大亮点之一，也是其在未来进入高并发高性能场景的重要筹码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/bingfa1.jpg&#34; alt=&#34;bingfa1&#34;&gt;&lt;/p&gt;
&lt;p&gt;不同于传统的多进程或多线程，golang的并发执行单元是一种称为goroutine的协程。&lt;/p&gt;
&lt;p&gt;由于在共享数据场景中会用到锁，再加上GC，其并发性能有时不如异步复用IO模型，因此相对于大多数语言来说，golang的并发编程简单比并发性能更具卖点。&lt;/p&gt;
&lt;p&gt;在当今这个多核时代，并发编程的意义不言而喻。当然，很多语言都支持多线程、多进程编程，但遗憾的是，实现和控制起来并不是那么令人感觉轻松和愉悦。Golang不同的是，语言级别支持协程(goroutine)并发（协程又称微线程，比线程更轻量、开销更小，性能更高），操作起来非常简单，语言级别提供关键字（go）用于启动协程，并且在同一台机器上可以启动成千上万个协程。协程经常被理解为轻量级线程，一个线程可以包含多个协程，共享堆不共享栈。协程间一般由应用程序显式实现调度，上下文切换无需下到内核层，高效不少。协程间一般不做同步通讯，而golang中实现协程间通讯有两种：1）共享内存型，即使用全局变量+mutex锁来实现数据共享；2）消息传递型，即使用一种独有的channel机制进行异步通讯。&lt;/p&gt;
&lt;p&gt;对比JAVA的多线程和GO的协程实现，明显更直接、简单。这就是GO的魅力所在，以简单、高效的方式解决问题，关键字go，或许就是GO语言最重要的标志。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高并发是Golang语言最大的亮点&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;22-内存回收gc&#34;&gt;2.2 内存回收(GC)&lt;/h3&gt;
&lt;p&gt;从C到C++，从程序性能的角度来考虑，这两种语言允许程序员自己管理内存，包括内存的申请和释放等。因为没有垃圾回收机制所以C/C++运行起来速度很快，但是随着而来的是程序员对内存使用上的很谨小慎微的考虑。因为哪怕一点不小心就可能会导致“内存泄露”使得资源浪费或者“野指针”使得程序崩溃等，尽管C++11后来使用了智能指针的概念，但是程序员仍然需要很小心的使用。后来为了提高程序开发的速度以及程序的健壮性，java和C#等高级语言引入了GC机制，即程序员不需要再考虑内存的回收等，而是由语言特性提供垃圾回收器来回收内存。但是随之而来的可能是程序运行效率的降低。&lt;/p&gt;
&lt;p&gt;GC过程是：先stop the world，扫描所有对象判活，把可回收对象在一段bitmap区中标记下来，接着立即start the world，恢复服务，同时起一个专门gorountine回收内存到空闲list中以备复用，不物理释放。物理释放由专门线程定期来执行。&lt;/p&gt;
&lt;p&gt;GC瓶颈在于每次都要扫描所有对象来判活，待收集的对象数目越多，速度越慢。一个经验值是扫描10w个对象需要花费1ms，所以尽量使用对象少的方案，比如我们同时考虑链表、map、slice、数组来进行存储，链表和map每个元素都是一个对象，而slice或数组是一个对象，因此slice或数组有利于GC。&lt;/p&gt;
&lt;p&gt;GC性能可能随着版本不断更新会不断优化，这块没仔细调研，团队中有HotSpot开发者，应该会借鉴jvm gc的设计思想，比如分代回收、safepoint等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存自动回收，再也不需要开发人员管理内存&lt;/li&gt;
&lt;li&gt;开发人员专注业务实现，降低了心智负担&lt;/li&gt;
&lt;li&gt;只需要new分配内存，不需要释放&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-内存分配&#34;&gt;2.3 内存分配&lt;/h3&gt;
&lt;p&gt;初始化阶段直接分配一块大内存区域，大内存被切分成各个大小等级的块，放入不同的空闲list中，对象分配空间时从空闲list中取出大小合适的内存块。内存回收时，会把不用的内存重放回空闲list。空闲内存会按照一定策略合并，以减少碎片。&lt;/p&gt;
&lt;h3 id=&#34;24-编译&#34;&gt;2.4 编译&lt;/h3&gt;
&lt;p&gt;编译涉及到两个问题：编译速度和依赖管理&lt;/p&gt;
&lt;p&gt;目前Golang具有两种编译器，一种是建立在GCC基础上的Gccgo，另外一种是分别针对64位x64和32位x86计算机的一套编译器(6g和8g)。&lt;/p&gt;
&lt;p&gt;依赖管理方面，由于golang绝大多数第三方开源库都在github上，在代码的import中加上对应的github路径就可以使用了，库会默认下载到工程的pkg目录下。&lt;/p&gt;
&lt;p&gt;另外，编译时会默认检查代码中所有实体的使用情况，凡是没使用到的package或变量，都会编译不通过。这是golang挺严谨的一面。&lt;/p&gt;
&lt;h3 id=&#34;25-网络编程&#34;&gt;2.5 网络编程&lt;/h3&gt;
&lt;p&gt;由于golang诞生在互联网时代，因此它天生具备了去中心化、分布式等特性，具体表现之一就是提供了丰富便捷的网络编程接口，比如socket用net.Dial(基于tcp/udp，封装了传统的connect、listen、accept等接口)、http用http.Get/Post()、rpc用client.Call(&#39;class_name.method_name&#39;, args, &amp;amp;reply)，等等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;高性能HTTP Server&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;26-函数多返回值&#34;&gt;2.6 函数多返回值&lt;/h3&gt;
&lt;p&gt;在C，C++中，包括其他的一些高级语言是不支持多个函数返回值的。但是这项功能又确实是需要的，所以在C语言中一般通过将返回值定义成一个结构体，或者通过函数的参数引用的形式进行返回。而在Go语言中，作为一种新型的语言，目标定位为强大的语言当然不能放弃对这一需求的满足，所以支持函数多返回值是必须的。&lt;/p&gt;
&lt;p&gt;函数定义时可以在入参后面再加(a,b,c)，表示将有3个返回值a、b、c。这个特性在很多语言都有，比如python。&lt;/p&gt;
&lt;p&gt;这个语法糖特性是有现实意义的，比如我们经常会要求接口返回一个三元组（errno,errmsg,data），在大多数只允许一个返回值的语言中，我们只能将三元组放入一个map或数组中返回，接收方还要写代码来检查返回值中包含了三元组，如果允许多返回值，则直接在函数定义层面上就做了强制，使代码更简洁安全。&lt;/p&gt;
&lt;h3 id=&#34;27-语言交互性&#34;&gt;2.7 语言交互性&lt;/h3&gt;
&lt;p&gt;语言交互性指的是本语言是否能和其他语言交互，比如可以调用其他语言编译的库。&lt;/p&gt;
&lt;p&gt;在Go语言中直接重用了大部份的C模块，这里称为Cgo.Cgo允许开发者混合编写C语言代码，然后Cgo工具可以将这些混合的C代码提取并生成对于C功能的调用包装代码。开发者基本上可以完全忽略这个Go语言和C语言的边界是如何跨越的。&lt;/p&gt;
&lt;p&gt;golang可以和C程序交互，但不能和C++交互。可以有两种替代方案：1）先将c++编译成动态库，再由go调用一段c代码，c代码通过dlfcn库动态调用动态库（记得export LD_LIBRARY_PATH）；2）使用swig(没玩过)&lt;/p&gt;
&lt;h3 id=&#34;28-异常处理&#34;&gt;2.8 异常处理&lt;/h3&gt;
&lt;p&gt;golang不支持try...catch这样的结构化的异常解决方式，因为觉得会增加代码量，且会被滥用，不管多小的异常都抛出。golang提倡的异常处理方式是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通异常：被调用方返回error对象，调用方判断error对象。&lt;/li&gt;
&lt;li&gt;严重异常：指的是中断性panic（比如除0），使用defer...recover...panic机制来捕获处理。严重异常一般由golang内部自动抛出，不需要用户主动抛出，避免传统try...catch写得到处都是的情况。当然，用户也可以使用panic(&#39;xxxx&#39;)主动抛出，只是这样就使这一套机制退化成结构化异常机制了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;29-其他一些有趣的特性&#34;&gt;2.9 其他一些有趣的特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型推导：类型定义：支持&lt;code&gt;var abc = 10&lt;/code&gt;这样的语法，让golang看上去有点像动态类型语言，但golang实际上时强类型的，前面的定义会被自动推导出是int类型。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作为强类型语言，隐式的类型转换是不被允许的，记住一条原则：让所有的东西都是显式的。&lt;/p&gt;
&lt;p&gt;简单来说，Go是一门写起来像动态语言，有着动态语言开发效率的静态语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个类型只要实现了某个interface的所有方法，即可实现该interface，无需显式去继承。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Go编程规范推荐每个Interface只提供一到两个的方法。这样使得每个接口的目的非常清晰。另外Go的隐式推导也使得我们组织程序架构的时候更加灵活。在写JAVA／C++程序的时候，我们一开始就需要把父类／子类／接口设计好，因为一旦后面有变更，修改起来会非常痛苦。而Go不一样，当你在实现的过程中发现某些方法可以抽象成接口的时候，你直接定义好这个接口就OK了，其他代码不需要做任何修改，编译器的自动推导会帮你做好一切。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能循环引用：即如果a.go中import了b，则b.go要是import a会报import cycle not allowed。好处是可以避免一些潜在的编程危险，比如a中的func1()调用了b中的func2()，如果func2()也能调用func1()，将会导致无限循环调用下去。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;defer机制：在Go语言中，提供关键字defer，可以通过该关键字指定需要延迟执行的逻辑体，即在函数体return前或出现panic时执行。这种机制非常适合善后逻辑处理，比如可以尽早避免可能出现的资源泄漏问题。&lt;/p&gt;
&lt;p&gt;可以说，defer是继goroutine和channel之后的另一个非常重要、实用的语言特性，对defer的引入，在很大程度上可以简化编程，并且在语言描述上显得更为自然，极大的增强了代码的可读性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“包”的概念：和python一样，把相同功能的代码放到一个目录，称之为包。包可以被其他包引用。main包是用来生成可执行文件，每个程序只有一个main包。包的主要用途是提高代码的可复用性。通过package可以引入其他包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编程规范：GO语言的编程规范强制集成在语言中，比如明确规定花括号摆放位置，强制要求一行一句，不允许导入没有使用的包，不允许定义没有使用的变量，提供gofmt工具强制格式化代码等等。奇怪的是，这些也引起了很多程序员的不满，有人发表GO语言的XX条罪状，里面就不乏对编程规范的指责。要知道，从工程管理的角度，任何一个开发团队都会对特定语言制定特定的编程规范，特别像Google这样的公司，更是如此。GO的设计者们认为，与其将规范写在文档里，还不如强制集成在语言里，这样更直接，更有利用团队协作和工程管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交叉编译：比如说你可以在运行 Linux 系统的计算机上开发运行 Windows 下运行的应用程序。这是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go 语言做到了真正的国际化！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三功能&#34;&gt;三、功能&lt;/h2&gt;
&lt;p&gt;此处我们说个小段子：(引自网上某篇文章，具体是哪一篇想不起来了)&lt;/p&gt;
&lt;p&gt;很久以前，有一个IT公司，这公司有个传统，允许员工拥有20%自由时间来开发实验性项目。在2007的某一天，公司的几个大牛，正在用c++开发一些比较繁琐但是核心的工作，主要包括庞大的分布式集群，大牛觉得很闹心，后来c++委员会来他们公司演讲，说c++将要添加大概35种新特性。这几个大牛的其中一个人，名为：Rob Pike，听后心中一万个xxx飘过，“c++特性还不够多吗？简化c++应该更有成就感吧”。于是乎，Rob Pike和其他几个大牛讨论了一下，怎么解决这个问题，过了一会，Rob Pike说要不我们自己搞个语言吧，名字叫“go”，非常简短，容易拼写。其他几位大牛就说好啊，然后他们找了块白板，在上面写下希望能有哪些功能。接下来的时间里，大牛们开心的讨论设计这门语言的特性，经过漫长的岁月，他们决定，以c语言为原型，以及借鉴其他语言的一些特性，来解放程序员，解放自己，然后在2009年，go语言诞生。&lt;/p&gt;
&lt;p&gt;以下就是这些大牛所罗列出的Go要有的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规范的语法（不需要符号表来解析）&lt;/li&gt;
&lt;li&gt;垃圾回收（独有）&lt;/li&gt;
&lt;li&gt;无头文件&lt;/li&gt;
&lt;li&gt;明确的依赖&lt;/li&gt;
&lt;li&gt;无循环依赖&lt;/li&gt;
&lt;li&gt;常量只能是数字&lt;/li&gt;
&lt;li&gt;int和int32是两种类型&lt;/li&gt;
&lt;li&gt;字母大小写设置可见性（letter case sets visibility）&lt;/li&gt;
&lt;li&gt;任何类型（type）都有方法（不是类型）&lt;/li&gt;
&lt;li&gt;没有子类型继承（不是子类）&lt;/li&gt;
&lt;li&gt;包级别初始化以及明确的初始化顺序&lt;/li&gt;
&lt;li&gt;文件被编译到一个包里&lt;/li&gt;
&lt;li&gt;包package-level globals presented in any order&lt;/li&gt;
&lt;li&gt;没有数值类型转换（常量起辅助作用）&lt;/li&gt;
&lt;li&gt;接口隐式实现（没有“implement”声明）&lt;/li&gt;
&lt;li&gt;嵌入（不会提升到超类）&lt;/li&gt;
&lt;li&gt;方法按照函数声明（没有特别的位置要求）&lt;/li&gt;
&lt;li&gt;方法即函数&lt;/li&gt;
&lt;li&gt;接口只有方法（没有数据）&lt;/li&gt;
&lt;li&gt;方法通过名字匹配（而非类型）&lt;/li&gt;
&lt;li&gt;没有构造函数和析构函数&lt;/li&gt;
&lt;li&gt;postincrement（如++i）是状态，不是表达式&lt;/li&gt;
&lt;li&gt;没有preincrement(i++)和predecrement&lt;/li&gt;
&lt;li&gt;赋值不是表达式&lt;/li&gt;
&lt;li&gt;明确赋值和函数调用中的计算顺序（没有“sequence point”）&lt;/li&gt;
&lt;li&gt;没有指针运算&lt;/li&gt;
&lt;li&gt;内存一直以零值初始化&lt;/li&gt;
&lt;li&gt;局部变量取值合法&lt;/li&gt;
&lt;li&gt;方法中没有“this”&lt;/li&gt;
&lt;li&gt;分段的堆栈&lt;/li&gt;
&lt;li&gt;没有静态和其它类型的注释&lt;/li&gt;
&lt;li&gt;没有模板&lt;/li&gt;
&lt;li&gt;内建string、slice和map&lt;/li&gt;
&lt;li&gt;数组边界检查&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;大牛真身&#34;&gt;大牛真身&lt;/h2&gt;
&lt;p&gt;最大牌的当属B和C语言设计者、Unix和Plan 9创始人、1983年图灵奖获得者Ken Thompson，这份名单中还包括了Unix核心成员Rob Pike（go语言之父）、java HotSpot虚拟机和js v8引擎的开发者Robert Griesemer、Memcached作者Brad Fitzpatrick，等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文图片来自网络，侵删&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934/&#34;&gt;https://www.bilibili.com/video/av56018934/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Go语言的前世今生</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC2%E8%8A%82_go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC2%E8%8A%82_go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;go语言的前世今生&#34;&gt;Go语言的前世今生&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/go_logo.jpg&#34; alt=&#34;go_logo&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;一-为什么需要一个新的语言&#34;&gt;一、 为什么需要一个新的语言&lt;/h2&gt;
&lt;p&gt;最近十年来，C/C++在计算领域没有很好得到发展，并没有新的系统编程语言出现。对开发程度和系统效率在很多情况下不能兼得。要么执行效率高，但低效的开发和编译，如C++；要么执行低效，但拥有有效的编译，如.NET、Java；所以需要一种拥有较高效的执行速度、编译速度和开发速度的编程语言，Go就横空出世了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;传统的语言比如c++，大家花费太多时间来学习如何使用这门语言，而不是如何更好的表达写作者的思想，同时编译花费的时间实在太长，对于编写-编译-运行这个链条来说周期太长。动态语言如Python，由于没有强类型的约束，很多问题需要在运行时发现，这种低级错误更应该交给编译器来发现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;人力成本越来越高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;机器越来越便宜&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;机器的性能越来越厉害&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在开发效率和运行速度上达到平衡&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;go出现之前，无论汇编语言、还是动态脚本语言，在执行效率和开发效率上都不能兼备。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;执行效率 execution speed：  C/C++    &amp;gt;  Java   &amp;gt;  PHP
开发效率 developing efficiency：  PHP   &amp;gt;  Java  &amp;gt;  C/C++&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;二-谷歌工程师的20时间&#34;&gt;二、 谷歌工程师的20%时间&lt;/h2&gt;
&lt;p&gt;谷歌的“20%时间”工作方式，允许工程师拿出20%的时间来研究自己喜欢的项目。语音服务Google Now、谷歌新闻Google News、谷歌地图Google Map上的交通信息等，全都是20%时间的产物。&lt;/p&gt;
&lt;p&gt;Go语言最开始也是20%时间的产物。&lt;/p&gt;
&lt;h2 id=&#34;三-创始人&#34;&gt;三、 创始人&lt;/h2&gt;
&lt;p&gt;Go的三个作者分别是： Rob Pike（罗伯.派克），Ken Thompson（肯.汤普森）和Robert Griesemer（罗伯特.格利茨默） 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Rob Pike：曾是贝尔实验室（Bell Labs）的Unix团队，和Plan 9操作系统计划的成员。他与Thompson共事多年，并共创出广泛使用的UTF-8 字元编码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ken Thompson：主要是B语言、C语言的作者、Unix之父。1983年图灵奖（Turing Award）和1998年美国国家技术奖（National Medal of Technology）得主。他与Dennis Ritchie是Unix的原创者。Thompson也发明了后来衍生出C语言的B程序语言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Robert Griesemer：在开发Go之前是Google V8、Chubby和HotSpot JVM的主要贡献者。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/aa.jpg&#34; alt=&#34;aa&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此外还有Plan 9开发者Russ Cox、和曾改善目前广泛使用之开原码编译器GCC的Ian Taylor。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;四-go的缔造与发展&#34;&gt;四、 Go的缔造与发展&lt;/h2&gt;
&lt;h3 id=&#34;41-go的命名&#34;&gt;4.1 Go的命名&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/mail1.jpg&#34; alt=&#34;mail1&#34;&gt;&lt;/p&gt;
&lt;p&gt;这是一封由 Rob Pike 在 2007 年 9 月 25 号，星期二，下午 3：12 回复给 Robert Griesemer、Ken Thompson 的有关编程语言讨论主题的邮件，邮件正文大意为：在开车回家的路上我得到了些灵感。1.给这门编程语言取名为“go”，它很简短，易书写。工具类可以命名为：goc、 gol、goa。交互式的调试工具也可以直接命名为“go”。语言文件后缀名为 .go 等等&lt;/p&gt;
&lt;p&gt;这就是 Go 语言名字的来源，自此之后 Robert、Rob 和 Ken 三个人开始在 Google 内部进行了研发，一直到了 2009 年，Go 正式开源了，Go 项目团队将 2009 年 11 月 10 日，即该语言正式对外开源的日字作为其官方生日。源代码最初托管在 &lt;a href=&#34;http://link.zhihu.com/?target=http%3A//code.google.com&#34;&gt;http://code.google.com&lt;/a&gt; 上，之后几年才逐步的迁移到 GitHub 上。&lt;/p&gt;
&lt;h3 id=&#34;42-go的发展过程中的记事&#34;&gt;4.2 Go的发展过程中的记事&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第一个事情是在开发设计 Go 语言过程中的第一个重大惊喜是收到了以下这封邮件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/mail2.jpg&#34; alt=&#34;mail2&#34;&gt;&lt;/p&gt;
&lt;p&gt;这是一封由 Ian Lance Taylor 在 2008 年 6月 7 日（星期六）的晚上 7：06 写给 Robert Griesemer、Rob Pike、 Ken Thompson 的关于 Go gcc 编译器前端的邮件。邮件正文大意如下：我的同事向我推荐了这个网站 http://…/go_lang.html 。这似乎是一门很有趣的编程语言。我为它写了一个 gcc 编译器前端。虽然这个工具仍缺少很多的功能，但它确实可以编译网站上展示的那个素数筛选程序了。&lt;/p&gt;
&lt;p&gt;Ian Lance Taylor 的加入以及第二个编译器 (gcc go) 的实现 在带来震惊的同时，也伴随着喜悦。这对 Go 项目来说不仅仅是鼓励，更是一种对可行性的证明。语言的第二次实现对制定语言规范和确定标准库的过程至关重要，同时也有助于保证其高可移植性，这也是 Go 语言承诺的一部分。自此之后 Ian Lance Taylor 成为了设计和实现 Go 语言及其工具的核心人物。&lt;/p&gt;
&lt;p&gt;**第二件事情是 Russ Cox 在2008年带着他的语言设计天赋和编程技巧加入了刚成立不久的 Go 团队。**Russ 发现 Go 方法的通用性意味着函数也能拥有自己的方法，这直接促成了 &lt;strong&gt;http.HandlerFunc&lt;/strong&gt; 的实现，这是一个让 Go 一下子变得无限可能的特性。Russ 还提出了更多的泛化性的想法，比如 io.Reader 和 io.Writer 接口，奠定了所有 I/O 库的整体结构。&lt;/p&gt;
&lt;p&gt;**第三件事情是聘请了安全专家 Adam Langley 帮助 Go 走向 Google 外面的世界。**Adam 为 Go 团队做了许多不为外人知晓的工作，包括创建最初的 &lt;strong&gt;&lt;a href=&#34;http://golang.org&#34;&gt;http://golang.org&lt;/a&gt;&lt;/strong&gt; 网站以及 &lt;strong&gt;build dashboard&lt;/strong&gt;。不过他最大的贡献当属创建了 cryptographic 库。起先，在我们中的部分人看来，这个库无论在规模还是复杂度上都不成气候。但是就是这个库在后期成为了很多重要的网络和安全软件的基础，并且成为了 Go 语言开发历史的关键组成部分。许多网络基础设施公司，比如 &lt;strong&gt;Cloudflare&lt;/strong&gt;，均重度依赖 Adam 在 Go 项目上的工作，互联网也因它变得更好。我记得当初 beego 设计的时候，session 模块设计的时候也得到了 Adam 的很多建议，因此，就 Go 而言，我们由衷地感谢 Adam。&lt;/p&gt;
&lt;p&gt;**第四个事情就是一家叫做 Docker 的公司。**就是使用 Go 进行项目开发，并促进了计算机领域的容器行业，进而出现了像 Kubernetes 这样的项目。现在，我们完全可以说 Go 是容器语言，这是另一个完全出乎意料的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/1641730da1fe6861.jpg&#34; alt=&#34;1641730da1fe6861&#34;&gt;&lt;/p&gt;
&lt;p&gt;除了大名鼎鼎的Docker，完全用GO实现。业界最为火爆的容器编排管理系统kubernetes完全用GO实现。之后的Docker Swarm，完全用GO实现。除此之外，还有各种有名的项目，如etcd/consul/flannel，七牛云存储等等
均使用GO实现。有人说，GO语言之所以出名，是赶上了云时代。但为什么不能换种说法？也是GO语言促使了云的发展。&lt;/p&gt;
&lt;p&gt;除了云项目外，还有像今日头条、UBER这样的公司，他们也使用GO语言对自己的业务进行了彻底的重构。&lt;/p&gt;
&lt;h2 id=&#34;五最后&#34;&gt;五、最后&lt;/h2&gt;
&lt;p&gt;Go语言是谷歌2009年发布的第二款开源编程语言（系统开发语言)，它是基于编译、垃圾收集和并发的编程语言。
Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美 C / C++代码的速度，而且更加安全、支持并行进程。作为出现在21世纪的语言，其近C的执行性能和近解析型语言的开发效率，以及近乎于完美的编译速度，已经风靡全球。特别是在云项目中，大部分都使用了Golang来开发。不得不说，Golang早已深入人心。而对于一个没有历史负担的新项目，Golang或许就是个不二的选择。
很多人将Go语言称为21世纪的C语言，因为Go不仅拥有C的简洁和性能。而且还很好的提供了21世纪互联网环境下服务端开发的各种实用特性。被称为Go语言之父的罗勃·派克(Rob Pike)就曾说过，你是否同意Go语言，取决于你是认可少就是多，还是少就是少(Less is more or less is less)。Go语言的整个设计哲学就是：将简单、实用体现得淋漓尽致。
如今 Go 已经是云计算编程语言，GO语言背靠Google这棵大树，又不乏牛人坐镇，是名副其实的“牛二代”。想象一下：一个只有十几年发展经历的编程语言，已经成为了如此巨大而且正在不断发展的行业的主导者，这种成功是每个人都无法想象的。&lt;/p&gt;
&lt;p&gt;本文所有图片来自网络，侵删&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;对应视频地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934/&#34;&gt;https://www.bilibili.com/video/av56018934/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Go语言和其他语言的对比</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC5%E8%8A%82_go%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AF%B9%E6%AF%94/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC5%E8%8A%82_go%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AF%B9%E6%AF%94/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;go语言和其他语言的对比&#34;&gt;Go语言和其他语言的对比&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一go语言设计初衷&#34;&gt;一、Go语言设计初衷&lt;/h2&gt;
&lt;p&gt;1、设计Go语言是为了解决当时Google开发遇到的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大量的C++代码，同时又引入了Java和Python&lt;/li&gt;
&lt;li&gt;成千上万的工程师&lt;/li&gt;
&lt;li&gt;数以万计行的代码&lt;/li&gt;
&lt;li&gt;分布式的编译系统&lt;/li&gt;
&lt;li&gt;数百万的服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、Google开发中的痛点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译慢&lt;/li&gt;
&lt;li&gt;失控的依赖&lt;/li&gt;
&lt;li&gt;每个工程师只是用了一个语言里面的一部分&lt;/li&gt;
&lt;li&gt;程序难以维护（可读性差、文档不清晰等）&lt;/li&gt;
&lt;li&gt;更新的花费越来越长&lt;/li&gt;
&lt;li&gt;交叉编译困难&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、如何解决当前的问题和痛点？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Go希望成为互联网时代的C语言。多数系统级语言（包括Java和C#）的根本编程哲学来源于C++，将C++的面向对象进一步发扬光大。但是Go语言的设计者却有不同的看法，他们认为值得学习的是C语言。C语言经久不衰的根源是它足够简单。因此，Go语言也是足够简单。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以，他们当时设计Go的目标是为了消除各种缓慢和笨重、改进各种低效和扩展性。Go是由那些开发大型系统的人设计的，同时也是为了这些人服务的；它是为了解决工程上的问题，不是为了研究语言设计；它还是为了让我们的编程变得更舒适和方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是结合Google当时内部的一些现实情况，如很多工程师都是C系的，所以新设计的语言一定要易学习，最好是类似C的语言；20年没有出新的语言了，所以新设计的语言必须是现代化的（例如内置GC）等情况。最后根据实战经验，他们向着目标设计了Go这个语言。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4、Go语言的特色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有继承多态的面向对象&lt;/li&gt;
&lt;li&gt;强一致类型&lt;/li&gt;
&lt;li&gt;interface不需要显式声明(Duck Typing)&lt;/li&gt;
&lt;li&gt;没有异常处理(Error is value)&lt;/li&gt;
&lt;li&gt;基于首字母的可访问特性&lt;/li&gt;
&lt;li&gt;不用的import或者变量引起编译错误&lt;/li&gt;
&lt;li&gt;完整而卓越的标准库包&lt;/li&gt;
&lt;li&gt;Go内置runtime（作用是性能监控、垃圾回收等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二go语言的优势&#34;&gt;二、Go语言的优势&lt;/h2&gt;
&lt;p&gt;1、学习曲线容易&lt;/p&gt;
&lt;p&gt;​    Go语言语法简单，包含了类C语法。因为Go语言容易学习，所以一个普通的大学生花几个星期就能写出来可以上手的、高性能的应用。在国内大家都追求快，这也是为什么国内Go流行的原因之一。&lt;/p&gt;
&lt;p&gt;​    &lt;img src=&#34;http://www.songx.fun/img/png/go2.png&#34; alt=&#34;go2&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Go 语言的语法特性简直是太简单了，简单到你几乎玩不出什么花招，直来直去的，学习曲线很低，上手非常快。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、效率：快速的编译时间，开发效率和运行效率高&lt;/p&gt;
&lt;p&gt;​    开发过程中相较于 Java 和 C++呆滞的编译速度，Go 的快速编译时间是一个主要的效率优势。Go拥有接近C的运行效率和接近PHP的开发效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/golang2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/go3.png&#34; alt=&#34;go3&#34;&gt;&lt;/p&gt;
&lt;p&gt;3、出身名门、血统纯正&lt;/p&gt;
&lt;p&gt;​    之所以说Go出身名门，从Go语言的创造者就可见端倪，Go语言绝对血统纯正。其次Go语言出自Google公司，Google在业界的知名度和实力自然不用多说。Google公司聚集了一批牛人，在各种编程语言称雄争霸的局面下推出新的编程语言，自然有它的战略考虑。而且从Go语言的发展态势来看，Google对它这个新的宠儿还是很看重的，Go自然有一个良好的发展前途。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/qinerzi_meitu_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;4、自由高效：组合的思想、无侵入式的接口&lt;/p&gt;
&lt;p&gt;​    Go语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go语言支持当前所有的编程范式，包括过程式编程、面向对象编程、面向接口编程、函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;5、强大的标准库&lt;/p&gt;
&lt;p&gt;​    这包括互联网应用、系统编程和网络编程。Go里面的标准库基本上已经是非常稳定了，特别是我这里提到的三个，网络层、系统层的库非常实用。**Go 语言的 lib 库麻雀虽小五脏俱全。**Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。&lt;/p&gt;
&lt;p&gt;6、部署方便：二进制文件，Copy部署&lt;/p&gt;
&lt;p&gt;​    这一点是很多人选择Go的最大理由，因为部署太方便了，所以现在也有很多人用Go开发运维程序。&lt;/p&gt;
&lt;p&gt;7、简单的并发&lt;/p&gt;
&lt;p&gt;**并行和异步编程几乎无痛点。**Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的编程者来说，完全就是让人眼前一亮的感觉。Go 是一种非常高效的语言，高度支持并发性。Go是为大数据、微服务、并发而生的一种编程语言。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Go 作为一门语言致力于使事情简单化。它并未引入很多新概念，而是聚焦于打造一门简单的语言，它使用起来异常快速并且简单。其唯一的创新之处是 goroutines 和通道。Goroutines 是 Go 面向线程的轻量级方法，而通道是 goroutines 之间通信的优先方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 Goroutines 的成本很低，只需几千个字节的额外内存，正由于此，才使得同时运行数百个甚至数千个 goroutines 成为可能。可以借助通道实现 goroutines 之间的通信。Goroutines 以及基于通道的并发性方法使其非常容易使用所有可用的 CPU 内核，并处理并发的 IO。相较于 Python/Java，在一个 goroutine 上运行一个函数需要最小的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/golang1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;8、稳定性&lt;/p&gt;
&lt;p&gt;​    Go拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么Go相比于其他程序会更稳定呢？这是因为Go提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如go tool、gofmt、go test。&lt;/p&gt;
&lt;h2 id=&#34;三对比其他语言&#34;&gt;三、对比其他语言&lt;/h2&gt;
&lt;p&gt;Go的很多语言特性借鉴与它的三个祖先：C，Pascal和CSP。Go的语法、数据类型、控制流等继承于C，Go的包、面对对象等思想来源于Pascal分支，而Go最大的语言特色，基于管道通信的协程并发模型，则借鉴于CSP分支。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/go1.jpeg&#34; alt=&#34;go1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;java&#34;&gt;Java&lt;/h3&gt;
&lt;p&gt;编译语言，速度适中（2.67s），目前的大型网站都是拿java写的，比如淘宝、京东等。主要特点是稳定，开源性好，具有自己的一套编写规范，开发效率适中，目前最主流的语言。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作为编程语言中的大腕。具有最大的知名度和用户群。无论风起云涌，我自巍然不动。他强任他强，清风拂山岗；他横由他横，明月照大江。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;c&#34;&gt;c#&lt;/h3&gt;
&lt;p&gt;执行速度快（4.28），学习难度适中，开发速度适中。但是由于c#存在很多缺点，京东、携程等大型网站前身都是用c#开发的，但是现在都迁移到了java上。&lt;/p&gt;
&lt;h3 id=&#34;cc&#34;&gt;C/C++&lt;/h3&gt;
&lt;p&gt;现存编程语言中的老祖，其他语言皆由此而生。执行速度最快无人能及。但是写起来最为复杂，开发难度大。&lt;/p&gt;
&lt;h3 id=&#34;javascript&#34;&gt;Javascript&lt;/h3&gt;
&lt;p&gt;编程语言中特立独行的傲娇美女。前端处理能力是其它语言无法比拟。发展中的js后端处理能力也是卓越不凡。前后端通吃，舍我其谁？&lt;/p&gt;
&lt;h3 id=&#34;python&#34;&gt;Python&lt;/h3&gt;
&lt;p&gt;脚本语言，速度最慢（258s），代码简洁、学习进度短，开发速度快。豆瓣就是拿python写的。Python著名的服务器框架有django，flask。但是python在大型项目上不太稳定，因此有些用python的企业后来迁移到了java上。&lt;/p&gt;
&lt;h3 id=&#34;scala&#34;&gt;scala&lt;/h3&gt;
&lt;p&gt;编译语言，比python快十倍，和java差不多，但是学习进度慢，而且在实际编程中，如果对语言不够精通，很容易造成性能严重下降。，后来比如Yammer就从scala迁移到了java上。微服务框架有lagom等。&lt;/p&gt;
&lt;h3 id=&#34;go&#34;&gt;Go&lt;/h3&gt;
&lt;p&gt;编程界的小鲜肉。高并发能力无人能及。即具有像Python一样的简洁代码、开发速度，又具有C语言一样的执行效率，优势突出。&lt;/p&gt;
&lt;h2 id=&#34;四最后&#34;&gt;四、最后&lt;/h2&gt;
&lt;p&gt;因为Go的语法和Erlang、Python类似，所以我们将这三门语言做个详细的对比。&lt;/p&gt;
&lt;p&gt;相比于Python的40个特性，Go只有31个，可以说Go在语言设计上是相当克制的。比如，它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。&lt;/p&gt;
&lt;p&gt;但是Go的特点也很鲜明，比如，它拥有协程、自动垃圾回收、包管理系统、一等公民的函数、栈空间管理等。&lt;/p&gt;
&lt;p&gt;Go作为静态类型语言，保证了Go在运行效率、内存用量、类型安全都要强于Python和Erlang。&lt;/p&gt;
&lt;p&gt;Go的数据类型也更加丰富，除了支持表、字典等复杂的数据结构，还支持指针和接口类型，这是Python和Erlang所没有的。特别是接口类型特别强大，它提供了管理类型系统的手段。而指针类型提供了管理内存的手段，这让Go进入底层软件开发提供了强有力的支持。&lt;/p&gt;
&lt;p&gt;Go在面对对象的特性支持上做了很多反思和取舍，它没有类、虚函数、继承、泛型等特性。Go语言中面向对象编程的核心是组合和方法(function)。组合很类似于C语言的struct结构体的组合方式，方法类似于Java的接口(Interface)，但是使用方法上与对象更加解耦，减少了对对象内部的侵入。Erlang则不支持面对对象编程范式，相比而言，Python对面对对象范式的支持最为全面。&lt;/p&gt;
&lt;p&gt;在函数式编程的特性支持上，Erlang作为函数式语言，支持最为全面。但是基本的函数式语言特性，如lambda、高阶函数、curry等，三种语言都支持。&lt;/p&gt;
&lt;p&gt;控制流的特性支持上，三种语言都差不多。Erlang支持尾递归优化，这给它在函数式编程上带来便利。而Go在通过动态扩展协程栈的方式来支持深度递归调用。Python则在深度递归调用上经常被爆栈。&lt;/p&gt;
&lt;p&gt;Go和Erlang的并发模型都来源于CSP，但是Erlang是基于actor和消息传递（mailbox）的并发实现，Go是基于goroutine和管道（channel）的并发实现。不管Erlang的actor还是Go的goroutine，都满足协程的特点：由编程语言实现和调度，切换在用户态完成，创建销毁开销很小。至于Python，其多线程的切换和调度是基于操作系统实现，而且因为GIL的大坑级存在，无法真正做到并行。&lt;/p&gt;
&lt;p&gt;而且从笔者的并发编程体验上看，Erlang的函数式编程语法风格和其OTP behavior框架提供的晦涩的回调（callback）使用方法，对大部分的程序员，如C/C++和Java出身的程序员来说，有一定的入门门槛和挑战。而被称为“互联网时代的C”的Go，其类C的语法和控制流，以及面对对象的编程范式，编程体验则好很多。&lt;/p&gt;
&lt;p&gt;本文图片来自网络，侵删&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934/&#34;&gt;https://www.bilibili.com/video/av56018934/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Go语言环境搭建</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC7%E8%8A%82_go%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC7%E8%8A%82_go%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;go语言环境搭建&#34;&gt;Go语言环境搭建&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一golang语言的官网&#34;&gt;一、Golang语言的官网&lt;/h2&gt;
&lt;p&gt;首先我们登录Golang的官方网站：https://golang.org/&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/guanwang2.png&#34; alt=&#34;guanwang2&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为Google和中国的关系，直接登录Golang的官网，需要翻墙。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然你也可以登录Golang的国内网站：&lt;a href=&#34;https://golang.google.cn/&#34;&gt;https://golang.google.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/guanwang1.png&#34; alt=&#34;WX20190403-095602&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;二下载&#34;&gt;二、下载&lt;/h2&gt;
&lt;p&gt;在Mac、Windows和Linux三个平台上都支持Golang。您可以从&lt;a href=&#34;https://golang.org/dl/&#34;&gt;https://golang.org/dl/&lt;/a&gt;下载相应平台的安装包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/xiazai1.png&#34; alt=&#34;xiazai1&#34;&gt;&lt;/p&gt;
&lt;p&gt;该网站在国内不容易访问，所以可以访问中国对应的&lt;a href=&#34;https://golang.google.cn/dl/&#34;&gt;https://golang.google.cn/dl/&lt;/a&gt;或者是Go语言中文网&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.studygolang.com/dl&#34;&gt;https://www.studygolang.com/dl&lt;/a&gt; 进行安装软件的下载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/xiazai2.png&#34; alt=&#34;xiazai2&#34;&gt;&lt;/p&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/xiazai3.png&#34; alt=&#34;xiazai3&#34;&gt;&lt;/p&gt;
&lt;p&gt;目前最新的版本，是今年2月份发布的Go1.12。&lt;/p&gt;
&lt;p&gt;Mac OS
从https://golang.org/dl/下载osx安装程序。双击启动安装。按照提示，这应该在/usr/local/go中安装了Golang，并且还会将文件夹/usr/local/go/bin添加到您的PATH环境变量中。&lt;/p&gt;
&lt;p&gt;Windows
从https://golang.org/dl/下载MSI安装程序。双击启动安装并遵循提示。这将在位置c中安装Golang:\Go，并且还将添加目录c:\Go\bin到您的path环境变量。&lt;/p&gt;
&lt;p&gt;Linux
从https://golang.org/dl/下载tar文件，并将其解压到/usr/local。将/usr/local/go/bin添加到PATH环境变量中。这应该安装在linux中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;开发工具包又分为安装版和压缩版。安装版是Mac和Windows特有的，他们的名字类似于：

- go1.12.1.darwin-amd64.pkg
- go1.12.1.windows-386.msi
- go1.12.1.windows-amd64.msi

安装版，顾名思义，双击打开会出现安装向导，让你选择安装的路径，帮你设置好环境比安康等信息，比较省事方便一些。

压缩版的就是一个压缩文件，可以解压得到里面的内容，他们的名字类似于：

- go1.12.1.darwin-amd64.tar.gz
- go1.12.1.linux-386.tar.gz
- go1.12.1.linux-amd64.tar.gz
- go1.12.1.windows-386.zip
- go1.12.1.windows-amd64.zip

压缩版我们下载后需要解压，然后自己移动到要存放的路径下，并且配置环境变量等信息，相比安装版来说，比较复杂一些，手动配置的比较多。

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;三安装和配置环境变量&#34;&gt;三、安装和配置环境变量&lt;/h2&gt;
&lt;h3 id=&#34;31-linux系统安装和配置&#34;&gt;3.1 Linux系统安装和配置&lt;/h3&gt;
&lt;p&gt;Linux系统，我们以Ubuntu为例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：下载安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到go的官网上下载go的安装包，自动下载到了下载目录。&lt;/p&gt;
&lt;p&gt;打开终端，进入到下载目录，查看安装包：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ruby@hanru:~$ cd 下载
ruby@hanru:~/下载$ ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/ubuntu1.png&#34; alt=&#34;ubuntu1&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后我们需要将压缩包解压，并拷贝到指定的目录下，所以在终端继续执行以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ruby@ubuntu:~/下载$ sudo tar -xzf go1.12.1.linux-amd64.tar.gz -C /usr/local
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/ubuntu2.png&#34; alt=&#34;ubuntu2&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入sudo，表示使用管理员身份执行命令，需要输入密码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时，就将从go官网https://golang.org/dl/上下载tar文件，解压到/usr/local目录下，该目录下会有一个go文件夹。&lt;/p&gt;
&lt;p&gt;可以进入这个文件夹直接查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/ubuntu3.png&#34; alt=&#34;ubuntu3&#34;&gt;&lt;/p&gt;
&lt;p&gt;也可以通过终端命令进行查看，输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ruby@hanru:~/下载$ cd /usr/local
ruby@hanru:/usr/local$ ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/ubuntu4.png&#34; alt=&#34;ubuntu4&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：配置环境变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一：需要先安装vim。&lt;/p&gt;
&lt;p&gt;直接在终端执行以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ruby@ubuntu:~$ sudo apt-get install vim
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二：编辑$HOME/.profile文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A：先配置GOROOT，就是go的安装目录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export GOROOT=&amp;quot;/usr/local/go&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;B：然后配置GOPATH&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Gopath就是Go项目代码存放的位置。这个是我们自己定义的目录。就好比是其他IDE的Workspace。&lt;/p&gt;
&lt;p&gt;​	对于Ubuntu系统，默认使用Home/go目录作为gopath。&lt;/p&gt;
&lt;p&gt;​		该目录下有3个子目录：src，pkg，bin&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GO代码必须在工作空间内。工作空间是一个目录，其中包含三个子目录：&lt;/p&gt;
&lt;p&gt;​	src ---- 里面每一个子目录，就是一个包。包内是Go的源码文件&lt;/p&gt;
&lt;p&gt;​	pkg ---- 编译后生成的，包的目标文件&lt;/p&gt;
&lt;p&gt;​	bin ---- 生成的可执行文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export GOPATH=$HOME/go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;C：GOBIN&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export GOBIN=$GOROOT/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;D：添加到PATH中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们需要将GOBIN添加到环境变量PATH中。可以通过vi直接将下面内容添加到$HOME/.profile中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export PATH=$PATH:$GOBIN
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，你也可以将GO的bin目录直接配置到PATH中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export PATH=$GOROOT/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相当于将上面的C和D步骤，写在一起&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先使用ls -a命令，查看home目录下是否有.profile文件。(以.开头的文件都是隐藏文件，使用-a命令查看)&lt;/li&gt;
&lt;li&gt;直接在终端中输入：vi $HOME/.profile&lt;/li&gt;
&lt;li&gt;输入i，切片到编辑模式，将以上内容复制到文件中，并保存退出。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;​	点击esc键后，&lt;/p&gt;
&lt;p&gt;​	:q!，强制退出不保存&lt;/p&gt;
&lt;p&gt;​	:wq，保存并退出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;三：让配置文件立刻生效&lt;/p&gt;
&lt;p&gt;使用source命令让配置文件生效&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ruby@ubuntu:~$ source $HOME/.profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;四：测试安装&lt;/p&gt;
&lt;p&gt;版本检测&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ruby@ubuntu:~$ go version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;检查go的配置信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ruby@ubuntu:~$ go env
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;额外扩展：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vi命令后文件的保存

Linux中vi的英文全称为Visual Interface。

末行模式下执行以下操作。[命令模式下按下:就切换到末行模式下]
w
保存文件不退出vi

w file
文件另存到file中，不退出vi

w!
强制保存，不退出vi

wq
保持文件并退出

wq!
强制保存文件并退出

q
不保存文件退出vi

q!
不保存文件强制退出vi

e!
放弃所有修改，从上次保持的文件处在编辑
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32-mac系统安装并配置&#34;&gt;3.2 mac系统安装并配置&lt;/h3&gt;
&lt;p&gt;Mac分为压缩版和安装版，他们都是64位的。压缩版和Linux的大同小异，因为Mac和Linux都是基于Unix，终端这一块基本上是相同的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A：安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找到下载后的pkg安装包：一般情况下，下载后的文件都在下载目录下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/anzhuang1.png&#34; alt=&#34;anzhuang1&#34;&gt;&lt;/p&gt;
&lt;p&gt;双击pkg包，顺着指引，即可安装成功。&lt;/p&gt;
&lt;p&gt;在命令行输入 go version，获取到go的版本号，则代表安装成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置环境变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、打开终端输入cd ~进入用户主目录;
2、输入ls -all命令查看是否存在.bash_profile;
3、存在既使用vim .bash_profile 打开文件;
4、输入 i 进入vim编辑模式；
5、输入下面代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export GOROOT=/usr/local/go
export GOPATH=/Users/ruby/go
export GOBIN=$GOROOT/bin
export PATH=$PATH:$GOBIN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 GOPATH: 日常开发的根目录。GOBIN:是GOPATH下的bin目录。&lt;/p&gt;
&lt;p&gt;6、点击ESC，并输入 :wq 保存并退出编辑。可输入vim .bash_profile 查看是否保存成功。&lt;/p&gt;
&lt;p&gt;7、输入source ~/.bash_profile 完成对golang环境变量的配置，配置成功没有提示。
8、输入go env 查看配置结果。&lt;/p&gt;
&lt;h3 id=&#34;33-windows&#34;&gt;3.3 Windows&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;A、安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装步骤就不在多说什么了，一路下一步到底&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B、配置环境变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：如果是msi安装文件，Go语言的环境变量会自动设置好。&lt;/p&gt;
&lt;p&gt;我的电脑——右键“属性”——“高级系统设置”——“环境变量”——“系统变量”&lt;/p&gt;
&lt;p&gt;​	假设GO安装于C盘根目录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新建：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GOROOT：Go安装路径（例：C:\Go）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GOPATH：Go工程的路径（例：E:\go）。如果有多个，就以分号分隔添加&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/winhuanjing1.jpg&#34; alt=&#34;winhuanjing1&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;修改：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Path：在path中增加：C:\Go\bin;%GOPATH%\bin;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要把GOPATH中的可执行目录也配置到环境变量中, 否则你自行下载的第三方go工具就无法使用了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/winhuanjing2.jpg&#34; alt=&#34;winhuanjing2&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;工作目录就是我们用来存放开发的源代码的地方，对应的也是Go里的GOPATH这个环境变量。这个环境变量指定之后，我们编译源代码等生成的文件都会放到这个目录下，GOPATH环境变量的配置参考上面的安装Go，配置到Windows下的系统变量里。&lt;/li&gt;
&lt;li&gt;GOPATH之下主要包含三个目录: bin、pkg、src。bin目录主要存放可执行文件; pkg目录存放编译好的库文件, 主要是*.a文件; src目录下主要存放go的源文件&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;C、查看是否安装配置成功&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用快捷键win+R键，输入cmd，打开命令行提示符，在命令行中输入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go env  # 查看得到go的配置信息
go version  # 查看go的版本号
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Go语言能做什么</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC6%E8%8A%82_go%E8%AF%AD%E8%A8%80%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC6%E8%8A%82_go%E8%AF%AD%E8%A8%80%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;go语言能做什么&#34;&gt;Go语言能做什么&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一我们为什么选择go语言&#34;&gt;一、我们为什么选择Go语言&lt;/h2&gt;
&lt;p&gt;选择Go语言的原因可能会有很多，关于Go语言的特性、优势等，我们在之前的文档中也已经介绍了很多了。但是最主要的原因，应该是基于以下两方面的考虑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;执行性能&lt;/p&gt;
&lt;p&gt;缩短API的响应时长，解决批量请求访问超时的问题。在Uwork的业务场景下，一次API批量请求，往往会涉及对另外接口服务的多次调用，而在之前的PHP实现模式下，要做到并行调用是非常困难的，串行处理却不能从根本上提高处理性能。而GO语言不一样，通过协程可以方便的实现API的并行处理，达到处理效率的最大化。 依赖Golang的高性能HTTP Server，提升系统吞吐能力，由PHP的数百级别提升到数千里甚至过万级别。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发效率&lt;/p&gt;
&lt;p&gt;GO语言使用起来简单、代码描述效率高、编码规范统一、上手快。 通过少量的代码，即可实现框架的标准化，并以统一的规范快速构建API业务逻辑。 能快速的构建各种通用组件和公共类库，进一步提升开发效率，实现特定场景下的功能量产。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二go语言能做什么&#34;&gt;二、Go语言能做什么&lt;/h2&gt;
&lt;p&gt;Go 语言从发布 1.0 版本以来备受众多开发者关注并得到广泛使用，Go 语言的简单、高效、并发特性吸引了众多传统语言开发者的加入，而且人数越来越多。&lt;/p&gt;
&lt;p&gt;鉴于Go语言的特点和设计的初衷，Go语言作为服务器编程语言，很适合处理日志、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等；网络编程方面，Go语言广泛应用于Web 应用、API应用、下载应用等；除此之外，Go语言还适用于内存数据库和云平台领域，目前国外很多云平台都是采用Go开发。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器编程，以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。&lt;/li&gt;
&lt;li&gt;分布式系统、数据库代理器、中间件等，例如Etcd。&lt;/li&gt;
&lt;li&gt;网络编程，这一块目前应用最广，包括Web应用、API应用、下载应用，而且Go内置的net/http包基本上把我们平常用到的网络功能都实现了。&lt;/li&gt;
&lt;li&gt;数据库操作&lt;/li&gt;
&lt;li&gt;开发云平台，目前国外很多云平台在采用Go开发&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三国内外有哪些企业或项目使用go语言&#34;&gt;三、国内外有哪些企业或项目使用Go语言&lt;/h2&gt;
&lt;p&gt;Go发布之后，很多公司特别是云计算公司开始用Go重构他们的基础架构，很多都是直接采用Go进行了开发，最近热火朝天的Docker就是采用Go开发的。&lt;/p&gt;
&lt;p&gt;使用 Go 语言开发的开源项目非常多。早期的 Go 语言开源项目只是通过 Go 语言与传统项目进行C语言库绑定实现，例如 Qt、Sqlite 等；后期的很多项目都使用 Go 语言进行重新原生实现，这个过程相对于其他语言要简单一些，这也促成了大量使用 Go 语言原生开发项目的出现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;云计算基础设施领域&lt;/p&gt;
&lt;p&gt;代表项目：docker、kubernetes、etcd、&lt;a href=&#34;http://tonybai.com/2015/07/06/implement-distributed-services-registery-and-discovery-by-consul/&#34;&gt;consul&lt;/a&gt;、cloudflare CDN、七牛云存储等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基础软件&lt;/p&gt;
&lt;p&gt;代表项目：&lt;a href=&#34;https://github.com/pingcap/tidb&#34;&gt;tidb&lt;/a&gt;、&lt;a href=&#34;https://github.com/influxdata/influxdb&#34;&gt;influxdb&lt;/a&gt;、&lt;a href=&#34;https://github.com/cockroachdb/cockroach&#34;&gt;cockroachdb&lt;/a&gt;等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微服务&lt;/p&gt;
&lt;p&gt;代表项目：&lt;a href=&#34;https://github.com/go-kit/kit&#34;&gt;go-kit&lt;/a&gt;、&lt;a href=&#34;https://github.com/micro/micro&#34;&gt;micro&lt;/a&gt;、monzo bank的&lt;a href=&#34;https://github.com/monzo&#34;&gt;typhon&lt;/a&gt;、&lt;a href=&#34;https://www.bilibili.com/&#34;&gt;bilibili&lt;/a&gt;等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;互联网基础设施&lt;/p&gt;
&lt;p&gt;代表项目：&lt;a href=&#34;https://github.com/ethereum/go-ethereum&#34;&gt;以太坊&lt;/a&gt;、&lt;a href=&#34;https://github.com/hyperledger&#34;&gt;hyperledger&lt;/a&gt;等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;采用Go的一些国外公司，如Google、Docker、Apple、Cloud Foundry、CloudFlare、Couchbase、CoreOS、Dropbox、MongoDB、AWS等公司；&lt;/p&gt;
&lt;p&gt;采用Go开发的国内企业：如阿里云CDN、百度、小米、七牛、PingCAP、华为、金山软件、猎豹移动、饿了么等公司。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;docker&#34;&gt;Docker&lt;/h3&gt;
&lt;p&gt;Docker 是一种操作系统层面的虚拟化技术，可以在操作系统和应用程序之间进行隔离，也可以称之为容器。Docker 可以在一台物理服务器上快速运行一个或多个实例。基于lxc的一个虚拟打包工具，能够实现PAAS平台的组建。例如，启动一个 CentOS 操作系统，并在其内部命令行执行指令后结束，整个过程就像自己在操作系统一样高效。&lt;/p&gt;
&lt;p&gt;项目链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/docker/docker&#34;&gt;https://github.com/docker/docker&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;go语言&#34;&gt;go语言&lt;/h3&gt;
&lt;p&gt;Go 语言自己的早期源码使用C语言和汇编语言写成。从 Go 1.5 版本后，完全使用 Go 语言自身进行编写。Go 语言的源码对了解 Go 语言的底层调度有极大的参考意义，建议希望对 Go 语言有深入了解的读者读一读。&lt;/p&gt;
&lt;p&gt;项目链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go&#34;&gt;https://github.com/golang/go&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;kubernetes&#34;&gt;Kubernetes&lt;/h3&gt;
&lt;p&gt;Google 公司开发的构建于 Docker 之上的容器调度服务，用户可以通过 Kubernetes 集群进行云端容器集群管理。&lt;/p&gt;
&lt;p&gt;项目链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes&#34;&gt;https://github.com/kubernetes/kubernetes&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;etcd&#34;&gt;etcd&lt;/h3&gt;
&lt;p&gt;一款分布式、可靠的 KV 存储系统，可以快速进行云配置。&lt;/p&gt;
&lt;p&gt;项目链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/coreos/etcd&#34;&gt;https://github.com/coreos/etcd&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;beego&#34;&gt;beego&lt;/h3&gt;
&lt;p&gt;beego 是一个类似 Python的 Tornado 框架，采用了 RESTFul 的设计思路，使用 Go 语言编写的一个极轻量级、高可伸缩性和高性能的 Web 应用框架。&lt;/p&gt;
&lt;p&gt;项目链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/astaxie/beego&#34;&gt;https://github.com/astaxie/beego&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;martini&#34;&gt;martini&lt;/h3&gt;
&lt;p&gt;一款快速构建模块化的 Web 应用的 Web 框架。&lt;/p&gt;
&lt;p&gt;项目链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/go-martini/martini&#34;&gt;https://github.com/go-martini/martini&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;codis&#34;&gt;codis&lt;/h3&gt;
&lt;p&gt;国产的优秀分布式 Redis 解决方案。&lt;/p&gt;
&lt;p&gt;项目链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/CodisLabs/codis&#34;&gt;https://github.com/CodisLabs/codis&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;delve&#34;&gt;delve&lt;/h3&gt;
&lt;p&gt;Go语言&lt;/p&gt;
&lt;p&gt;强大的调试器，被很多集成环境和编辑器整合。&lt;/p&gt;
&lt;p&gt;项目链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/derekparker/delve&#34;&gt;https://github.com/derekparker/delve&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;facebook&#34;&gt;Facebook&lt;/h3&gt;
&lt;p&gt;Facebook也在用，为此他们还专门在Github上建立了一个开源组织facebookgo，大家可以通过https://github.com/facebookgo访问查看facebook开源的项目，比如著名的是平滑升级的grace。&lt;/p&gt;
&lt;h3 id=&#34;uber&#34;&gt;Uber&lt;/h3&gt;
&lt;h3 id=&#34;腾讯&#34;&gt;腾讯&lt;/h3&gt;
&lt;p&gt;腾讯作为国内的大公司，还是敢于尝试的，尤其是Docker容器化这一块，他们在15年已经做了docker万台规模的实践，具体可以参考http://www.infoq.com/cn/articles/tencent-millions-scale-docker-application-practice 。&lt;/p&gt;
&lt;h3 id=&#34;百度&#34;&gt;百度&lt;/h3&gt;
&lt;p&gt;目前所知的百度的使用是在运维这边，是百度运维的一个BFE项目，负责前端流量的接入。他们的负责人在2016年有分享，大家可以看下这个 &lt;a href=&#34;http://www.infoq.com/cn/presentations/application-of-golang-in-baidu-frontend&#34;&gt;http://www.infoq.com/cn/presentations/application-of-golang-in-baidu-frontend&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;其次就是百度的消息系统。负责公司手百消息通讯系统服务器端开发及维护。&lt;/p&gt;
&lt;h3 id=&#34;京东&#34;&gt;京东&lt;/h3&gt;
&lt;p&gt;京东云消息推送系统、云存储，以及京东商城等都有使用Go做开发。&lt;/p&gt;
&lt;h3 id=&#34;小米&#34;&gt;小米&lt;/h3&gt;
&lt;p&gt;小米对Golang的支持，莫过于运维监控系统的开源，也就是 &lt;a href=&#34;http://open-falcon.com/&#34;&gt;http://open-falcon.com/&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;此外，小米互娱、小米商城、小米视频、小米生态链等团队都在使用Golang。&lt;/p&gt;
&lt;h3 id=&#34;360&#34;&gt;360&lt;/h3&gt;
&lt;p&gt;360对Golang的使用也不少，一个是开源的日志搜索系统Poseidon，托管在Github上，https://github.com/Qihoo360/poseidon.&lt;/p&gt;
&lt;p&gt;还有360的推送团队也在使用，他们还写了篇博文在Golang的官方博客上 &lt;a href=&#34;https://blog.golang.org/qihoo&#34;&gt;https://blog.golang.org/qihoo&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;七牛云&#34;&gt;七牛云&lt;/h3&gt;
&lt;p&gt;七牛云用了近50万行代码，来实现整个产品。七牛云存储产品网址：http://qiniu.com/。上线时间：2011-9-1。应用范围：整个产品（包括基础服务、Web端、统计平台、各类小工具等等）Go代码行数占比：99.9%日 PV：保密&lt;/p&gt;
&lt;h3 id=&#34;美团&#34;&gt;美团&lt;/h3&gt;
&lt;p&gt;美团后台流量支撑程序。应用范围：支撑主站后台流量（排序，推荐，搜索等），提供负载均衡，cache，容错，按条件分流，统计运行指标（qps，latency）等功能。&lt;/p&gt;
&lt;h3 id=&#34;滴滴&#34;&gt;滴滴&lt;/h3&gt;
&lt;p&gt;基础服务平台。&lt;/p&gt;
&lt;p&gt;###金山微看&lt;/p&gt;
&lt;p&gt;应用范围：服务接口，后台流程服务，消息系统，图片系统&lt;/p&gt;
&lt;h3 id=&#34;搜狗&#34;&gt;搜狗&lt;/h3&gt;
&lt;p&gt;搜狗推送系统。Push系统中用于维持与客户端连接的部分。&lt;/p&gt;
&lt;h3 id=&#34;qor---模块化的电商系统&#34;&gt;QOR - 模块化的电商系统&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;QOR官网: &lt;a href=&#34;https://link.zhihu.com/?target=http%3A//getqor.com&#34;&gt;QOR: E-commerce &amp;amp; CMS SDK written in Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;github地址: qor/qor · GitHub&lt;/li&gt;
&lt;li&gt;应用范围: 整个产品&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;weico&#34;&gt;weico&lt;/h3&gt;
&lt;p&gt;产品名：weico 3.0， 服务端所有代码都是用Go实现。&lt;/p&gt;
&lt;h3 id=&#34;仙侠道&#34;&gt;仙侠道&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;产品网址：[仙侠道官网 - 心动游戏](仙侠道官网 - 心动游戏)&lt;/li&gt;
&lt;li&gt;应用范围： 游戏服务端（通讯、逻辑、数据存储）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;快玩游戏&#34;&gt;快玩游戏&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网址：&lt;a href=&#34;%E5%BF%AB%E7%8E%A9%E5%B0%8F%E6%B8%B8%E6%88%8F,%E5%8D%95%E6%9C%BA%E6%B8%B8%E6%88%8F,%E7%BD%91%E9%A1%B5%E6%B8%B8%E6%88%8F,%E5%BF%AB%E7%8E%A9%E6%B8%B8%E6%88%8F,%E5%BF%AB%E7%8E%A9%E6%B8%B8%E6%88%8F%E7%9B%92&#34;&gt;快玩小游戏,单机游戏,网页游戏,快玩游戏,快玩游戏盒&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;应用范围：实时消息系统、用户认证、用户会话、统一统计接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;盛大云cdn&#34;&gt;盛大云CDN&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网址：盛大云计算&lt;/li&gt;
&lt;li&gt;应用范围：CDN的调度系统、分发系统、监控系统、短域名服务，CDN内部开放平台、运营报表系统以及其他一些小工具等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bmob移动后端云服务平台&#34;&gt;Bmob移动后端云服务平台&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;产品网址：Bmob移动后端云服务平台&lt;/li&gt;
&lt;li&gt;应用范围：Restful API(使用Beego)、统计分析平台、常用服务如发邮件、队列异步处理、统计用户空间和接口请求&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;群策&#34;&gt;群策&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网址：[群策 - 统一团队沟通，高效完成工作](群策 - 统一团队沟通，高效完成工作)&lt;/li&gt;
&lt;li&gt;应用范围：全系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;biddingx-dsp广告投放系统&#34;&gt;BiddingX DSP广告投放系统&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网址：BiddingX_专业的DSP解决方案供应商&lt;/li&gt;
&lt;li&gt;应用范围：竞价投放、曝光统计、点击跳转&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;街坊四邻&#34;&gt;街坊四邻&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网址：首页 - 街坊四邻&lt;/li&gt;
&lt;li&gt;应用范围：后台服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;leanote&#34;&gt;Leanote&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网址：Leanote&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bearychat&#34;&gt;Bearychat&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网址：BearyChat&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;宅豆&#34;&gt;宅豆&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网址：宅豆网 - 自筑最美家，宅豆随你搭&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;白板--设计图讨论工具&#34;&gt;白板- 设计图讨论工具&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网址：白板&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实验楼&#34;&gt;实验楼&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网址：实验楼 - 第一家以实验为核心的IT在线教育平台&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;新浪微博&#34;&gt;新浪微博&lt;/h3&gt;
&lt;p&gt;中间件和弹性调度用 Java 和 Go 编写，微博视频转码及存储服务用 Go 编写。&lt;/p&gt;
&lt;h3 id=&#34;爱奇艺&#34;&gt;爱奇艺&lt;/h3&gt;
&lt;p&gt;VR 后台系统中间件，VR 端的 HTTP 接口。&lt;/p&gt;
&lt;h3 id=&#34;猎豹移动&#34;&gt;猎豹移动&lt;/h3&gt;
&lt;p&gt;消息推送&lt;/p&gt;
&lt;h3 id=&#34;网易&#34;&gt;网易&lt;/h3&gt;
&lt;p&gt;网易蜂巢容器公有云。&lt;/p&gt;
&lt;h3 id=&#34;哔哩哔哩&#34;&gt;哔哩哔哩&lt;/h3&gt;
&lt;p&gt;弹幕&lt;/p&gt;
&lt;h3 id=&#34;巨人网络&#34;&gt;巨人网络&lt;/h3&gt;
&lt;p&gt;部分手机游戏的服务端。&lt;/p&gt;
&lt;h3 id=&#34;今日头条&#34;&gt;今日头条&lt;/h3&gt;
&lt;p&gt;Nsq：Nsq 是由Go语言开发的高性能、高可用消息队列系统，性能非常高，每天能处理数十亿条的消息；&lt;/p&gt;
&lt;p&gt;Packer:用来生成不同平台的镜像文件，例如VM、vbox、AWS等，作者是vagrant的作者&lt;/p&gt;
&lt;p&gt;Skynet：分布式调度框架&lt;/p&gt;
&lt;p&gt;Doozer：分布式同步工具，类似ZooKeeper&lt;/p&gt;
&lt;p&gt;Heka：mazila开源的日志处理系统&lt;/p&gt;
&lt;p&gt;Cbfs：couchbase开源的分布式文件系统&lt;/p&gt;
&lt;p&gt;Tsuru：开源的PAAS平台，和SAE实现的功能一模一样&lt;/p&gt;
&lt;p&gt;Groupcache：memcahe作者写的用于Google下载系统的缓存系统&lt;/p&gt;
&lt;p&gt;God：类似redis的缓存系统，但是支持分布式和扩展性&lt;/p&gt;
&lt;p&gt;Gor：网络流量抓包和重放工具&lt;/p&gt;
&lt;p&gt;还有很多，比如阿里中间件、聚美优品、高升控股、探探、斗鱼直播、人人车、亚信、Udesk、方付通、招财猫、三一集团、美餐网等。一般的选择，都是选择用于自己公司合适的产品系统来做，比如消息推送的、监控的、容器的等，Golang特别适合做网络并发的服务，这是他的强项，所以也是被优先用于这些项目。Go语言作为一门大型项目开发语言，在很多大公司相继使用，甚至完全转向Go开发。&lt;/p&gt;
&lt;h2 id=&#34;四写在最后&#34;&gt;四、写在最后&lt;/h2&gt;
&lt;p&gt;当然，一个技术能不能发展起来，关键还要看三点。(以下观点引自https://www.cnblogs.com/qwangxiao/p/8318894.html)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**有没有一个比较好的社区。**像 C、C++、Java、Python 和 JavaScript 的生态圈都是非常丰富和火爆的。尤其是有很多商业机构参与的社区那就更为人气爆棚了，比如 Linux 的社区。&lt;/li&gt;
&lt;li&gt;**有没有一个工业化的标准。**像 C、C++、Java 都是有标准化组织的。尤其是 Java，其在架构上还搞出了像 J2EE 这样的企业级标准。&lt;/li&gt;
&lt;li&gt;**有没有一个或多个杀手级应用。**C、C++ 和 Java 的杀手级应用不用多说了，就算是对于 PHP 这样还不能算是一个好的编程语言来说，因为是 Linux 时代的第一个杀手级解决方案 LAMP 中的关键技术，所以，也发展起来了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述的这三点是非常关键的，新的技术只需要占到其中一到两点就已经很不错了，何况有的技术，比如 Java，是三点全占到了，所以，Java 的发展是如此好。当然，除了上面这三点重要的，还有一些其它的影响因素，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**学习曲线是否低，上手是否快。**这点非常重要，C++ 在这点上越做越不好了。&lt;/li&gt;
&lt;li&gt;**有没有一个不错的提高开发效率的开发框架。**如：Java 的 Spring 框架，C++ 的 STL 等。&lt;/li&gt;
&lt;li&gt;**是否有一个或多个巨型的技术公司作为后盾。**如：Java 和 Linux 后面的 IBM、Sun……&lt;/li&gt;
&lt;li&gt;**有没有解决软件开发中的痛点。**如：Java 解决了 C 和 C++ 的内存管理问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用这些标尺来量一下 Go 语言，我们可以清楚地看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Go 语言容易上手；&lt;/li&gt;
&lt;li&gt;Go 语言解决了并发编程和写底层应用开发效率的痛点；&lt;/li&gt;
&lt;li&gt;Go 语言有 Google 这个世界一流的技术公司在后面；&lt;/li&gt;
&lt;li&gt;Go 语言的杀手级应用是 Docker，而 Docker 的生态圈在这几年完全爆棚了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，Go 语言的未来是不可限量的。当然，我个人觉得，Go 可能会吞食很多 C、C++、Java 的项目。不过，Go 语言所吞食主要的项目应该是中间层的项目，既不是非常底层也不会是业务层。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也就是说，Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到高层如 Java 业务层的项目。Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，没有复杂的业务场景，也到不了特别底层（如操作系统）的中间平台层的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了，我们再用上面的标尺来量一下 Go 语言的杀手级应用 Docker，你会发现基本是一样的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker 上手很容易。&lt;/li&gt;
&lt;li&gt;Docker 解决了运维中的环境问题以及服务调度的痛点。&lt;/li&gt;
&lt;li&gt;Docker 的生态圈中有大公司在后面助力。比如 Google。&lt;/li&gt;
&lt;li&gt;Docker 产出了工业界标准 OCI。&lt;/li&gt;
&lt;li&gt;Docker 的社区和生态圈已经出现像 Java 和 Linux 那样的态势。&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，虽然几年前的 Docker ，当时的坑儿还很多，但是，相对于这些大的因素来说，那些小坑儿都不是问题。只是需要一些时间，这些小坑儿在未来 5-10 年就可以完全被填平了。&lt;/p&gt;
&lt;p&gt;同样，我们可以看到 Kubernetes 作为服务和容器调度的关键技术一定会是最后的赢家。&lt;/p&gt;
&lt;p&gt;最后，我还要说一下，为什么要早一点地进入这些新技术，而不是等待这些技术成熟了后再进入。原因有这么几个。&lt;/p&gt;
&lt;p&gt;技术的发展过程非常重要。因为你可以清楚地看到了这种新技术的生态圈发展过程。让我们收获最大的并不是这些技术本身，而是一个技术的变迁和行业的发展。&lt;/p&gt;
&lt;p&gt;从中，我们看到了非常具体的各种思潮和思路，这些东西比起 技术本身来说更有价值。因为，这不但让我们重新思考已经掌握的技术以及如何更好地解决已有的问题，而且还让我看到了未来。不但有了技术优势，而且这些知识还让我们的技术生涯多了很多的可能性。&lt;/p&gt;
&lt;p&gt;这些关键新技术，可以让你拿到技术的先机。这些对一个需要技术领导力的个人或公司来说都是非常重要的。&lt;/p&gt;
&lt;p&gt;一个公司或是个人能够占有技术先机，就会比其它公司或个人有更大的影响力。一旦未来行业需求引爆，那么这个公司或是个人的影响力就会形成一个比较大的护城河，并可以快速地产生经济利益。&lt;/p&gt;
&lt;p&gt;Go的应用范围一直在扩大，云计算，微服务，区块链，哪里都有用Go写的重量级项目。docker/kubernetes生态圈，几百/千万行代码，基本统治了云原生应用市场。去年大热的区块链，以太坊的geth，比特币的btcd，闪电网络的lnd，都是Go语言开发。还是那句话，多看看各种语言的生态，或许都并没有你想象的那么不堪。。。Go语言设计上确实不够“先进”，但也是另一种“务实”。其实go不管在国内还是国外已经很受待见了，国外google用的很多，uber也在用，国内有著名的今日头条，每日千亿级的访问妥妥的。多少语言终其一生都没有这么大的应用场景。&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934/&#34;&gt;https://www.bilibili.com/video/av56018934/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundationhttps://www.bilibili.com/video/av47467197/?p=6&#34;&gt;https://github.com/rubyhan1314/go_foundationhttps://www.bilibili.com/video/av47467197/?p=6&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Go语言中包的使用</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day11_%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day11_%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;go语言中包的使用&#34;&gt;Go语言中包的使用&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Go语言使用包（package）这种语法元素来组织源码，所有语法可见性均定义在package这个级别，与Java 、python等语言相比，这算不上什么创新，但与C传统的include相比，则是显得“先进”了许多。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;myblog
├── conf
│   └── app.conf
├── controllers
│   ├── aboutme_controller.go
│   ├── add_article_controller.go
│   ├── album_controller.go
│   ├── base_controller.go
│   ├── default.go
│   ├── delete_article_controller.go
│   ├── exit_controller.go
│   ├── home_controller.go
│   ├── login_controller.go
│   ├── register_controller.go
│   ├── show_article_controller.go
│   ├── tags_controller.go
│   ├── update_article_controller.go
│   └── upload_controller.go
├── main.go
├── models
│   ├── album_model.go
│   ├── article_model.go
│   ├── home_model.go
│   ├── tags_model.go
│   └── user_model.go
├── myblogweb
├── routers
│   └── router.go
├── static
│   ├── css
│   │   ├── blogsheet.css
│   │   └── lib
│   │       ├── highlight.css
│   │       └── login.css
│   ├── img
│   ├── js
│   │   ├── blog.js
│   │   ├── lib
│   │   │   ├── jquery-3.3.1.min.js
│   │   │   └── jquery.url.js
│   │   └── reload.min.js
│   └── upload
│       └── img
│           └── 2018
│               └── 12
│                   └── 11
│                       ├── 1544511378-bee2.png
├── tests
│   └── default_test.go
├── utils
│   ├── myUtils.go
│   └── mysqlUtils.go
└── views
    ├── aboultme.html
    ├── album.html
    ├── block
    │   ├── home_block.html
    │   └── nav.html
    ├── home.html
    ├── index.tpl
    ├── login.html
    ├── register.html
    ├── show_article.html
    ├── tags.html
    └── write_article.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go 语言的源码复用建立在包（package）基础之上。包通过 package, import, GOPATH 操作完成。&lt;/p&gt;
&lt;h2 id=&#34;1-main包&#34;&gt;1、 main包&lt;/h2&gt;
&lt;p&gt;Go 语言的入口 main() 函数所在的包（package）叫 main，main 包想要引用别的代码，需要import导入！&lt;/p&gt;
&lt;h2 id=&#34;2-package&#34;&gt;2、 package&lt;/h2&gt;
&lt;p&gt;src 目录是以代码包的形式组织并保存 Go 源码文件的。每个代码包都和 src 目录下的文件夹一一对应。每个子目录都是一个代码包。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码包包名和文件目录名，不要求一致。比如文件目录叫 hello，但是代码包包名可以声明为 “main”，但是同一个目录下的源码文件第一行声明的所属包，必须一致！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同一个目录下的所有.go文件的第一行添加 包定义，以标记该文件归属的包，演示语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package 包名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;包需要满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个目录下的同级文件归属一个包。也就是说，在同一个包下面的所有文件的package名，都是一样的。&lt;/li&gt;
&lt;li&gt;在同一个包下面的文件&lt;code&gt;package&lt;/code&gt;名都建议设为是该目录名，但也可以不是。也就是说，包名可以与其目录不同名。&lt;/li&gt;
&lt;li&gt;包名为 main 的包为应用程序的入口包，其他包不能使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在同一个包下面的文件属于同一个工程文件，不用&lt;code&gt;import&lt;/code&gt;包，可以直接使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;包可以嵌套定义，对应的就是嵌套目录，但包名应该与所在的目录一致，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 文件：qf/ruby/tool.go中
package ruby
// 可以被导出的函数
func FuncPublic() {
}
// 不可以被导出的函数
func funcPrivate() {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;包中，通过标识符首字母是否大写，来确定是否可以被导出。首字母大写才可以被导出，视为 public 公共的资源。&lt;/p&gt;
&lt;h2 id=&#34;3-import&#34;&gt;3、 import&lt;/h2&gt;
&lt;p&gt;要引用其他包，可以使用 import 关键字，可以单个导入或者批量导入，语法演示：&lt;/p&gt;
&lt;p&gt;A：通常导入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 单个导入
import &amp;quot;package&amp;quot;
// 批量导入
import (
  &amp;quot;package1&amp;quot;
  &amp;quot;package2&amp;quot;
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B：点操作
我们有时候会看到如下的方式导入包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import(
	. &amp;quot;fmt&amp;quot;
) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调&lt;/p&gt;
&lt;p&gt;用的&lt;code&gt;fmt.Println(&amp;quot;hello world&amp;quot;)&lt;/code&gt;可以省略的写成&lt;code&gt;Println(&amp;quot;hello world&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;C：起别名&lt;/p&gt;
&lt;p&gt;别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字。导入时，可以为包定义别名，语法演示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
  p1 &amp;quot;package1&amp;quot;
  p2 &amp;quot;package2&amp;quot;
  )
// 使用时：别名操作，调用包函数时前缀变成了我们的前缀
p1.Method()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;D：_操作
如果仅仅需要导入包时执行初始化操作，并不需要使用包内的其他函数，常量等资源。则可以在导入包时，匿名导入。&lt;/p&gt;
&lt;p&gt;这个操作经常是让很多人费解的一个操作符，请看下面这个import：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
   &amp;quot;database/sql&amp;quot;
   _ &amp;quot;github.com/ziutek/mymysql/godrv&amp;quot;
 ) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;_操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。也就是说，使用下划线作为包的别名，会仅仅执行init()。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;导入的包的路径名，可以是相对路径也可以是绝对路径，推荐使用绝对路径（起始于工程根目录）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4gopath环境变量&#34;&gt;4、GOPATH环境变量&lt;/h2&gt;
&lt;p&gt;import导入时，会从GO的安装目录（也就是GOROOT环境变量设置的目录）和GOPATH环境变量设置的目录中，检索 src/package 来导入包。如果不存在，则导入失败。
GOROOT，就是GO内置的包所在的位置。
GOPATH，就是我们自己定义的包的位置。&lt;/p&gt;
&lt;p&gt;通常我们在开发Go项目时，调试或者编译构建时，需要设置GOPATH指向我们的项目目录，目录中的src目录中的包就可以被导入了。&lt;/p&gt;
&lt;h2 id=&#34;5init-包初始化&#34;&gt;5、init() 包初始化&lt;/h2&gt;
&lt;p&gt;下面我们详细的来介绍一下这两个函数：init()、main() 是 go 语言中的保留函数。我们可以在源码中，定义 init() 函数。此函数会在包被导入时执行，例如如果是在 main 中导入包，包中存在 init()，那么 init() 中的代码会在 main() 函数执行前执行，用于初始化包所需要的特定资料。例如：
包源码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;src/userPackage/tool.go

package userPackage
import &amp;quot;fmt&amp;quot;
func init() {
  fmt.Println(&amp;quot;tool init&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主函数源码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;src/main.go

package main
import (
  &amp;quot;userPackage&amp;quot;
  )
func main() {
  fmt.Println(&amp;quot;main run&amp;quot;)
  // 使用userPackage
  userPackage.SomeFunc()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行时，会先输出 &amp;quot;tool init&amp;quot;，再输出 &amp;quot;main run&amp;quot;。&lt;/p&gt;
&lt;p&gt;下面我们详细的来介绍一下init()、main() 这两个函数。在 go 语言中的区别如下：
相同点：&lt;/p&gt;
&lt;p&gt;两个函数在定义时不能有任何的参数和返回值。
该函数只能由 go 程序自动调用，不可以被引用。&lt;/p&gt;
&lt;p&gt;不同点：&lt;/p&gt;
&lt;p&gt;init 可以应用于任意包中，且可以重复定义多个。
main 函数只能用于 main 包中，且只能定义一个。&lt;/p&gt;
&lt;p&gt;两个函数的执行顺序：&lt;/p&gt;
&lt;p&gt;在 main 包中的 go 文件默认总是会被执行。&lt;/p&gt;
&lt;p&gt;对同一个 go 文件的 init( ) 调用顺序是从上到下的。&lt;/p&gt;
&lt;p&gt;对同一个 package 中的不同文件，将文件名按字符串进行“从小到大”排序，之后顺序调用各文件中的init()函数。&lt;/p&gt;
&lt;p&gt;对于不同的 package，如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 init() 函数。&lt;/p&gt;
&lt;p&gt;如果 package 存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序 main –&amp;gt; A –&amp;gt; B –&amp;gt; C，则初始化顺序为 C –&amp;gt; B –&amp;gt; A –&amp;gt; main，一次执行对应的 init 方法。main 包总是被最后一个初始化，因为它总是依赖别的包&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/20170831112523944.png&#34; alt=&#34;20170831112523944&#34;&gt;&lt;/p&gt;
&lt;p&gt;图片引自网络&lt;/p&gt;
&lt;p&gt;避免出现循环 import，例如：A –&amp;gt; B –&amp;gt; C –&amp;gt; A。&lt;/p&gt;
&lt;p&gt;一个包被其它多个包 import，但只能被初始化一次&lt;/p&gt;
&lt;h2 id=&#34;6管理外部包&#34;&gt;6、管理外部包&lt;/h2&gt;
&lt;p&gt;go允许import不同代码库的代码。对于import要导入的外部的包，可以使用 go get 命令取下来放到GOPATH对应的目录中去。&lt;/p&gt;
&lt;p&gt;举个例子，比如说我们想通过go语言连接mysql数据库，那么需要先下载mysql的数据包，打开终端并输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;localhost:~ ruby$ go get github.com/go-sql-driver/mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装之后，就可以在gopath目录的src下，看到对应的文件包目录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/anzhuangbao1.png&#34; alt=&#34;anzhuangbao1&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也就是说，对于go语言来讲，其实并不关心你的代码是内部还是外部的，总之都在GOPATH里，任何import包的路径都是从GOPATH开始的；唯一的区别，就是内部依赖的包是开发者自己写的，外部依赖的包是go get下来的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;扩展&#34;&gt;扩展&lt;/h2&gt;
&lt;p&gt;我们可以通过go install 来编译包文件。&lt;/p&gt;
&lt;p&gt;我们知道一个非main包在编译后会生成一个.a文件（在临时目录下生成，除非使用go install安装到&lt;code&gt;$GOROOT&lt;/code&gt;或​&lt;code&gt;$GOPATH&lt;/code&gt;下，否则你看不到.a），用于后续可执行程序链接使用。&lt;/p&gt;
&lt;p&gt;比如Go标准库中的包对应的源码部分路径在：&lt;code&gt;$GOROOT/src&lt;/code&gt;，而标准库中包编译后的.a文件路径在&lt;code&gt;$GOROOT/pkg/darwin_amd64&lt;/code&gt;下。&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_advanced&#34;&gt;https://github.com/rubyhan1314/go_advanced&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>gRPC编程使用</title>
                <link>http://www.songx.fun/blog/day81-82grpc%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/day82_grpc%E4%BD%BF%E7%94%A8/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day81-82grpc%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/day82_grpc%E4%BD%BF%E7%94%A8/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;grpc编程使用&#34;&gt;gRPC编程使用&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一grpc调用&#34;&gt;一、gRPC调用&lt;/h2&gt;
&lt;p&gt;在上节课内容中，我们学习了使用gRPC框架实现服务的调用编程。在gRPC框架中，诸如上节课我们学习的在客户端与服务端之间通过消息结构体定义的方式来传递数据，我们称之为“单项RPC”，也称之为简单模式。除此之外，gRPC中还有数据流模式的RPC调用实现，这正是我们本节课要学习的内容。&lt;/p&gt;
&lt;h3 id=&#34;11服务端流rpc&#34;&gt;1.1、服务端流RPC&lt;/h3&gt;
&lt;p&gt;在服务端流模式的RPC实现中，服务端得到客户端请求后，处理结束返回一个数据应答流。在发送完所有的客户端请求的应答数据后，服务端的状态详情和可选的跟踪元数据发送给客户端。服务端流RPC实现案例如下：&lt;/p&gt;
&lt;h4 id=&#34;111服务接口定义&#34;&gt;1.1.1、服务接口定义&lt;/h4&gt;
&lt;p&gt;在.proto文件中定义服务接口,使用服务端流模式定义服务接口,如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;...
//订单服务service定义
service OrderService {
    rpc GetOrderInfos (OrderRequest) returns (stream OrderInfo) {}; //服务端流模式
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以看到与之前简单模式下的数据作为服务接口的参数和返回值不同的是，此处服务接口的返回值使用了stream进行修饰。通过stream修饰的方式表示该接口调用时，服务端会以数据流的形式将数据返回给客户端。&lt;/p&gt;
&lt;h4 id=&#34;112-编译proto文件生成pbgo文件&#34;&gt;1.1.2 编译.proto文件，生成pb.go文件&lt;/h4&gt;
&lt;p&gt;使用gRPC插件编译命令编译.proto文件，编译命令如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;protoc --go_out=plugins=grpc:. message.proto
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;113-自动生成文件的变化&#34;&gt;1.1.3 自动生成文件的变化&lt;/h4&gt;
&lt;p&gt;与数据结构体发送携带数据实现不同的时，流模式下的数据发送和接收使用新的功能方法完成。在自动生成的go代码程序当中，每一个流模式对应的服务接口，都会自动生成对应的单独的client和server程序，以及对应的结构体实现。具体编程如下图所示：&lt;/p&gt;
&lt;h5 id=&#34;1131-服务端自动生成&#34;&gt;1.1.3.1 服务端自动生成&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type OrderService_GetOrderInfosServer interface {
	Send(*OrderInfo) error
	grpc.ServerStream
}

type orderServiceGetOrderInfosServer struct {
	grpc.ServerStream
}

func (x *orderServiceGetOrderInfosServer) Send(m *OrderInfo) error {
	return x.ServerStream.SendMsg(m)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;流模式下，服务接口的服务端提供Send方法，将数据以流的形式进行发送&lt;/p&gt;
&lt;h5 id=&#34;1132-客户端自动生成&#34;&gt;1.1.3.2 客户端自动生成&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type OrderService_GetOrderInfosClient interface {
	Recv() (*OrderInfo, error)
	grpc.ClientStream
}

type orderServiceGetOrderInfosClient struct {
	grpc.ClientStream
}

func (x *orderServiceGetOrderInfosClient) Recv() (*OrderInfo, error) {
	m := new(OrderInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;流模式下，服务接口的客户端提供Recv()方法接收服务端发送的流数据。&lt;/p&gt;
&lt;h4 id=&#34;114-服务编码实现&#34;&gt;1.1.4 服务编码实现&lt;/h4&gt;
&lt;p&gt;定义好服务接口并编译生成代码文件后，即可根据规则对定义的服务进行编码实现。具体的服务编码实现如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//订单服务实现
type OrderServiceImpl struct {
}

//获取订单信息s
func (os *OrderServiceImpl) GetOrderInfos(request *message.OrderRequest, stream message.OrderService_GetOrderInfosServer) error {
	fmt.Println(&amp;quot; 服务端流 RPC 模式&amp;quot;)

	orderMap := map[string]message.OrderInfo{
		&amp;quot;201907300001&amp;quot;: message.OrderInfo{OrderId: &amp;quot;201907300001&amp;quot;, OrderName: &amp;quot;衣服&amp;quot;, OrderStatus: &amp;quot;已付款&amp;quot;},
		&amp;quot;201907310001&amp;quot;: message.OrderInfo{OrderId: &amp;quot;201907310001&amp;quot;, OrderName: &amp;quot;零食&amp;quot;, OrderStatus: &amp;quot;已付款&amp;quot;},
		&amp;quot;201907310002&amp;quot;: message.OrderInfo{OrderId: &amp;quot;201907310002&amp;quot;, OrderName: &amp;quot;食品&amp;quot;, OrderStatus: &amp;quot;未付款&amp;quot;},
	}
	for id, info := range orderMap {
		if (time.Now().Unix() &amp;gt;= request.TimeStamp) {
			fmt.Println(&amp;quot;订单序列号ID：&amp;quot;, id)
			fmt.Println(&amp;quot;订单详情：&amp;quot;, info)
			//通过流模式发送给客户端
			stream.Send(&amp;amp;info)
		}
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GetOrderInfos方法就是服务接口的具体实现，因为是流模式开发，服务端将数据以流的形式进行发送,因此，该方法的第二个参数类型为OrderService_GetOrderInfosServer，该参数类型是一个接口，其中包含Send方法，允许发送流数据。Send方法的具体实现在编译好的pb.go文件中，进一步调用grpc.SeverStream.SendMsg方法。&lt;/p&gt;
&lt;h4 id=&#34;115-服务的注册和监听的处理&#34;&gt;1.1.5 服务的注册和监听的处理&lt;/h4&gt;
&lt;p&gt;服务的监听与处理与前文所学内容没有区别，依然是相同的步骤:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	server := grpc.NewServer()
	//注册
	message.RegisterOrderServiceServer(server, new(OrderServiceImpl))
	lis, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:8090&amp;quot;)
	if err != nil {
		panic(err.Error())
	}
	server.Serve(lis)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;116-客户端数据接收&#34;&gt;1.1.6 客户端数据接收&lt;/h4&gt;
&lt;p&gt;服务端使用Send方法将数据以流的形式进行发送，客户端可以使用Recv()方法接收流数据,因为数据流失源源不断的，因此使用for无限循环实现数据流的读取，当读取到io.EOF时，表示流数据结束。客户端数据读取实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...
for {
		orderInfo, err := orderInfoClient.Recv()
		if err == io.EOF {
			fmt.Println(&amp;quot;读取结束&amp;quot;)
			return
		}
		if err != nil {
			panic(err.Error())
		}
		fmt.Println(&amp;quot;读取到的信息：&amp;quot;, orderInfo)
	}
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;117-运行结果&#34;&gt;1.1.7 运行结果&lt;/h4&gt;
&lt;p&gt;按照先后顺序，依次运行server.go文件和client.go文件，可以得到运行结果。&lt;/p&gt;
&lt;h5 id=&#34;1171-服务端运行结果&#34;&gt;1.1.7.1 服务端运行结果&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; 服务端流 RPC 模式
订单序列号ID： 201907300001
订单详情： {201907300001 衣服 已付款 {} [] 0}
订单序列号ID： 201907310001
订单详情： {201907310001 零食 已付款 {} [] 0}
订单序列号ID： 201907310002
订单详情： {201907310002 食品 未付款 {} [] 0}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;1172-客户端运行结果&#34;&gt;1.1.7.2 客户端运行结果&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;客户端请求RPC调用：服务端流模式
读取到的信息： OrderId:&amp;quot;201907310001&amp;quot; OrderName:&amp;quot;\351\233\266\351\243\237&amp;quot; OrderStatus:&amp;quot;\345\267\262\344\273\230\346\254\276&amp;quot; 
读取到的信息： OrderId:&amp;quot;201907310002&amp;quot; OrderName:&amp;quot;\351\243\237\345\223\201&amp;quot; OrderStatus:&amp;quot;\346\234\252\344\273\230\346\254\276&amp;quot; 
读取到的信息： OrderId:&amp;quot;201907300001&amp;quot; OrderName:&amp;quot;\350\241\243\346\234\215&amp;quot; OrderStatus:&amp;quot;\345\267\262\344\273\230\346\254\276&amp;quot; 
读取结束
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12客户端流模式&#34;&gt;1.2、客户端流模式&lt;/h3&gt;
&lt;p&gt;上文演示的是服务端以数据流的形式返回数据的形式。对应的，也存在客户端以流的形式发送请求数据的形式。&lt;/p&gt;
&lt;h4 id=&#34;121-服务接口的定义&#34;&gt;1.2.1 服务接口的定义&lt;/h4&gt;
&lt;p&gt;与服务端同理,客户端流模式的RPC服务声明格式，就是使用stream修饰服务接口的接收参数,具体如下所示:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;...
//订单服务service定义
service OrderService {
    rpc AddOrderList (stream OrderRequest) returns (OrderInfo) {}; //客户端流模式
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;122--编译proto文件&#34;&gt;1.2.2  编译.proto文件&lt;/h4&gt;
&lt;p&gt;使用编译命令编译.protow文件。客户端流模式中也会自动生成服务接口的接口。&lt;/p&gt;
&lt;h5 id=&#34;1221-自动生成的服务流接口实现&#34;&gt;1.2.2.1 自动生成的服务流接口实现&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type OrderService_AddOrderListServer interface {
	SendAndClose(*OrderInfo) error
	Recv() (*OrderRequest, error)
	grpc.ServerStream
}

type orderServiceAddOrderListServer struct {
	grpc.ServerStream
}

func (x *orderServiceAddOrderListServer) SendAndClose(m *OrderInfo) error {
	return x.ServerStream.SendMsg(m)
}

func (x *orderServiceAddOrderListServer) Recv() (*OrderRequest, error) {
	m := new(OrderRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SendAndClose和Recv方法是客户端流模式下的服务端对象所拥有的方法。&lt;/p&gt;
&lt;h5 id=&#34;1222-自动生成的客户端流接口实现&#34;&gt;1.2.2.2 自动生成的客户端流接口实现&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type OrderService_AddOrderListClient interface {
	Send(*OrderRequest) error
	CloseAndRecv() (*OrderInfo, error)
	grpc.ClientStream
}

type orderServiceAddOrderListClient struct {
	grpc.ClientStream
}

func (x *orderServiceAddOrderListClient) Send(m *OrderRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *orderServiceAddOrderListClient) CloseAndRecv() (*OrderInfo, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(OrderInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Send和CloseAndRecv是客户端流模式下的客户端对象所拥有的方法。&lt;/p&gt;
&lt;h4 id=&#34;123-服务的实现&#34;&gt;1.2.3 服务的实现&lt;/h4&gt;
&lt;p&gt;客户端流模式的服务接口具体实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//订单服务实现
type OrderServiceImpl struct {
}

//添加订单信息服务实现
func (os *OrderServiceImpl) AddOrderList(stream message.OrderService_AddOrderListServer) error {
	fmt.Println(&amp;quot; 客户端流 RPC 模式&amp;quot;)

	for {
		//从流中读取数据信息
		orderRequest, err := stream.Recv()
		if err == io.EOF {
			fmt.Println(&amp;quot; 读取数据结束 &amp;quot;)
			result := message.OrderInfo{OrderStatus: &amp;quot; 读取数据结束 &amp;quot;}
			return stream.SendAndClose(&amp;amp;result)
		}
		if err != nil {
			fmt.Println(err.Error())
			return err
		}
		//打印接收到的数据
		fmt.Println(orderRequest)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;124-服务的注册和监听处理&#34;&gt;1.2.4 服务的注册和监听处理&lt;/h4&gt;
&lt;p&gt;依然是采用相同的服务注册和监听处理方式对服务进行注册和监听处理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

	server := grpc.NewServer()
	//注册
	message.RegisterOrderServiceServer(server, new(OrderServiceImpl))

	lis, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:8090&amp;quot;)
	if err != nil {
		panic(err.Error())
	}
	server.Serve(lis)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;125-客户端实现&#34;&gt;1.2.5 客户端实现&lt;/h4&gt;
&lt;p&gt;客户端调用send方法流数据到服务端，具体实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...
//调用服务方法
	addOrderListClient, err := orderServiceClient.AddOrderList(context.Background())
	if err != nil {
		panic(err.Error())
	}
	//调用方法发送流数据
	for _, info := range orderMap {
		err = addOrderListClient.Send(&amp;amp;info)
		if err != nil {
			panic(err.Error())
		}
	}

	for {
		orderInfo, err := addOrderListClient.CloseAndRecv()
		if err == io.EOF {
			fmt.Println(&amp;quot; 读取数据结束了 &amp;quot;)
			return
		}
		if err != nil {
			fmt.Println(err.Error())
		}
		fmt.Println(orderInfo.GetOrderStatus())
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;126-程序运行&#34;&gt;1.2.6 程序运行&lt;/h4&gt;
&lt;h5 id=&#34;1261-服务端&#34;&gt;1.2.6.1 服务端&lt;/h5&gt;
&lt;p&gt;运行案例，程序输出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; 客户端流 RPC 模式
201907300001 衣服 已付款
201907310001 零食 已付款
201907310002 食品 未付款
 读取数据结束 
 客户端流 RPC 模式
201907300001 衣服 已付款
201907310001 零食 已付款
201907310002 食品 未付款
 读取数据结束 
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;1262-客户端&#34;&gt;1.2.6.2 客户端&lt;/h5&gt;
&lt;p&gt;客户端运行程序输出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;客户端请求RPC调用：客户端流模式
 读取数据结束 
 读取数据结束了 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13双向流模式&#34;&gt;1.3、双向流模式&lt;/h3&gt;
&lt;p&gt;上文已经讲过了服务端流模式和客户端流模式。如果将客户端和服务端两种流模式结合起来,就是第三种模式，双向流模式。即客户端发送数据的时候以流数据发送，服务端返回数据也以流的形式进行发送，因此称之为双向流模式。&lt;/p&gt;
&lt;h4 id=&#34;131-双向流服务的定义&#34;&gt;1.3.1 双向流服务的定义&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//订单服务service定义
service OrderService {
    rpc GetOrderInfos (stream OrderRequest) returns (stream OrderInfo) {}; //双向流模式
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;132-编译proto文件&#34;&gt;1.3.2 编译.proto文件&lt;/h4&gt;
&lt;h5 id=&#34;1321-服务端接口实现&#34;&gt;1.3.2.1 服务端接口实现&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type OrderService_GetOrderInfosServer interface {
	Send(*OrderInfo) error
	Recv() (*OrderRequest, error)
	grpc.ServerStream
}

type orderServiceGetOrderInfosServer struct {
	grpc.ServerStream
}

func (x *orderServiceGetOrderInfosServer) Send(m *OrderInfo) error {
	return x.ServerStream.SendMsg(m)
}

func (x *orderServiceGetOrderInfosServer) Recv() (*OrderRequest, error) {
	m := new(OrderRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;1322-客户端接口实现&#34;&gt;1.3.2.2 客户端接口实现&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type OrderService_GetOrderInfosClient interface {
	Send(*OrderRequest) error
	Recv() (*OrderInfo, error)
	grpc.ClientStream
}

type orderServiceGetOrderInfosClient struct {
	grpc.ClientStream
}

func (x *orderServiceGetOrderInfosClient) Send(m *OrderRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *orderServiceGetOrderInfosClient) Recv() (*OrderInfo, error) {
	m := new(OrderInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;133-服务实现&#34;&gt;1.3.3 服务实现&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//实现grpc双向流模式
func (os *OrderServiceImpl) GetOrderInfos(stream message.OrderService_GetOrderInfosServer) error {

	for {
		orderRequest, err := stream.Recv()
		if err == io.EOF {
			fmt.Println(&amp;quot; 数据读取结束 &amp;quot;)
			return err
		}
		if err != nil {
			panic(err.Error())
			return err
		}

		fmt.Println(orderRequest.GetOrderId())
		orderMap := map[string]message.OrderInfo{
			&amp;quot;201907300001&amp;quot;: message.OrderInfo{OrderId: &amp;quot;201907300001&amp;quot;, OrderName: &amp;quot;衣服&amp;quot;, OrderStatus: &amp;quot;已付款&amp;quot;},
			&amp;quot;201907310001&amp;quot;: message.OrderInfo{OrderId: &amp;quot;201907310001&amp;quot;, OrderName: &amp;quot;零食&amp;quot;, OrderStatus: &amp;quot;已付款&amp;quot;},
			&amp;quot;201907310002&amp;quot;: message.OrderInfo{OrderId: &amp;quot;201907310002&amp;quot;, OrderName: &amp;quot;食品&amp;quot;, OrderStatus: &amp;quot;未付款&amp;quot;},
		}

		result := orderMap[orderRequest.GetOrderId()]
		//发送数据
		err = stream.Send(&amp;amp;result)
		if err == io.EOF {
			fmt.Println(err)
			return err
		}
		if err != nil {
			fmt.Println(err.Error())
			return err
		}
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;134-服务端及客户端的编程实现&#34;&gt;1.3.4 服务端及客户端的编程实现&lt;/h4&gt;
&lt;h5 id=&#34;1341-服务端实现&#34;&gt;1.3.4.1 服务端实现&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	server := grpc.NewServer()
	//注册
	message.RegisterOrderServiceServer(server, new(OrderServiceImpl))

	lis, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:8092&amp;quot;)
	if err != nil {
		panic(err.Error())
	}
	server.Serve(lis)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;1342-客户端实现&#34;&gt;1.3.4.2 客户端实现&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

	//1、Dail连接
	conn, err := grpc.Dial(&amp;quot;localhost:8092&amp;quot;, grpc.WithInsecure())
	if err != nil {
		panic(err.Error())
	}
	defer conn.Close()

	orderServiceClient := message.NewOrderServiceClient(conn)

	fmt.Println(&amp;quot;客户端请求RPC调用：双向流模式&amp;quot;)
	orderIDs := []string{&amp;quot;201907300001&amp;quot;, &amp;quot;201907310001&amp;quot;, &amp;quot;201907310002&amp;quot;}

	orderInfoClient, err := orderServiceClient.GetOrderInfos(context.Background())
	for _, orderID := range orderIDs {
		orderRequest := message.OrderRequest{OrderId: orderID}
		err := orderInfoClient.Send(&amp;amp;orderRequest)
		if err != nil {
			panic(err.Error())
		}
	}

	//关闭
	orderInfoClient.CloseSend()

	for {
		orderInfo, err := orderInfoClient.Recv()
		if err == io.EOF {
			fmt.Println(&amp;quot;读取结束&amp;quot;)
			return
		}
		if err != nil {
			return
		}
		fmt.Println(&amp;quot;读取到的信息：&amp;quot;, orderInfo)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二tls验证和token认证&#34;&gt;二、TLS验证和Token认证&lt;/h2&gt;
&lt;p&gt;上节课我们学习掌握了grpc-go框架的四种流模式。在实际的生产环境中，一个功能完整的服务，不仅包含基本的方法调用和数据交互的功能，还包括授权认证，数据追踪，负载均衡等方面。本节课，我们来看一下除了在gRPC调用过程中，如何实现授权认证，以及如何进行拦截处理。&lt;/p&gt;
&lt;h3 id=&#34;21-授权认证&#34;&gt;2.1 授权认证&lt;/h3&gt;
&lt;p&gt;gRPC中默认支持两种授权方式,分别是：SSL/TLS认证方式、基于Token的认证方式。&lt;/p&gt;
&lt;h4 id=&#34;211-ssltls认证方式&#34;&gt;2.1.1 SSL/TLS认证方式&lt;/h4&gt;
&lt;p&gt;SSL全称是Secure Sockets Layer，又被称之为安全套接字层，是一种标准安全协议，用于在通信过程中建立客户端与服务器之间的加密链接。
TLS的全称是Transport Layer Security，TLS是SSL的升级版。在使用的过程中，往往习惯于将SSL和TLS组合在一起写作SSL/TLS。
简而言之，SSL/TLS是一种用于网络通信中加密的安全协议。&lt;/p&gt;
&lt;h5 id=&#34;2111-ssltls工作原理&#34;&gt;2.1.1.1 SSL/TLS工作原理&lt;/h5&gt;
&lt;p&gt;使用SSL/TLS协议对通信连接进行安全加密，是通过非对称加密的方式来实现的。所谓非对称加密方式又称之为公钥加密，密钥对由公钥和私钥两种密钥组成。私钥和公钥成对存在，先生成私钥，通过私钥生成对应的公钥。公钥可以公开，私钥进行妥善保存。&lt;/p&gt;
&lt;p&gt;在加密过程中：客户端想要向服务器发起链接，首先会先向服务端请求要加密的公钥。获取到公钥后客户端使用公钥将信息进行加密，服务端接收到加密信息，使用私钥对信息进行解密并进行其他后续处理，完成整个信道加密并实现数据传输的过程。&lt;/p&gt;
&lt;h5 id=&#34;2112-制作证书&#34;&gt;2.1.1.2 制作证书&lt;/h5&gt;
&lt;p&gt;可以自己在本机计算机上安装openssl，并生成相应的证书。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-openssl&#34;&gt;openssl ecparam -genkey -name secp384r1 -out server.key
openssl req -new -x509 -sha256 -key server.key -out server.pem -days 3650
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2113-编程实现服务端&#34;&gt;2.1.1.3 编程实现服务端&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type MathManager struct {
}

func (mm *MathManager) AddMethod(ctx context.Context, request *message.RequestArgs) (response *message.Response, err error) {
	fmt.Println(&amp;quot; 服务端 Add方法 &amp;quot;)
	result := request.Args1 + request.Args2
	fmt.Println(&amp;quot; 计算结果是：&amp;quot;, result)
	response = new(message.Response)
	response.Code = 1;
	response.Message = &amp;quot;执行成功&amp;quot;
	return response, nil
}

func main() {

	//TLS认证
	creds, err := credentials.NewServerTLSFromFile(&amp;quot;./keys/server.pem&amp;quot;, &amp;quot;./keys/server.key&amp;quot;)
	if err != nil {
		grpclog.Fatal(&amp;quot;加载在证书文件失败&amp;quot;, err)
	}

	//实例化grpc server, 开启TLS认证
	server := grpc.NewServer(grpc.Creds(creds))

	message.RegisterMathServiceServer(server, new(MathManager))

	lis, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:8092&amp;quot;)
	if err != nil {
		panic(err.Error())
	}
	server.Serve(lis)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2113-编程实现客户端&#34;&gt;2.1.1.3 编程实现客户端&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;func main() {

	//TLS连接
	creds, err := credentials.NewClientTLSFromFile(&amp;quot;./keys/server.pem&amp;quot;, &amp;quot;go-grpc-example&amp;quot;)
	if err != nil {
		panic(err.Error())
	}
	//1、Dail连接
	conn, err := grpc.Dial(&amp;quot;localhost:8092&amp;quot;, grpc.WithTransportCredentials(creds))
	if err != nil {
		panic(err.Error())
	}
	defer conn.Close()

	serviceClient := message.NewMathServiceClient(conn)

	addArgs := message.RequestArgs{Args1: 3, Args2: 5}

	response, err := serviceClient.AddMethod(context.Background(), &amp;amp;addArgs)
	if err != nil {
		grpclog.Fatal(err.Error())
	}

	fmt.Println(response.GetCode(), response.GetMessage())
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;212-基于token认证方式&#34;&gt;2.1.2 基于Token认证方式&lt;/h4&gt;
&lt;h5 id=&#34;2121-token认证介绍&#34;&gt;2.1.2.1 Token认证介绍&lt;/h5&gt;
&lt;p&gt;在web应用的开发过程中，我们往往还会使用另外一种认证方式进行身份验证，那就是：Token认证。基于Token的身份验证是无状态，不需要将用户信息服务存在服务器或者session中。&lt;/p&gt;
&lt;h5 id=&#34;2122-token认证过程&#34;&gt;2.1.2.2 Token认证过程&lt;/h5&gt;
&lt;p&gt;基于Token认证的身份验证主要过程是：客户端在发送请求前，首先向服务器发起请求，服务器返回一个生成的token给客户端。客户端将token保存下来，用于后续每次请求时，携带着token参数。服务端在进行处理请求之前，会首先对token进行验证，只有token验证成功了，才会处理并返回相关的数据。&lt;/p&gt;
&lt;h5 id=&#34;2123-grpc的自定义token认证&#34;&gt;2.1.2.3 gRPC的自定义Token认证&lt;/h5&gt;
&lt;p&gt;在gRPC中，允许开发者自定义自己的认证规则，通过&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;grpc.WithPerRPCCredentials()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置自定义的认证规则。WithPerRPCCredentials方法接收一个PerRPCCredentials类型的参数，进一步查看可以知道PerRPCCredentials是一个接口，定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type PerRPCCredentials interface {
    GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error)
    RequireTransportSecurity() bool
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，开发者可以实现以上接口，来定义自己的token信息。&lt;/p&gt;
&lt;p&gt;在本案例中，我们自定义的token认证结构体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//token认证
type TokenAuthentication struct {
	AppKey    string
	AppSecret string
}

//组织token信息
func (ta *TokenAuthentication) RequestMetaData(ctx context.Context, uri ...string) (map[string]string, error) {
	return map[string]string{
		&amp;quot;appid&amp;quot;:    ta.AppKey,
		&amp;quot;appkey&amp;quot;: ta.AppSecret,
	}, nil
}

//是否基于TLS认证进行安全传输
func (a *TokenAuthentication) RequireTransportSecurity() bool {
	return true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是，RequestMetaData方法中的appid和appkey字段均需要保持小写，不能大写。RequireTransportSecurity方法用于设置是否基于tls认证进行安全传输。&lt;/p&gt;
&lt;p&gt;在客户端进行连接时，我们将自定义的token认证信息作为参数进行传入。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;auth := TokenAuthentication{
		AppKey:    &amp;quot;hello&amp;quot;,
		AppSecret: &amp;quot;20190812&amp;quot;,
}
conn, err := grpc.Dial(&amp;quot;localhost:8093&amp;quot;, grpc.WithTransportCredentials(creds), grpc.WithPerRPCCredentials(&amp;amp;auth))
if err != nil {
	panic(err.Error())
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2124-服务端&#34;&gt;2.1.2.4 服务端&lt;/h5&gt;
&lt;p&gt;在服务端的调用方法中实现对token请求参数的判断，可以通过metadata获取token认证信息。具体实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (mm *MathManager) AddMethod(ctx context.Context, request *message.RequestArgs) (response *message.Response, err error) {

	//通过metadata
	md, exist := metadata.FromIncomingContext(ctx)
	if !exist {
		return nil, status.Errorf(codes.Unauthenticated, &amp;quot;无Token认证信息&amp;quot;)
	}

	var appKey string
	var appSecret string

	if key, ok := md[&amp;quot;appid&amp;quot;]; ok {
		appKey = key[0]
	}

	if secret, ok := md[&amp;quot;appkey&amp;quot;]; ok {
		appSecret = secret[0]
	}

	if appKey != &amp;quot;hello&amp;quot; || appSecret != &amp;quot;20190812&amp;quot; {
		return nil, status.Errorf(codes.Unauthenticated, &amp;quot;Token 不合法&amp;quot;)
	}
	fmt.Println(&amp;quot; 服务端 Add方法 &amp;quot;)
	result := request.Args1 + request.Args2
	fmt.Println(&amp;quot; 计算结果是：&amp;quot;, result)
	response = new(message.Response)
	response.Code = 1;
	response.Message = &amp;quot;执行成功&amp;quot;
	return response, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，运行项目，token认证成功。客户端修改token信息，再次运行，会发现提示token不合法。&lt;/p&gt;
&lt;h2 id=&#34;三拦截器的使用&#34;&gt;三、拦截器的使用&lt;/h2&gt;
&lt;h3 id=&#34;31需求&#34;&gt;3.1、需求&lt;/h3&gt;
&lt;p&gt;在上节课程中，我们学习使用了gRPC框架中的两种认证方式：TLS验证和Token验证。&lt;/p&gt;
&lt;p&gt;但是，在服务端的方法中，每个方法都要进行token的判断。程序效率太低，可以优化一下处理逻辑，在调用服务端的具体方法之前，先进行拦截，并进行token验证判断，这种方式称之为拦截器处理。&lt;/p&gt;
&lt;p&gt;除了此处的token验证判断处理以外，还可以进行日志处理等。&lt;/p&gt;
&lt;h3 id=&#34;32interceptor&#34;&gt;3.2、Interceptor&lt;/h3&gt;
&lt;p&gt;使用拦截器，首先需要注册。
在grpc中编程实现中，可以在NewSever时添加拦截器设置，grpc框架中可以通过UnaryInterceptor方法设置自定义的拦截器，并返回ServerOption。具体代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;grpc.UnaryInterceptor()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UnaryInterceptor()接收一个UnaryServerInterceptor类型，继续查看源码定义，可以发现UnaryServerInterceptor是一个func，定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type UnaryServerInterceptor func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过以上代码，如果开发者需要注册自定义拦截器，需要自定义实现UnaryServerInterceptor的定义。&lt;/p&gt;
&lt;h3 id=&#34;33自定义unaryserverinterceptor&#34;&gt;3.3、自定义UnaryServerInterceptor&lt;/h3&gt;
&lt;p&gt;接下来就自定义实现func,符合UnaryServerInterceptor的标准，在该func的定义中实现对token的验证逻辑。自定义实现func如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TokenInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {

	//通过metadata
	md, exist := metadata.FromIncomingContext(ctx)
	if !exist {
		return nil, status.Errorf(codes.Unauthenticated, &amp;quot;无Token认证信息&amp;quot;)
	}

	var appKey string
	var appSecret string
	if key, ok := md[&amp;quot;appid&amp;quot;]; ok {
		appKey = key[0]
	}
	if secret, ok := md[&amp;quot;appkey&amp;quot;]; ok {
		appSecret = secret[0]
	}

	if appKey != &amp;quot;hello&amp;quot; || appSecret != &amp;quot;20190812&amp;quot; {
		return nil, status.Errorf(codes.Unauthenticated, &amp;quot;Token 不合法&amp;quot;)
	}
	//通过token验证，继续处理请求
	return handler(ctx, req)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在自定义的TokenInterceptor方法定义中,和之前在服务的方法调用的验证逻辑一致，从metadata中取出请求头中携带的token认证信息，并进行验证是否正确。如果token验证通过，则继续处理请求后续逻辑，后续继续处理可以由grpc.UnaryHandler进行处理。grpc.UnaryHandler同样是一个方法，其具体的实现就是开发者自定义实现的服务方法。grpc.UnaryHandler接口定义源码定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type UnaryHandler func(ctx context.Context, req interface{}) (interface{}, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;34拦截器注册&#34;&gt;3.4、拦截器注册&lt;/h3&gt;
&lt;p&gt;在服务端调用grpc.NewServer时进行拦截器的注册。详细如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;server := grpc.NewServer(grpc.Creds(creds), grpc.UnaryInterceptor(TokenInterceptor))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;35项目运行&#34;&gt;3.5、项目运行&lt;/h3&gt;
&lt;p&gt;依次运行server.go程序和client.go程序，可以得到程序运行的正确结果。修改token携带值，可以验证token非法情况的拦截器效果。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/rpc/">RPC</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/grpc/">GRPC</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>gRPC远程过程调用机制</title>
                <link>http://www.songx.fun/blog/day81-82grpc%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/day81_grpc%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day81-82grpc%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/day81_grpc%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;grpc远程过程调用机制&#34;&gt;gRPC远程过程调用机制&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一grpc介绍和安装&#34;&gt;一、gRPC介绍和安装&lt;/h2&gt;
&lt;h3 id=&#34;11什么是grpc&#34;&gt;1.1、什么是gRPC&lt;/h3&gt;
&lt;h4 id=&#34;111-grpc介绍&#34;&gt;1.1.1、 gRPC介绍&lt;/h4&gt;
&lt;p&gt;gRPC是由Google公司开源的一款高性能的远程过程调用(RPC)框架，可以在任何环境下运行。该框架提供了负载均衡，跟踪，智能监控，身份验证等功能，可以实现系统间的高效连接。另外，在分布式系统中，gRPC框架也有有广泛应用，实现移动社会，浏览器等和服务器的连接。&lt;/p&gt;
&lt;h4 id=&#34;112grpc官方网站&#34;&gt;1.1.2、gRPC官方网站&lt;/h4&gt;
&lt;p&gt;gRPC官方网站：&lt;a href=&#34;https://grpc.io/&#34;&gt;https://grpc.io/&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;113grpc源码&#34;&gt;1.1.3、gRPC源码&lt;/h4&gt;
&lt;p&gt;gRPC的官方源码库存放于github网站，可以公开访问。gRPC源码库主页链接如下：&lt;a href=&#34;https://github.com/grpc/grpc&#34;&gt;https://github.com/grpc/grpc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;gRPC开源库支持诸如：C++，C#，Dart，Go，Java，Node，Objective-C，PHP，Python，Ruby，WebJS等多种语言，开发者可以自行在gRPC的github主页库选择查看对应语言的实现。&lt;/p&gt;
&lt;h4 id=&#34;114grpc调用执行过程&#34;&gt;1.1.4、gRPC调用执行过程&lt;/h4&gt;
&lt;p&gt;因为gRPC支持多种语言的实现，因此gRPC支持客户端与服务器在多种语言环境中部署运行和互相调用。多语言环境交互示例如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190802-154324@2x.png&#34; alt=&#34;多语言环境交互示例&#34;&gt;&lt;/p&gt;
&lt;p&gt;gRPC中默认采用的数据格式化方式是protocol buffers。关于protocol buffers相关的知识和联系，在前面的课程内容中已经有涉及，此处不再赘述。&lt;/p&gt;
&lt;h3 id=&#34;12grpc-go介绍&#34;&gt;1.2、grpc-go介绍&lt;/h3&gt;
&lt;h4 id=&#34;121-grpc-go是什么&#34;&gt;1.2.1 grpc-go是什么&lt;/h4&gt;
&lt;p&gt;grpc-go库是gRPC库的Golang语言实现版本。可以通过github主页访问grpc-go库的源码并下载。grpc-go主页的Github地址如下：&lt;a href=&#34;https://github.com/grpc/grpc-go&#34;&gt;https://github.com/grpc/grpc-go&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;122-grpc-go安装&#34;&gt;1.2.2 grpc-go安装&lt;/h4&gt;
&lt;h5 id=&#34;1221-go-get命令安装&#34;&gt;1.2.2.1 go get命令安装&lt;/h5&gt;
&lt;p&gt;在网络环境通畅的情况下，可以使用go get命令安装grpc-go库：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go get -u google.golang.org/grpc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意，很多开发者在使用上述的命令进行安装grpc-go库时，往往会遇到网络环境的问题导致下载失败，链接超时报错。经常遇到的错误是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package google.golang.org/grpc: unrecognized import path &amp;quot;google.golang.org/grpc&amp;quot; (https fetch: Get https://google.golang.org/grpc?go-get=1: dial tcp 216.239.37.1:443: i/o timeout)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果遇到类似上文中的timeout的链接服务器超时的错误，说明是网络环境问题，此时可以通过第二种方案进行安装。&lt;/p&gt;
&lt;h5 id=&#34;1222-下载方式安装&#34;&gt;1.2.2.2 下载方式安装&lt;/h5&gt;
&lt;p&gt;可以使用git工具中的git clone命令，将代码从github上下载到本地。clone命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;git clone https://github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述命令后半部分$GOPATH/src/google.golang.org/grpc是指定将grpc-go代码库下载到特定目录。&lt;/p&gt;
&lt;h5 id=&#34;1223-依赖配置&#34;&gt;1.2.2.3 依赖配置&lt;/h5&gt;
&lt;p&gt;如果采用2.2.2中的clone方式下载安装，因为grpc-go库中调用了其他外部库内容，因此，需要额外准备相关的代码库环境。需要准备的库主要是golang.org包下的一些库。golang.org包下的库也可以从github上下载，然后放到对应的golang.org目录下。&lt;/p&gt;
&lt;h5 id=&#34;1234-grpc-go案例&#34;&gt;1.2.3.4 grpc-go案例&lt;/h5&gt;
&lt;p&gt;刚刚搭建完grpc-go库环境后，还暂时不会写grpc的程序。可以通过官方提供的案例进行grpc的学习。在下载的grpc-go库的根目录中，存在有examples目录，存放了官方提供的演示案例。开发者可以通过开发工具进行学习和运行调试。&lt;/p&gt;
&lt;h5 id=&#34;1235-案例演示&#34;&gt;1.2.3.5 案例演示&lt;/h5&gt;
&lt;p&gt;通过查看examples目录下的helloworld项目，并分别依次执行greeter_server中的main.go程序和greeter_client中的main.go程序。可以查看到运行结果。项目目录和运行效果如下所示：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190802-173309@2x.png&#34; alt=&#34;示例程序及执行结果&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;二grpc框架使用&#34;&gt;二、gRPC框架使用&lt;/h2&gt;
&lt;p&gt;上节课已经学习了gRPC基本知识，对gRPC有了初步的认识。本节课通过编程实现gRPC编程。&lt;/p&gt;
&lt;h3 id=&#34;21定义服务&#34;&gt;2.1、定义服务&lt;/h3&gt;
&lt;p&gt;我们想要实现的是通过gRPC框架进行远程服务调用，首先第一步应该是要有服务。利用之前所掌握的内容，gRPC框架支持对服务的定义和生成。
gRPC框架默认使用protocol buffers作为接口定义语言，用于描述网络传输消息结构。除此之外，还可以使用protobuf定义服务接口。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;syntax = &amp;quot;proto3&amp;quot;;
package message;

//订单请求参数
message OrderRequest {
    string orderId = 1;
    int64 timeStamp = 2;
}

//订单信息
message OrderInfo {
    string OrderId = 1;
    string OrderName = 2;
    string OrderStatus = 3;
}

//订单服务service定义
service OrderService{
    rpc GetOrderInfo(OrderRequest) returns (OrderInfo);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们通过proto文件定义了数据结构的同时，还定义了要实现的服务接口，GetOrderInfo即是具体服务接口的定义，在GetOrderInfo接口定义中，OrderRequest表示是请求传递的参数，OrderInfo表示处理结果返回数据参数。&lt;/p&gt;
&lt;h3 id=&#34;22编译proto文件&#34;&gt;2.2、编译.proto文件&lt;/h3&gt;
&lt;h4 id=&#34;221环境准备&#34;&gt;2.2.1、环境准备&lt;/h4&gt;
&lt;p&gt;定义的proto文件需要通过编译，生成go语言代码文件，供客户端程序和服务端程序使用。可以安装go语言环境中的关于proto的插件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go get -a github.com/golang/protobuf/protoc-gen-go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-a 参数标示下载好后直接做 go install&lt;/p&gt;
&lt;h4 id=&#34;222编译proto文件&#34;&gt;2.2.2、编译.proto文件&lt;/h4&gt;
&lt;h5 id=&#34;2221基本用法&#34;&gt;2.2.2.1、基本用法&lt;/h5&gt;
&lt;p&gt;可以通过基本编译命令完成对.proto文件的编译.基础编译命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;protoc --go_out=. *.proto
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2222grpc编译支持&#34;&gt;2.2.2.2、gRPC编译支持&lt;/h5&gt;
&lt;p&gt;如果定义的.proto文件，如本案例中所示，定义中包含了服务接口的定义，而我们想要使用gRPC框架实现RPC调用。开发者可以采用protocol-gen-go库提供的插件编译功能，生成兼容gRPC框架的golang语言代码。只需要在基本编译命令的基础上，指定插件的参数，告知protoc编译器即可。具体的编译生成兼容gRPC框架的服务代码的命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-protoc&#34;&gt;protoc --go_out=plugins=grpc:. *.proto
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23grpc实现rpc编程&#34;&gt;2.3、gRPC实现RPC编程&lt;/h3&gt;
&lt;h4 id=&#34;231服务接口实现&#34;&gt;2.3.1、服务接口实现&lt;/h4&gt;
&lt;p&gt;在.proto定义好服务接口并生成对应的go语言文件后，需要对服务接口做具体的实现。定义服务接口具体由OrderServiceImpl进行实现，并实现GetOrderInfo详细内容，服务实现逻辑与前文所述内容相同。不同点是服务接口参数的变化。详细代码实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type OrderServiceImpl struct {
}

//具体的方法实现
func (os *OrderServiceImpl) GetOrderInfo(ctx context.Context, request *message.OrderRequest) (*message.OrderInfo, error) {
	orderMap := map[string]message.OrderInfo{
		&amp;quot;201907300001&amp;quot;: message.OrderInfo{OrderId: &amp;quot;201907300001&amp;quot;, OrderName: &amp;quot;衣服&amp;quot;, OrderStatus: &amp;quot;已付款&amp;quot;},
		&amp;quot;201907310001&amp;quot;: message.OrderInfo{OrderId: &amp;quot;201907310001&amp;quot;, OrderName: &amp;quot;零食&amp;quot;, OrderStatus: &amp;quot;已付款&amp;quot;},
		&amp;quot;201907310002&amp;quot;: message.OrderInfo{OrderId: &amp;quot;201907310002&amp;quot;, OrderName: &amp;quot;食品&amp;quot;, OrderStatus: &amp;quot;未付款&amp;quot;},
	}

	var response *message.OrderInfo
	current := time.Now().Unix()
	if (request.TimeStamp &amp;gt; current) {
		*response = message.OrderInfo{OrderId: &amp;quot;0&amp;quot;, OrderName: &amp;quot;&amp;quot;, OrderStatus: &amp;quot;订单信息异常&amp;quot;}
	} else {
		result := orderMap[request.OrderId]
		if result.OrderId != &amp;quot;&amp;quot; {
			fmt.Println(result)
			return &amp;amp;result, nil
		} else {
			return nil, errors.New(&amp;quot;server error&amp;quot;)
		}
	}
	return response, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;232grpc实现服务端&#34;&gt;2.3.2、gRPC实现服务端&lt;/h4&gt;
&lt;p&gt;使用gRPC框架，首先实现服务端的程序。既然使用gRPC框架来实现，就需要调用gRPC进行服务方法的注册以及监听的处理。服务注册和监听处理实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

	server := grpc.NewServer()

	message.RegisterOrderServiceServer(server, new(OrderServiceImpl))

	lis, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:8090&amp;quot;)
	if err != nil {
		panic(err.Error())
	}
	server.Serve(lis)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;233grpc实现客户端&#34;&gt;2.3.3、gRPC实现客户端&lt;/h4&gt;
&lt;p&gt;实现完服务端以后，实现客户端程序。和服务端程序关系对应，调用gRPC框架的方法获取相应的客户端程序，并实现服务的调用，具体编程实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

	//1、Dail连接
	conn, err := grpc.Dial(&amp;quot;localhost:8090&amp;quot;, grpc.WithInsecure())
	if err != nil {
		panic(err.Error())
	}
	defer conn.Close()

	orderServiceClient := message.NewOrderServiceClient(conn)

	orderRequest := &amp;amp;message.OrderRequest{OrderId: &amp;quot;201907300001&amp;quot;, TimeStamp: time.Now().Unix()}
	orderInfo, err := orderServiceClient.GetOrderInfo(context.Background(), orderRequest)
	if orderInfo != nil {
		fmt.Println(orderInfo.GetOrderId())
		fmt.Println(orderInfo.GetOrderName())
		fmt.Println(orderInfo.GetOrderStatus())
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;24运行程序&#34;&gt;2.4、运行程序&lt;/h3&gt;
&lt;p&gt;经过上述步骤后，程序及逻辑全部开发完成。程序运行，打印如下结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;201907300001
衣服
已付款
&lt;/code&gt;&lt;/pre&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/rpc/">RPC</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/grpc/">GRPC</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Iris框架设置、mvc包、session使用、项目搭建和资源导入</title>
                <link>http://www.songx.fun/blog/day54-55iris%E6%A1%86%E6%9E%B6/day55_%E6%A1%86%E6%9E%B6%E8%AE%BE%E7%BD%AEmvc%E5%8C%85session%E4%BD%BF%E7%94%A8%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E5%92%8C%E8%B5%84%E6%BA%90%E5%AF%BC%E5%85%A5/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day54-55iris%E6%A1%86%E6%9E%B6/day55_%E6%A1%86%E6%9E%B6%E8%AE%BE%E7%BD%AEmvc%E5%8C%85session%E4%BD%BF%E7%94%A8%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E5%92%8C%E8%B5%84%E6%BA%90%E5%AF%BC%E5%85%A5/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;iris框架设置mvc包session使用项目搭建和资源导入&#34;&gt;Iris框架设置、mvc包、session使用、项目搭建和资源导入&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author:Davie&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一-iris框架设置&#34;&gt;一 iris框架设置&lt;/h2&gt;
&lt;h3 id=&#34;11-路由组的使用&#34;&gt;1.1 路由组的使用&lt;/h3&gt;
&lt;p&gt;在实际开发中，我们通常都是按照模块进行开发，同一模块的不同接口url往往是最后的一级url不同，具有相同的前缀url。因此，我们期望在后台开发中，可以按照模块来进行处理我们的请求，对于这种需求，iris框架也是支持的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;usersRouter := app.Party(&amp;quot;/admin&amp;quot;, userMiddleware)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上述代码所示，iris框架中使用app.Party方法来对请求进行分组处理，第二个参数是处理路由组的中间件方法，通常情况下我们会在中间件中写context.Next()方法。&lt;/p&gt;
&lt;h3 id=&#34;12-应用程序内代码配置&#34;&gt;1.2 应用程序内代码配置&lt;/h3&gt;
&lt;p&gt;在iris框架开发中，初始化应用程序时已经使用了默认的配置值。作为开发者，我们可以不需要其他额外的配置就启动我们的应用程序。
如果开发者想要自己根据自己的需求进行配置，iris框架也是支持的，本节课我们来学习一下iris框架所支持的配置方式。
现在主流的配置文件格式有：xml、yaml、 cnf、toml、json等等格式。xml现在使用的已经不多，cnf格式的配置文件适合数据库的配置文件，在本节内容中，我们将带大家学习多种配置文件的使用方法。
在iris程序的全局app实例中，支持通过多种方式进行代码配置，途径是多样的：&lt;/p&gt;
&lt;h4 id=&#34;121-appconfigure&#34;&gt;1.2.1 app.Configure&lt;/h4&gt;
&lt;p&gt;通过app.Configure(iris.WithConfiguration(iris.Configuration{DisableStartuplog:false}))来对整体应用进行配置项配置。&lt;/p&gt;
&lt;h4 id=&#34;122-apprun&#34;&gt;1.2.2 app.Run&lt;/h4&gt;
&lt;p&gt;通过app.Run方法的第二个参数来进行相关的自定义配置项的配置，第二个参数的类型同1一致。&lt;br&gt;
以上两种方式，无论哪种方式，都是对app服务应用进行Configuration配置，提供应用配置的Configuration结构体定义所支持的配置项分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DisableInterruptHandler：如果设置为true，当人为中断程序执行时，则不会自动正常将服务器关闭。如果设置为true，需要自己自定义处理。默认为false。&lt;/li&gt;
&lt;li&gt;DisablePathCorrection： 该配置项表示更正并将请求的路径重定向到已注册的路径。比如：如果请求/home/ 但找不到此Route的处理程序，然后路由器检查/home处理程序是否存在，如果是，（permant）将客户端重定向到正确的路径/home。默认为false。&lt;/li&gt;
&lt;li&gt;EnablePathEscape：该配置选项用于配置是否支持路径转义。适用于请求url中包含转义字符时进行配置。默认为false。&lt;/li&gt;
&lt;li&gt;FireMethodNotAllowed： 默认为false。&lt;/li&gt;
&lt;li&gt;DisableBodyConsumptionOnUnmarshal：该设置选项用于配置读取请求数据的方法是否使用，如果设置为true，则表示禁用context.UnmarshalBody，context. ReadJSON以及context.ReadXML。默认为false。&lt;/li&gt;
&lt;li&gt;DisableAutoFireStatusCode：该配置变量为控制是否处理错误自动执行，如果为true，则不会进行错误自动执行。该配置项默认为false。&lt;/li&gt;
&lt;li&gt;TimeFormat：时间格式。默认格式为：&amp;quot;Mon, 02 Jan 2006 15:04:05 GMT&amp;quot;&lt;/li&gt;
&lt;li&gt;Charset：字体格式选项。默认字体为：&amp;quot;UTF-8&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-通过toml配置文件进行配置&#34;&gt;1.3 通过TOML配置文件进行配置&lt;/h3&gt;
&lt;h4 id=&#34;131-什么是toml&#34;&gt;1.3.1 什么是toml？&lt;/h4&gt;
&lt;p&gt;toml是Tom’s Obvious, Minimal Language的缩写， toml是一种配置文件。TOML是前GitHub CEO， Tom Preston-Werner，于2013年创建的语言，其目标是成为一个小规模的易于使用的语义化配置文件格式。TOML被设计为可以无二义性的转换为一个哈希表(Hash table)。&lt;/p&gt;
&lt;h4 id=&#34;132-toml文件配置&#34;&gt;1.3.2 toml文件配置&lt;/h4&gt;
&lt;p&gt;具体的项目配置使用中，我们需要创建config.tml类型的配置文件，并在程序中明确使用toml文件进行读取配置内容。如下图所所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app.Configure(iris.WithConfiguration(iris.TOML(&amp;quot;./configs/iris.tml&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14-通过yaml配置文件&#34;&gt;1.4 通过YAML配置文件&lt;/h3&gt;
&lt;p&gt;YAML 是专门用来写配置文件的语言，写法简洁、功能强大，比JSON格式还要方便。Yaml实质上是一种通用的数据串行化格式。Yaml的主要语法格式有以下几项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大小写敏感。&lt;/li&gt;
&lt;li&gt;使用缩进表示层级关系。&lt;/li&gt;
&lt;li&gt;缩进时不允许使用Tab键，只允许使用空格。&lt;/li&gt;
&lt;li&gt;缩进的空格数目不受限制，相同层级的配置元素	左侧对齐即可。
在本节内容中，我们可以通过yaml配置文件来对应用进行简单选项的的配置：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;app.Configure(iris.WithConfiguration(iris.))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;15-通过读取自定义配置文件&#34;&gt;1.5 通过读取自定义配置文件&lt;/h3&gt;
&lt;p&gt;这里我们给大家演示如何使用json格式的配置文件来进行应用的配置，然后从应用程序中进行读取。&lt;/p&gt;
&lt;h4 id=&#34;151-自定义json文件&#34;&gt;1.5.1 自定义json文件&lt;/h4&gt;
&lt;p&gt;首先创建json格式的配置文件，并编写配置项，如下图：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;appname&amp;quot;: &amp;quot;IrisDemo&amp;quot;,
  &amp;quot;port&amp;quot;: 8000
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;152-配置文件读取&#34;&gt;1.5.2 配置文件读取&lt;/h4&gt;
&lt;p&gt;在应用程序内，编程实现对配置文件的读取和解析，如下图：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;file, _ := os.Open(&amp;quot;/Users/hongweiyu/go/src/irisDemo/5-路由组及Iris配置/config.json&amp;quot;)
defer file.Close()
decoder := json.NewDecoder(file)
conf := Coniguration{}
err := decoder.Decode(&amp;amp;conf)
if err != nil {
	fmt.Println(&amp;quot;Error:&amp;quot;, err)
}
fmt.Println(conf.Port)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本节课我们带大家学习了在iris框架中如何使用路由组和对应用进行相关的配置的内容，本节课学习的内容我们在实战项目中都能能够用到。&lt;/p&gt;
&lt;h2 id=&#34;二-mvc包使用&#34;&gt;二 MVC包使用&lt;/h2&gt;
&lt;p&gt;在Iris框架中，封装了mvc包作为对mvc架构的支持，方便开发者遵循mvc的开发原则进行开发。
iris框架支持请求数据、模型、持久数据分层处理，并支持各层级模块代码绑定执行。
MVC即：model、view、controller三个部分，分别代表数据层、视图层、控制层。控制器层负责完成页面逻辑、实体层负责完成数据准备与数据操作、视图层负责展现UI效果。
在iris框架中，用一张图表示前端请求、服务端处理请求、服务端返回数据到前端的请求过程图，描述如下：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190806-151655@2x.png&#34; alt=&#34;Iris框架mvc请求过程&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;21-mvcapplication&#34;&gt;2.1 mvc.Application&lt;/h3&gt;
&lt;p&gt;iris框架中的mvc包中提供了Application结构体定义。开发者可以通过注册自定义的controller来使用对应提供的API，其中包含路由组router.Party,以此用来注册layout、middleware以及相应的handlers等。&lt;/p&gt;
&lt;h3 id=&#34;22-irismvc特性&#34;&gt;2.2 iris.mvc特性&lt;/h3&gt;
&lt;p&gt;iris框架封装的mvc包，支持所有的http方法。比如，如果想要提供GET，那么控制器应该有一个名为Get（）的函数，开发者可以定义多个方法函数在同一个Controller中提供。这里的Get、Post方法是指的直接和八种请求类型同名的方法，mvc模块会自动执行到Get()、Post()等八种对应的方法。如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//自定义的控制器
type CustomController struct{}
//注册自定义控制器处理请求
mvc.New(app).Handle(new(CustomController))
//自动处理基础的Http请求
//Url： http://localhost:8000
//Type：GET请求
func (cc *CustomController) Get() mvc.Result{
    //todo
    return mvc.Response{
        ContentType:&amp;quot;text/html&amp;quot;,
    }
}
/**
 * Url：http://localhost:8000
 * Type：POST
 **/
func (cc *CustomController) Post() mvc.Result{
    //todo
    return mvc.Response{}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-根据请求类型和请求url自动匹配处理方法&#34;&gt;2.3 根据请求类型和请求URL自动匹配处理方法&lt;/h3&gt;
&lt;p&gt;在iris框架中的mvc设计包中，设定了自定义的控制器以后，支持根据请求类型和对应的URL自动匹配对应的处理方法。具体案例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * url：http://localhost:8000/info
 * type：GET请求
 **/
func (cc *CustomController) GetInfo() mvc.Result{
    //todo
}

/**
 * url：http://localhost:8000/login
 * type：POST
 **/
func (cc *CustomController) PostLogin() mvc.Result{
    //todo
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上案例，当我们发起请求时，iris框架就能够自动匹配对应的控制器的处理方法。除了上述get和post两个方法之外，http请求的八种类型中的其他请求类型，也支持自动匹配。&lt;/p&gt;
&lt;h3 id=&#34;24-beforeactivation方法&#34;&gt;2.4 BeforeActivation方法&lt;/h3&gt;
&lt;p&gt;在通过Configure和Handle进行了自定义Controller绑定以后，就可以使用自己自定义的Controller来进行自定义处理处理请求方法。开发者可以在BeforeActivation方法中来处理请求定义。如下所示，我们给出案例说明：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func （m *CustomController） BeforeActivation(a mvc.BeforeActivation){
    a.Handle(&amp;quot;GET&amp;quot;,&amp;quot;/users/info&amp;quot;,&amp;quot;QueryInfo&amp;quot;)
}
//对应处理请求的方法
func (m *CustomController) QueryInfo() mvc.Result{
    //todo
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;25-使用mvcconfigure配置路由组和控制器&#34;&gt;2.5 使用mvc.Configure配置路由组和控制器&lt;/h3&gt;
&lt;p&gt;除了使用mvc.new(app)来构建mvc.Application结构体对象和Handle方法来配置处理请求的控制器外，iris框架还支持使用mvc.Configure来配置路由组和控制器的设置。具体使用方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mvc.Configure(app.Party(&amp;quot;/user&amp;quot;), func(mvc *mvc.Application) {
		mvc.Handle(new(UserController))
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本节课中我们学习了mvc包中控制器极其处理方法的基本用法，在实战项目中，我们会在本节课学习内容的基础上，继续深入学习更详细的操作。&lt;/p&gt;
&lt;h2 id=&#34;三-session的使用和控制&#34;&gt;三 Session的使用和控制&lt;/h2&gt;
&lt;p&gt;在实际的项目开发中，我们会经常有业务场景使用到Session功能。在iris框架中，也为我们提供了方便使用，功能齐全的Session模块。Session模块的源码目录为kataras/iris/sessions包。&lt;/p&gt;
&lt;h3 id=&#34;31-session与cookie的区别&#34;&gt;3.1 Session与Cookie的区别&lt;/h3&gt;
&lt;p&gt;在学习web开发过程中，我们总会和session和cookie打交道。本节课我们学习sesion相关的知识，因此有必要先通过讲解对比一下session和cookie的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先是两者的相同点。session和cookie两者都是用来存储客户的状态信息的手段。在登录、注册等动作后，可以存储相关账户的状态信息，方便程序后续跟踪及使用。&lt;/li&gt;
&lt;li&gt;其次是不同点，讨论两者的不同点我们从几个角度来总结。首先是两者的存储位置。Cookie是存储在客户端浏览器上，方便客户端请求时使用；Session存储的相关信息存储在服务器端，用于存储客户端连接的状态信息。&lt;/li&gt;
&lt;li&gt;其次，从可以存储的数据类型来看。Cookie仅仅支持存储字符串string一种数据类型，Session支持int、string、bool等多种数据类型，Session支持的数据类型更全更多。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-session对象创建&#34;&gt;3.2 Session对象创建&lt;/h3&gt;
&lt;p&gt;在实际的程序开发中，iris框架中可以非常方便的创建一个新的session对象。如下所示，即是session的创建：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...
sessionID := &amp;quot;mySession&amp;quot;
//session的创建
sess := sessions.New(sessions.Config{
		Cookie: sessionID,
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;33-支持的数据类型&#34;&gt;3.3 支持的数据类型&lt;/h3&gt;
&lt;p&gt;在上文中，我们说过session支持的数据类型要比cookie多，我们来看一下iris框架中的session所支持存储的数据类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//String：字符串类型
session.GetString()
//Int：无符号整形 及系列相关单位的同类型
session.GetInt()
//Boolean：布尔值类型
session.GetBoolean()
//Float：单精度数值类型 及系列相关单位的同类型
session.GetFloat()
//interface{}：接口 即任意数据结构类型
session.GetFlash()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码块，即列出了iris框架中所支持存储的数据类型。我们在接下来的本节课程内容中，将会演示如何进行具体使用。&lt;/p&gt;
&lt;h3 id=&#34;34-session的使用&#34;&gt;3.4 Session的使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...
session := sess.Start(ctx)
session.Set(&amp;quot;key&amp;quot;, &amp;quot;helloworld&amp;quot;)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四-实战项目资源导入和项目框架搭建&#34;&gt;四 实战项目资源导入和项目框架搭建&lt;/h2&gt;
&lt;p&gt;从本节内容开始，我们将利用我们所学习的Iris框架的相关知识，进行实战项目开发。&lt;/p&gt;
&lt;h3 id=&#34;41-实战项目框架搭建&#34;&gt;4.1 实战项目框架搭建&lt;/h3&gt;
&lt;p&gt;我们的实战项目是使用Iris框架开发一个关于本地服务平台的后台管理平台。平台中可以管理用户、商品、商铺等相关的信息，平台可以实时展示用户、商品等相关监测数据的变化情况。通过此项目，旨在能够将Iris框架相关的知识得到巩固和练习。
如下是项目框架搭建后的说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;config：项目配置文件及读取配置文件的相关功能&lt;/li&gt;
&lt;li&gt;controller：控制器目录、项目各个模块的控制器及业务逻辑处理的所在目录&lt;/li&gt;
&lt;li&gt;datasource：实现mysql连接和操作、封装操作mysql数据库的目录。&lt;/li&gt;
&lt;li&gt;model：数据实体目录，主要是项目中各业务模块的实体对象的定义&lt;/li&gt;
&lt;li&gt;service：服务层目录。用于各个模块的基础功能接口定义及实现，是各个模块的数据层。&lt;/li&gt;
&lt;li&gt;static：配置项目的静态资源目录。&lt;/li&gt;
&lt;li&gt;util：提供通用的方法封装。&lt;/li&gt;
&lt;li&gt;main.go：项目程序主入口&lt;/li&gt;
&lt;li&gt;config.json：项目配置文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42-项目资源导入&#34;&gt;4.2 项目资源导入&lt;/h3&gt;
&lt;p&gt;因为我们实战的项目开发主要是实现服务器端的功能开发和Iris框架的知识练习，因此我们将注重在后台功能开发上，对于前端的页面和一些布局效果，我们不做深入研究，只需要会使用，会调试即可。
因此，在该项目中，我们从外部导入的资源主要是前端的一些资源。前端框架采用Vue编写，我们在此项目中直接将编译后的js文件、css文件等相关的文件导入到实战项目中，全部存放于static目录中，如下图所示：
&lt;img src=&#34;http://www.songx.fun/img/png/resouce_import.jpg&#34; alt=&#34;资源导入&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E6%A1%86%E6%9E%B6/">框架</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Protocol buffer</title>
                <link>http://www.songx.fun/blog/day77protobuf/day77_protobuf%E4%BB%8B%E7%BB%8D/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day77protobuf/day77_protobuf%E4%BB%8B%E7%BB%8D/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;protocol-buffer&#34;&gt;Protocol buffer&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一protobuf简介&#34;&gt;一、Protobuf简介&lt;/h2&gt;
&lt;h3 id=&#34;11rpc-通信&#34;&gt;1.1、RPC 通信&lt;/h3&gt;
&lt;p&gt;对于单独部署，独立运行的微服务实例而言，在业务需要时，需要与其他服务进行通信，这种通信方式是进程之间的通讯方式（inter-process communication，简称IPC）。&lt;/p&gt;
&lt;p&gt;前文已经描述过，IPC有两种实现方式，分别为：&lt;strong&gt;同步过程调用、异步消息调用&lt;/strong&gt;。在同步过程调用的具体实现中，有一种实现方式为RPC通信方式，远程过程调用（英语：Remote Procedure Call，缩写为 RPC）。&lt;/p&gt;
&lt;p&gt;远程过程调用（英语：Remote Procedure Call，缩写为RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，例：Java RMI。**简单地说就是能使应用像调用本地方法一样的调用远程的过程或服务。**很显然，这是一种client-server的交互形式，调用者(caller)是client,执行者(executor)是server。典型的实现方式就是request–response通讯机制。&lt;/p&gt;
&lt;h3 id=&#34;12rpc-实现步骤&#34;&gt;1.2、RPC 实现步骤&lt;/h3&gt;
&lt;p&gt;一个正常的RPC过程可以分为一下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、client调用client stub，这是一次本地过程调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做marshalling。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、client所在的系统将消息发送给server。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4、server的的系统将收到的包传给server stub。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5、server stub解包得到参数。 解包也被称作 unmarshalling。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;6、server stub调用服务过程。返回结果按照相反的步骤传给client。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上述的步骤实现远程接口调用时，所需要执行的函数是存在于远程机器中，即函数是在另外一个进程中执行的。因此，就带来了几个新问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**1、Call ID映射。**远端进程中间可以包含定义的多个函数，本地客户端该如何告知远端进程程序调用特定的某个函数呢？因此，在RPC调用过程中，所有的函数都需要有一个自己的ID。开发者在客户端（调用端）和服务端（被调用端）分别维护一个{函数&amp;lt;--&amp;gt;Call ID}的对应表。两者的表不一定完全相同，但是相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，调用者通过映射表查询想要调用的函数的名称，找到对应的Call ID，然后传递给服务端，服务端也通过查表，来确定客户端所需要调用的函数，然后执行相应函数的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**2、序列化与反序列化。**客户端如何把参数传递给远程调用的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**3、网络传输。**远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传递给服务端，然后在把序列化后的调用结果传回给客户端，完成这种数据传递功能的被成为传输层。大部分的网络传输成都使用TCP协议，属于长连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上述步骤实现中，可以看到其中有对传递的数据进行序列化和反序列化的操作，这就是我们本节内容开始要学习的内容：&lt;strong&gt;Protobuf&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;13protobuf简介&#34;&gt;1.3、Protobuf简介&lt;/h3&gt;
&lt;p&gt;Google Protocol Buffer( 简称 Protobuf)是Google公司内部的混合语言数据标准，他们主要用于RPC系统和持续数据存储系统。&lt;/p&gt;
&lt;h3 id=&#34;14protobuf应用场景&#34;&gt;1.4、Protobuf应用场景&lt;/h3&gt;
&lt;p&gt;Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或RPC数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。&lt;/p&gt;
&lt;p&gt;简单来说，Protobuf的功能类似于XML，即负责把某种数据结构的信息，以某种格式保存起来。主要用于数据存储、传输协议等使用场景。&lt;/p&gt;
&lt;p&gt;为什么已经有了XLM，JSON等已经很普遍的数据传输方式，还要设计出Protobuf这样一种新的数据协议呢？&lt;/p&gt;
&lt;h3 id=&#34;15protobuf-优点&#34;&gt;1.5、Protobuf 优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能好/效率高&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间维度：采用XML格式对数据进行序列化时，时间消耗上性能尚可；对于使用XML格式对数据进行反序列化时的时间花费上，耗时长，性能差。&lt;/li&gt;
&lt;li&gt;空间维度：XML格式为了保持较好的可读性，引入了一些冗余的文本信息。所以在使用XML格式进行存储数据时，也会消耗空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整体而言，Protobuf以高效的二进制方式存储，比XML小3到10倍，快20到100倍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码生成机制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码生成机制的含义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Go语言中，可以通过定义结构体封装描述一个对象，并构造一个新的结构体对象。比如定义Person结构体，并存放于Person.go文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Person struct{
    Name string
    Age int
    Sex int
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在分布式系统中，因为程序代码时分开部署，比如分别为A、B。A系统在调用B系统时，无法直接采用代码的方式进行调用，因为A系统中不存在B系统中的代码。因此，A系统只负责将调用和通信的数据以二进制数据包的形式传递给B系统，由B系统根据获取到的数据包，自己构建出对应的数据对象，生成数据对象定义代码文件。这种利用编译器，根据数据文件自动生成结构体定义和相关方法的文件的机制被称作代码生成机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码生成机制的优点&lt;/strong&gt;
首先，代码生成机制能够极大解放开发者编写数据协议解析过程的时间，提高工作效率；其次，易于开发者维护和迭代，当需求发生变更时，开发者只需要修改对应的数据传输文件内容即可完成所有的修改。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支持“向后兼容”和“向前兼容”&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**向后兼容：**在软件开发迭代和升级过程中，&amp;quot;后&amp;quot;可以理解为新版本，越新的版本越靠后；而“前”意味着早起的版本或者先前的版本。向“后”兼容即是说当系统升级迭代以后，仍然可以处理老版本的数据业务逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**向前兼容：**向前兼容即是系统代码未升级，但是接受到了新的数据，此时老版本生成的系统代码可以处理接收到的新类型的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;支持前后兼容是非常重要的一个特点，在庞大的系统开发中，往往不可能统一完成所有模块的升级，为了保证系统功能正常不受影响，应最大限度保证通讯协议的向前兼容和向后兼容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支持多种编程语言&lt;/strong&gt;
Protobuf不仅仅Google开源的一个数据协议，还有很多种语言的开源项目实现。在Google官方发布的Protobuf的源代码中包含了C++、Java、Python三种语言。本系列课程中，我们学习如何实现Golang语言中的功能实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;16protobuf-缺点&#34;&gt;1.6、Protobuf 缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可读性较差&lt;/strong&gt;
为了提高性能，Protobuf采用了二进制格式进行编码。二进制格式编码对于开发者来说，是没办法阅读的。在进行程序调试时，比较困难。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;缺乏自描述&lt;/strong&gt;
诸如XML语言是一种自描述的标记语言，即字段标记的同时就表达了内容对应的含义。而Protobuf协议不是自描述的，Protobuf是通过二进制格式进行数据传输，开发者面对二进制格式的Protobuf，没有办法知道所对应的真实的数据结构，因此在使用Protobuf协议传输时，必须配备对应的proto配置文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二protobuf在go语言中的编程实现&#34;&gt;二、Protobuf在Go语言中的编程实现&lt;/h2&gt;
&lt;p&gt;Go语言中有对应的实现Protobuf协议的库，Github地址：&lt;a href=&#34;https://github.com/golang/protobuf&#34;&gt;https://github.com/golang/protobuf&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;21环境准备&#34;&gt;2.1、环境准备&lt;/h3&gt;
&lt;p&gt;使用Go语言的Protobuf库之前，需要相应的环境准备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1、安装protobuf编译器。&lt;/strong&gt;
可以在如下地址：&lt;a href=&#34;https://github.com/protocolbuffers/protobuf/releases&#34;&gt;https://github.com/protocolbuffers/protobuf/releases&lt;/a&gt;选择适合自己系统的Proto编译器程序进行下载并解压，如图：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190605-095735@2x.png&#34; alt=&#34;Protoc编译器&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2、配置环境变量&lt;/strong&gt;
protoc编译器正常运行需要进行环境变量配置，将protocke执行文件所在目录添加到当前系统的环境变量中。windows系统下可以直接在Path目录中进行添加；macOS系统下可以将protoc可执行文件拷贝至**/usr/local/include**目录下。具体的对应的系统的环境变量配置可以阅读解压后与bin目录同级的readme.txt的文件内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22安装&#34;&gt;2.2、安装&lt;/h3&gt;
&lt;p&gt;通过如下命令安装protoc-gen-go库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go get github.com/golang/protobuf/protoc-gen-go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/protobuf.png&#34; alt=&#34;protoc安装后&#34;&gt;&lt;/p&gt;
&lt;p&gt;安装完成以后，protoc-gen-go*可执行文件在本地环境GOPATH/bin目录下，如下图所示：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190604-155039@2x.png&#34; alt=&#34;protoc-gen-go执行文件&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;23protobuf-协议语法&#34;&gt;2.3、Protobuf 协议语法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Protobuf 协议的格式&lt;/strong&gt;
Protobuf协议规定：使用该协议进行数据序列化和反序列化操作时，首先定义传输数据的格式，并命名为以**&amp;quot;.proto&amp;quot;**为扩展名的消息定义文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;message 定义一个消息&lt;/strong&gt;
先来看一个非常简单的例子。假设想定义一个“订单”的消息格式，每一个“订单&amp;quot;都含有一个订单号ID、订单金额Num、订单时间TimeStamp字段。可以采用如下的方式来定义消息类型的.proto文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;message Order{
    required string order_id = 1;
    required int64 num = 2;
    optional int32 timestamp = 3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Order消息格式有3个字段，在消息中承载的数据分别对应每一个字段。其中每个字段都有一个名字和一种类型。
* **指定字段类型：**在proto协议中，字段的类型包括字符串（string)、整形（int32、int64...）、枚举（enum）等数据类型
* **分配标识符：**在消息字段中，每个字段都有唯一的一个标识符。最小的标识号可以从1开始，最大到536870911。不可以使用其中的[19000－19999]的标识号， Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。
* **指定字段规则：**字段的修饰符包含三种类型，分别是：
* **required：**一个格式良好的消息一定要含有1个这种字段。表示该值是必须要设置的；
* **optional：**消息格式中该字段可以有0个或1个值（不超过1个）。
* **repeated：**在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。表示该值可以重复，相当于Go中的slice。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;**【注意：】使用required弊多于利；在实际开发中更应该使用optional和repeated而不是required。**
* 添加更多消息类型
在同一个.proto文件中，可以定义多个消息类型。多个消息类型分开定义即可。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;24使用protobuf的步骤&#34;&gt;2.4、使用Protobuf的步骤&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、创建扩展名为**.proto**的文件，并编写代码。比如创建person.proto文件，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;syntax = &amp;quot;proto2&amp;quot;;
package example;

message Person {
    required string Name = 1;
    required int32 Age = 2;
    required string From = 3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、编译.proto文件，生成Go语言文件。执行如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protoc --go_out = . test.proto
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行 protoc --go_out=. test.proto 生成对应的 person.pb.go 文件。并构建对应的example目录，存放生成的person.pb.go文件。
&lt;img src=&#34;http://7xtcwd.com1.z0.glb.clouddn.com/WX20190605-101438@2x.png&#34; alt=&#34;Proto生成Go语言&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;3、在程序中使用Protobuf
在程序中有如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;ProtocDemo/example&amp;quot;
	&amp;quot;github.com/golang/protobuf/proto&amp;quot;
	&amp;quot;os&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;func main() {
fmt.Println(&amp;quot;Hello World. \n&amp;quot;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;msg_test := &amp;amp;example.Person{
	Name: proto.String(&amp;quot;Davie&amp;quot;),
	Age:  proto.Int(18),
	From: proto.String(&amp;quot;China&amp;quot;),
}

//序列化
msgDataEncoding, err := proto.Marshal(msg_test)
if err != nil {
	panic(err.Error())
	return
}

msgEntity := example.Person{}
err = proto.Unmarshal(msgDataEncoding, &amp;amp;msgEntity)
if err != nil {
	fmt.Println(err.Error())
	os.Exit(1)
	return
}

fmt.Printf(&amp;quot;姓名：%s\n\n&amp;quot;, msgEntity.GetName())
fmt.Printf(&amp;quot;年龄：%d\n\n&amp;quot;, msgEntity.GetAge())
fmt.Printf(&amp;quot;国籍：%s\n\n&amp;quot;, msgEntity.GetFrom())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;3、执行程序&lt;/strong&gt;
&lt;img src=&#34;http://7xtcwd.com1.z0.glb.clouddn.com/WX20190605-102000@2x.png&#34; alt=&#34;运行程序&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三protobuf-协议语法与原理实现&#34;&gt;三、Protobuf 协议语法与原理实现&lt;/h2&gt;
&lt;h3 id=&#34;31protobuf-协议语法&#34;&gt;3.1、Protobuf 协议语法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;message：&lt;/strong&gt;
Protobuf中定义一个数据结构需要用到关键字message，这一点和Java的class，Go语言中的struct类似。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标识号：&lt;/strong&gt;
在消息的定义中，每个字段等号后面都有唯一的标识号，用于在反序列化过程中识别各个字段的，一旦开始使用就不能改变。标识号从整数1开始，依次递增，每次增加1，标识号的范围为1~2^29 - 1，其中[19000-19999]为Protobuf协议预留字段，开发者不建议使用该范围的标识号；一旦使用，在编译时Protoc编译器会报出警告。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字段规则：&lt;/strong&gt;
字段规则有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、required：该规则规定，消息体中该字段的值是必须要设置的。&lt;/li&gt;
&lt;li&gt;2、optional：消息体中该规则的字段的值可以存在，也可以为空，optional的字段可以根据defalut设置默认值。&lt;/li&gt;
&lt;li&gt;repeated：消息体中该规则字段可以存在多个（包括0个），该规则对应java的数组或者go语言的slice。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据类型：&lt;/strong&gt;
常见的数据类型与protoc协议中的数据类型映射如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;.proto类型&lt;/th&gt;
&lt;th&gt;Java类型&lt;/th&gt;
&lt;th&gt;C++类型&lt;/th&gt;
&lt;th&gt;Go语言类型&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;float64&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;float32&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int32&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;int32&lt;/td&gt;
&lt;td&gt;可变长编码方式。编码负数时不够高效，如果字段可能包含负数，可以使用sint32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int64&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;int64&lt;/td&gt;
&lt;td&gt;int64&lt;/td&gt;
&lt;td&gt;可变长编码方式。编码负数时不够高效，如果字段可能包含负数，使用sint64。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;int[1]&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sint32&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;int32&lt;/td&gt;
&lt;td&gt;int32&lt;/td&gt;
&lt;td&gt;可变长编码方式，有符号的整形值。编码时比int32效率高。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sint64&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;int64&lt;/td&gt;
&lt;td&gt;int64&lt;/td&gt;
&lt;td&gt;可变长编码方式，有符号的整形值，编码时比int64效率高。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fixed32&lt;/td&gt;
&lt;td&gt;int[1]&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;总是4个字节。如果所有数值均比（2^28)大，该种编码方式比uint32高效。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fixed64&lt;/td&gt;
&lt;td&gt;long[1]&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;总是8个字节。如果所有数值均比（2^56)大，此种编码方式比uint64高效。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sfixed32&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;int32&lt;/td&gt;
&lt;td&gt;总是4个字节。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sfixed64&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;int64&lt;/td&gt;
&lt;td&gt;总是8个字节。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;枚举类型：&lt;/strong&gt;
proto协议支持使用枚举类型，和正常的编程语言一样，枚举类型可以使用enum关键字定义在.proto文件中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;enum Age{
    male=1;
    female=2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字段默认值：&lt;/strong&gt;
.proto文件支持在进行message定义时设置字段的默认值，可以通过&lt;strong&gt;default&lt;/strong&gt;进行设置，如下所示：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;message Address {
        required sint32 id = 1 [default = 1];
        required string name = 2 [default = &#39;北京&#39;];
        optional string pinyin = 3 [default = &#39;beijing&#39;];
        required string address = 4;
        required bool flag = 5 [default = true];
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;导入：&lt;/strong&gt;
如果需要引用的message是写在别的.proto文件中，可以通过import &amp;quot;xxx.proto&amp;quot;来进行引入：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;嵌套：&lt;/strong&gt;
message与message之间可以嵌套定义，比如如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;syntax = &amp;quot;proto2&amp;quot;;
package example;
message Person {
    required string Name = 1;
    required int32 Age = 2;
    required string From = 3;
    optional Address Addr = 4;
    message Address {
        required sint32 id = 1;
        required string name = 2;
        optional string pinyin = 3;
        required string address = 4;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;message更新规则：&lt;/strong&gt;
message定义以后如果需要进行修改，为了保证之前的序列化和反序列化能够兼容新的message，message的修改需要满足以下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不可以修改已存在域中的标识号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有新增添的域必须是 optional 或者 repeated。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非required域可以被删除。但是这些被删除域的标识号不可以再次被使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非required域可以被转化，转化时可能发生扩展或者截断，此时标识号和名称都是不变的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sint32和sint64是相互兼容的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fixed32兼容sfixed32。 fixed64兼容sfixed64。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;optional兼容repeated。发送端发送repeated域，用户使用optional域读取，将会读取repeated域的最后一个元素。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Protobuf 序列化后所生成的二进制消息非常紧凑，这得益于 Protobuf 采用的非常巧妙的 Encoding 方法。接下来看一看Protobuf协议是如何实现高效编码的。&lt;/p&gt;
&lt;h3 id=&#34;32protobuf序列化原理&#34;&gt;3.2、Protobuf序列化原理&lt;/h3&gt;
&lt;p&gt;之前已经做过描述，Protobuf的message中有很多字段，每个字段的格式为：**修饰符 字段类型 字段名 = 域号; **&lt;/p&gt;
&lt;h4 id=&#34;321varint&#34;&gt;3.2.1、Varint&lt;/h4&gt;
&lt;p&gt;Varint是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。&lt;/p&gt;
&lt;p&gt;Varint中的每个byte的最高位bit有特殊的含义，如果该位为1，表示后续的byte也是该数字的一部分，如果该位为0，则结束。其他的7个bit都用来表示数字。因此小于128的数字都可以用一个byte表示。大于128的数字，比如300，会用两个字节来表示：1010 1100 0000 0010。下图演示了 Google Protocol Buffer 如何解析两个bytes。注意到最终计算前将两个byte的位置相互交换过一次，这是因为 Google Protocol Buffer 字节序采用little-endian的方式。
&lt;img src=&#34;http://www.songx.fun/img/png/121732zuyzkxzxjkwwjkx5.jpg&#34; alt=&#34;小端位序排列的Varint编码&#34;&gt;&lt;/p&gt;
&lt;p&gt;在序列化时，Protobuf按照TLV的格式序列化每一个字段，T即Tag，也叫Key；V是该字段对应的值value；L是Value的长度，如果一个字段是整形，这个L部分会省略。&lt;/p&gt;
&lt;p&gt;序列化后的Value是按原样保存到字符串或者文件中，Key按照一定的转换条件保存起来，序列化后的结果就是 KeyValueKeyValue…依次类推的样式，示意图如下所示：
&lt;img src=&#34;http://www.songx.fun/img/png/121758l5mln3mnvpvc4mzw.jpg&#34; alt=&#34;序列化格式&#34;&gt;&lt;/p&gt;
&lt;p&gt;采用这种Key-Pair结构无需使用分隔符来分割不同的Field。对于可选的Field，如果消息中不存在该field，那么在最终的Message Buffer中就没有该field，这些特性都有助于节约消息本身的大小。比如，我们有消息order1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Order.id = 10;
Order.desc = &amp;quot;bill&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;则最终的 Message Buffer 中有两个Key-Value对，一个对应消息中的id；另一个对应desc。Key用来标识具体的field，在解包的时候，Protocol Buffer根据Key就可以知道相应的Value应该对应于消息中的哪一个field。&lt;/p&gt;
&lt;p&gt;Key 的定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(field_number &amp;lt;&amp;lt; 3) | wire_type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到 Key 由两部分组成。第一部分是 field_number，比如消息lm.helloworld中field id 的field_number为1。第二部分为wire_type。表示 Value的传输类型。而wire_type有以下几种类型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190606-174515@2x.png&#34; alt=&#34;wire_type类型&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/protobuf/">Protobuf</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>RESTful API设计标准和实践</title>
                <link>http://www.songx.fun/blog/day86restful%E8%AE%BE%E8%AE%A1/day86_restful%E6%A0%87%E5%87%86%E8%AE%BE%E8%AE%A1/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day86restful%E8%AE%BE%E8%AE%A1/day86_restful%E6%A0%87%E5%87%86%E8%AE%BE%E8%AE%A1/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;restful-api设计标准和实践&#34;&gt;RESTful API设计标准和实践&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;在之前的几节课程中，已经介绍了go-micro的一些核心功能和核心机制。实现的都是着重于微服务之间。在实际的开发过程中，需要微服务仅仅是作为后台程序进行部署，需要整体向web前端用户端产品提供交互和数据。因此，我们来看看如何微服务如何与web进行交互。&lt;/p&gt;
&lt;h2 id=&#34;划分调用范围&#34;&gt;划分调用范围&lt;/h2&gt;
&lt;p&gt;在整体的系统架构中，我们会将系统分为前台和后台。前台负责与用户交互，展示数据，执行操作。后台负责业务逻辑处理，数据持久化等操作。在系统运行过程中，前台和后台，后台和后台都可能发生功能调用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内部调用：后台各个微服务之间的互相调用，属于系统后台内部的调用,称之为内部调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外部调用：前台与后台的接口请求调用，通常被城之外外部调用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;技术选型&#34;&gt;技术选型&lt;/h2&gt;
&lt;p&gt;在开发实践中，我们对于外部调用和内部调用所采用的技术方案会有所不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RPC调用：后台各个服务之间内部的互相调用，为了实现高效率的服务的交互，通常采用RPC的方式进行实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REST：对于前端客户端通过HTTP接口，与后台交互的场景。因为涉及到对不同资源的管理和操作，因此往往采用RESTful标准进行实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;go-micro-api网关&#34;&gt;Go-Micro API网关&lt;/h2&gt;
&lt;p&gt;Micro框架中有API网关的功能。API网关的作用是为微服务做代理，负责将微服务的RPC方法代理成支持HTTP协议的web请求，同时将用户端使用的URL进行暴露。&lt;/p&gt;
&lt;h3 id=&#34;安装micro工具&#34;&gt;安装Micro工具&lt;/h3&gt;
&lt;p&gt;要想使用go-micro 的api网关功能。需要下载Micro源码并安装Mico。&lt;/p&gt;
&lt;h4 id=&#34;安装micro&#34;&gt;安装Micro&lt;/h4&gt;
&lt;p&gt;可以直接通过go get命令下载并安装,具体命令为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go get -u github.com/micro/micro
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在使用go get命令下载源码和相应依赖时，国内由于网络环境的问题，可能会导致下载失败的错误。&lt;/p&gt;
&lt;p&gt;如果在安装的过程中出现连接超时的错误，可以通过手动的方式下载相应的依赖库，然后再进行手动安装。因此，解决方案分为两步：&lt;/p&gt;
&lt;h5 id=&#34;安装golang的netcrypttext等库&#34;&gt;安装golang的net、crypt、text等库&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpc  
git clone https://github.com/golang/net.git $GOPATH/src/golang.org/x/net  
git clone https://github.com/golang/text.git $GOPATH/src/golang.org/x/text  
git clone https://github.com/golang/crypto.git $GOPATH/src/golang.org/x/crypto
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用git clone命令将所需要的代码库进行下载。&lt;/p&gt;
&lt;h5 id=&#34;安装micro-1&#34;&gt;安装micro&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;go install github.com/micro/micro
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用go install命令安装micro框架，等待命令执行结束。&lt;/p&gt;
&lt;h4 id=&#34;检验micro安装成功&#34;&gt;检验Micro安装成功&lt;/h4&gt;
&lt;p&gt;micro系列工具安装成功后，可以通过命令检验查看。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;micro --version
micro version 1.9.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上，输出了micro version 1.9.1即表示micro安装成功。&lt;/p&gt;
&lt;h2 id=&#34;micro-api工作原理&#34;&gt;Micro API工作原理&lt;/h2&gt;
&lt;p&gt;micro工具提供了构建api网关服务的功能，并基于go-micro框架进行编程实现，核心作用是把RPC形式的服务代理成为支持HTTP协议的WEB API请求。&lt;/p&gt;
&lt;h2 id=&#34;运行micro-api服务&#34;&gt;运行Micro api服务&lt;/h2&gt;
&lt;p&gt;可以通过如下命令启动micro api：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;micro api
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190912-074346@2x.png&#34; alt=&#34;运行micro服务&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;反向代理的api服务启动&#34;&gt;反向代理的API服务启动&lt;/h3&gt;
&lt;p&gt;在Micro api功能中,支持多种处理请求路由的方式，我们称之为Handler。包括：API Handler、RPC Handler、反向代理、Event Handler，RPC等五种方式。在本案例中，我们使用反向代理来进行演示。&lt;/p&gt;
&lt;h4 id=&#34;反向代理&#34;&gt;反向代理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;格式：/[service]&lt;/li&gt;
&lt;li&gt;请求/响应：HTTP方式&lt;/li&gt;
&lt;li&gt;micro api启动时通过--handler=proxy设置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，反向代理形式的micro api网关服务启动命令为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;micro api --handler=http
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在本案例中，我们将micro api的反向代理和REST代表的HTTP WEB请求结合起来一起使用。&lt;/p&gt;
&lt;h2 id=&#34;安装go-restful&#34;&gt;安装go-restful&lt;/h2&gt;
&lt;p&gt;可以通过安装go-restful库来实现RESTful风格的路径映射，从而实现HTTP的WEB API服务。安装go-restful的命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go get github.com/emicklei/go-restful
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下载后，可以在当前系统目录的$GOPATH/src/github.com/emicklei/go-restful中进行查看相应的源码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们使用一个获取某个学生信息的服务为例，进行讲解micro api的编程实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;服务定义和编译&#34;&gt;服务定义和编译&lt;/h2&gt;
&lt;p&gt;定义学生消息体proto文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;syntax = &#39;proto3&#39;;

package proto;

message Student {
    string id = 1;
    string name = 2;
    int32 grade = 3;
    string classes = 4;
}

message Request {
    string name = 1;
}

service StudentService {
    rpc GetStudent (Request) returns (Student);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在proto文件中定义了Student、Request消息体和rpc服务。使用micro api网关功能，编译proto文件，需要生成micro文件。编译生成该文件需要使用到一个新的protoc-gen-micro库，安装protoc-gen-micro库命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go get github.com/micro/protoc-gen-micro
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再次编译proto文件，需要指定两个参数，分别是：go_out和micro_out，详细命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;protoc --go_out=. --micro_out=. student.proto
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述命令执行成功后，会自动生成两个go语言文件：student.pb.go和student.micro.go。&lt;/p&gt;
&lt;p&gt;micro.go文件中生成的内容包含服务的实例化，和相应的服务方法的底层实现。&lt;/p&gt;
&lt;h2 id=&#34;服务端实现&#34;&gt;服务端实现&lt;/h2&gt;
&lt;p&gt;我们都知道正常的Web服务，是通过路由处理http的请求的。在此处也是一样的，我们可以通过路由处理来解析HTTP请求的接口，service对象中包含路由处理方法。详细代码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...
type StudentServiceImpl struct {
}

//服务实现
func (ss *StudentServiceImpl) GetStudent(ctx context.Context, request *proto.Request, resp *proto.Student) error {

	//tom
	studentMap := map[string]proto.Student{
		&amp;quot;davie&amp;quot;:  proto.Student{Name: &amp;quot;davie&amp;quot;, Classes: &amp;quot;软件工程专业&amp;quot;, Grade: 80},
		&amp;quot;steven&amp;quot;: proto.Student{Name: &amp;quot;steven&amp;quot;, Classes: &amp;quot;计算机科学与技术&amp;quot;, Grade: 90},
		&amp;quot;tony&amp;quot;:   proto.Student{Name: &amp;quot;tony&amp;quot;, Classes: &amp;quot;计算机网络工程&amp;quot;, Grade: 85},
		&amp;quot;jack&amp;quot;:   proto.Student{Name: &amp;quot;jack&amp;quot;, Classes: &amp;quot;工商管理&amp;quot;, Grade: 96},
	}

	if request.Name == &amp;quot;&amp;quot; {
		return errors.New(&amp;quot; 请求参数错误,请重新请求。&amp;quot;)
	}

	//获取对应的student
	student := studentMap[request.Name]
	if student.Name != &amp;quot;&amp;quot; {
		fmt.Println(student.Name, student.Classes, student.Grade)
		*resp = student
		return nil
	}
	return errors.New(&amp;quot; 未查询当相关学生信息 &amp;quot;)
}

func main() {
	service := micro.NewService(
		micro.Name(&amp;quot;go.micro.srv.student&amp;quot;),
	)

	service.Init()
    proto.RegisterStudentServiceHandler(service.Server(), new(StudentServiceImpl))

	if err := service.Run(); err != nil {
		log.Fatal(err.Error())
	}
}
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;server程序进行服务的实现和服务的运行。&lt;/p&gt;
&lt;h2 id=&#34;rest-映射&#34;&gt;REST 映射&lt;/h2&gt;
&lt;p&gt;现在，RPC服务已经编写完成。我们需要编程实现API的代理功能，用于处理HTTP形式的请求。
在rest.go文件中，实现rest的映射，详细代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Student struct {
}

var (
	cli proto.StudentService
)

func (s *Student) GetStudent(req *restful.Request, rsp *restful.Response) {

	name := req.PathParameter(&amp;quot;name&amp;quot;)
	fmt.Println(name)
	response, err := cli.GetStudent(context.TODO(), &amp;amp;proto.Request{
		Name: name,
	})

	if err != nil {
		fmt.Println(err.Error())
		rsp.WriteError(500, err)
	}

	rsp.WriteEntity(response)
}

func main() {

	service := web.NewService(
		web.Name(&amp;quot;go.micro.api.student&amp;quot;),
	)

	service.Init()

	cli = proto.NewStudentService(&amp;quot;go.micro.srv.student&amp;quot;, client.DefaultClient)

	student := new(Student)
	ws := new(restful.WebService)
	ws.Path(&amp;quot;/student&amp;quot;)
	ws.Consumes(restful.MIME_XML, restful.MIME_JSON)
	ws.Produces(restful.MIME_JSON, restful.MIME_XML)

	ws.Route(ws.GET(&amp;quot;/{name}&amp;quot;).To(student.GetStudent))

	wc := restful.NewContainer()
	wc.Add(ws)

	service.Handle(&amp;quot;/&amp;quot;, wc)

	if err := service.Run(); err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/rpc/">RPC</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/grpc/">GRPC</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>RPC远程过程调用</title>
                <link>http://www.songx.fun/blog/day80rpc%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/day80_rpc%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day80rpc%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/day80_rpc%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;rpc远程过程调用&#34;&gt;RPC远程过程调用&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一rpc简介及原理介绍&#34;&gt;一、RPC简介及原理介绍&lt;/h2&gt;
&lt;h3 id=&#34;11背景&#34;&gt;1.1、背景&lt;/h3&gt;
&lt;p&gt;在前面的课程《Go语言微服务理论与实践课程》课程中，我们已经学习了微服务的理论知识，了解了微服务实践中需要解决哪些问题。
从本篇技术文档开始，我们进入新的微服务内容的学习。在本系列课程中，我们会着重讲框架的内容，主要包括两个：gRPC框架、go-micro框架。&lt;/p&gt;
&lt;p&gt;首先来学习gRPC框架相关的内容。&lt;/p&gt;
&lt;h3 id=&#34;12本地过程调用&#34;&gt;1.2、本地过程调用&lt;/h3&gt;
&lt;p&gt;让我们先来看看正常情况下程序的执行和调用情况。例如有如下go语言代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	var a, b int
	a = 1
	b = 2
	c := Add(a, b)
	fmt.Println(&amp;quot;计算结果:&amp;quot;, c)
}
func Add(a int, b int) int {
	return a + b
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上述的Go语言代码中，我们定义了一个Add方法用于实现两个数相加的功能，在main方法中通过调用Add方法实现了计算两个变量之和的操作。整个过程涉及到变量值入栈，出栈，赋值等操作，最后将出栈的计算结果返回并赋值给c变量。&lt;/p&gt;
&lt;p&gt;总结说来，本地程序调用的过程大致可以分为几个步骤和阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发者开发好的程序，并进行编译，编译成机器认可的可执行文件。&lt;/li&gt;
&lt;li&gt;运行可执行文件，调用对应的功能方法，期间会读取可执行文件中国的机器指令，进行入栈，出栈赋值等操作。此时，计算机由可执行程序所在的进程控制。&lt;/li&gt;
&lt;li&gt;调用结束，所有的内存数据出栈，程序执行结束。计算机继续由操作系统进行控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13问题及解决方法&#34;&gt;1.3、问题及解决方法&lt;/h3&gt;
&lt;p&gt;上文我们已经说过，远程过程调用是在两台或者多台不同的物理机器上实现的调用，其间要跨越网络进行调用。因此，我们再想通过前文本地方法调用的形式完成功能调用，就无法实现了，因为编译器无法通过编译的可执行文件来调用远程机器上的程序方法。因此需要采用RPC的方式来实现远端服务器上的程序方法的调用。&lt;/p&gt;
&lt;p&gt;RPC技术内部原理是通过两种技术的组合来实现的：&lt;strong&gt;本地方法调用 和 网络通信技术。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;14rpc简介&#34;&gt;1.4、RPC简介&lt;/h3&gt;
&lt;p&gt;在上述本地过程调用的例子中，我们是在一台计算机上执行了计算机上的程序，完成调用。随着计算机技术的发展和需求场景的变化，有时就需要从一台计算机上执行另外一台计算机上的程序的需求，因此后来又发展出来了RPC技术。特别是目前随着互联网技术的快速迭代和发展，用户和需求几乎都是以指数式的方式在高速增长，这个时候绝大多数情况下程序都是部署在多台机器上，就需要在调用其他物理机器上的程序的情况。&lt;/p&gt;
&lt;p&gt;RPC是Remote Procedure Call Protocol单词首字母的缩写，简称为：RPC，翻译成中文叫远程过程调用协议。所谓远程过程调用，通俗的理解就是可以在本地程序中调用运行在另外一台服务器上的程序的功能方法。这种调用的过程跨越了物理服务器的限制，是在网络中完成的，在调用远端服务器上程序的过程中，本地程序等待返回调用结果，直到远端程序执行完毕，将结果进行返回到本地，最终完成一次完整的调用。&lt;/p&gt;
&lt;p&gt;需要强调的是：&lt;strong&gt;远程过程调用指的是调用远端服务器上的程序的方法整个过程。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;15rpc设计组成&#34;&gt;1.5、RPC设计组成&lt;/h3&gt;
&lt;p&gt;RPC技术在架构设计上有四部分组成，分别是：&lt;strong&gt;客户端、客户端存根、服务端、服务端存根。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里提到了&lt;strong&gt;客户端&lt;/strong&gt;和&lt;strong&gt;服务端&lt;/strong&gt;的概念，其属于程序设计架构的一种方式，在现代的计算机软件程序架构设计上，大方向上分为两种方向，分别是：&lt;strong&gt;B/S架构&lt;/strong&gt;、&lt;strong&gt;C/S架构&lt;/strong&gt;。B/S架构指的是浏览器到服务器交互的架构方式，另外一种是在计算机上安装一个单独的应用，称之为客户端，与服务器交互的模式。&lt;/p&gt;
&lt;p&gt;由于在服务的调用过程中，有一方是发起调用方，另一方是提供服务方。因此，我们把服务发起方称之为客户端，把服务提供方称之为服务端。以下是对RPC的四种角色的解释和说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**客户端(Client)：**服务调用发起方，也称为服务消费者。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**客户端存根(Client Stub)：**该程序运行在客户端所在的计算机机器上，主要用来存储要调用的服务器的地址，另外，该程序还负责将客户端请求远端服务器程序的数据信息打包成数据包，通过网络发送给服务端Stub程序；其次，还要接收服务端Stub程序发送的调用结果数据包，并解析返回给客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**服务端(Server)：**远端的计算机机器上运行的程序，其中有客户端要调用的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**服务端存根(Server Stub)：**接收客户Stub程序通过网络发送的请求消息数据包，并调用服务端中真正的程序功能方法，完成功能调用；其次，将服务端执行调用的结果进行数据处理打包发送给客户端Stub程序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;16rpc原理及调用步骤&#34;&gt;1.6、RPC原理及调用步骤&lt;/h3&gt;
&lt;p&gt;了解完了RPC技术的组成结构我们来看一下具体是如何实现客户端到服务端的调用的。实际上，如果我们想要在网络中的任意两台计算机上实现远程调用过程，要解决很多问题，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两台物理机器在网络中要建立稳定可靠的通信连接。&lt;/li&gt;
&lt;li&gt;两台服务器的通信协议的定义问题，即两台服务器上的程序如何识别对方的请求和返回结果。也就是说两台计算机必须都能够识别对方发来的信息，并且能够识别出其中的请求含义和返回含义，然后才能进行处理。这其实就是通信协议所要完成的工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们来看看RPC具体是如何解决这些问题的，RPC具体的调用步骤图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190726-151825@2x.png&#34; alt=&#34;RPC调用步骤图&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上述图中，通过1-10的步骤图解的形式，说明了RPC每一步的调用过程。具体描述为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、客户端想要发起一个远程过程调用，首先通过调用本地客户端Stub程序的方式调用想要使用的功能方法名；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、客户端Stub程序接收到了客户端的功能调用请求，&lt;strong&gt;将客户端请求调用的方法名，携带的参数等信息做序列化操作，并打包成数据包。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、客户端Stub查找到远程服务器程序的IP地址，调用Socket通信协议，通过网络发送给服务端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4、服务端Stub程序接收到客户端发送的数据包信息，并&lt;strong&gt;通过约定好的协议将数据进行反序列化，得到请求的方法名和请求参数等信息。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5、服务端Stub程序准备相关数据，&lt;strong&gt;调用本地Server对应的功能方法进行，并传入相应的参数，进行业务处理。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;6、服务端程序根据已有业务逻辑执行调用过程，待业务执行结束，将执行结果返回给服务端Stub程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;7、服务端Stub程序**将程序调用结果按照约定的协议进行序列化，**并通过网络发送回客户端Stub程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;8、客户端Stub程序接收到服务端Stub发送的返回数据，**对数据进行反序列化操作，**并将调用返回的数据传递给客户端请求发起者。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;9、客户端请求发起者得到调用结果，整个RPC调用过程结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;17rpc涉及到的相关技术&#34;&gt;1.7、RPC涉及到的相关技术&lt;/h3&gt;
&lt;p&gt;通过上文一系列的文字描述和讲解，我们已经了解了RPC的由来和RPC整个调用过程。我们可以看到RPC是一系列操作的集合，其中涉及到很多对数据的操作，以及网络通信。因此，我们对RPC中涉及到的技术做一个总结和分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1、动态代理技术：&lt;/strong&gt; 上文中我们提到的Client Stub和Sever Stub程序，在具体的编码和开发实践过程中，都是使用动态代理技术自动生成的一段程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2、序列化和反序列化：&lt;/strong&gt; 在RPC调用的过程中，我们可以看到数据需要在一台机器上传输到另外一台机器上。在互联网上，所有的数据都是以字节的形式进行传输的。而我们在编程的过程中，往往都是使用数据对象，因此想要在网络上将数据对象和相关变量进行传输，就需要对数据对象做序列化和反序列化的操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**序列化：**把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**反序列化：**把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们常见的Json,XML等相关框架都可以对数据做序列化和反序列化编解码操作。同时，在之前的《Go语言微服务理论与实践》课程中，我们已经学习过Protobuf协议，这也是一种数据编解码的协议，在RPC框架中使用的更广泛。&lt;/p&gt;
&lt;h2 id=&#34;二go语言实现rpc编程&#34;&gt;二、Go语言实现RPC编程&lt;/h2&gt;
&lt;p&gt;上节课我们对RPC知识做了介绍，讲解了RPC的原理，通过图示方式讲解了RPC的内部执行过程。本节课，我们继续来学习RPC相关的内容。&lt;/p&gt;
&lt;h3 id=&#34;21rpc官方库&#34;&gt;2.1、RPC官方库&lt;/h3&gt;
&lt;p&gt;在Go语言官方网站的pkg说明中，提供了官方支持的rpc包，具体链接如下：&lt;a href=&#34;https://golang.org/pkg/net/rpc/&#34;&gt;https://golang.org/pkg/net/rpc/&lt;/a&gt;。官方提供的rpc包完整的包名是：&lt;strong&gt;net/rpc&lt;/strong&gt;。根据官方的解释，rpc包主要是提供通过网络访问一个对象方法的功能。&lt;/p&gt;
&lt;p&gt;本节课，我们就来学习如何使用go语言官方提供的RPC包实现RPC调用编码。&lt;/p&gt;
&lt;h3 id=&#34;22netrpc库实现rpc调用编程&#34;&gt;2.2、net/rpc库实现RPC调用编程&lt;/h3&gt;
&lt;p&gt;前文我们已经讲过rpc调用有两个参与者，分别是：&lt;strong&gt;客户端（client）和服务器（server）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先是提供方法暴露的一方--服务器。&lt;/p&gt;
&lt;h4 id=&#34;221服务定义及暴露&#34;&gt;2.2.1、服务定义及暴露&lt;/h4&gt;
&lt;p&gt;在编程实现过程中，服务器端需要注册结构体对象，然后通过对象所属的方法暴露给调用者，从而提供服务，该方法称之为&lt;strong&gt;输出方法&lt;/strong&gt;，此输出方法可以被远程调用。当然，在定义输出方法时，能够被远程调用的方法需要遵循一定的规则。我们通过代码进行讲解：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (t *T) MethodName(request T1,response *T2) error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码是go语言官方给出的对外暴露的服务方法的定义标准，其中包含了主要的几条规则，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、对外暴露的方法有且只能有两个参数，这个两个参数只能是输出类型或内建类型，两种类型中的一种。&lt;/li&gt;
&lt;li&gt;2、方法的第二个参数必须是指针类型。&lt;/li&gt;
&lt;li&gt;3、方法的返回类型为error。&lt;/li&gt;
&lt;li&gt;4、方法的类型是可输出的。&lt;/li&gt;
&lt;li&gt;5、方法本身也是可输出的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们举例说明：假设目前我们有一个需求，给出一个float类型变量，作为圆形的半径，要求通过RPC调用，返回对应的圆形面积。具体的编程实现思路如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type MathUtil struct{
}
//该方法向外暴露：提供计算圆形面积的服务
func (mu *MathUtil) CalculateCircleArea(req float32, resp *float32) error {
	*resp = math.Pi * req * req //圆形的面积 s = π * r * r
	return nil //返回类型
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上述的案例中，我们可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、Calculate方法是服务对象MathUtil向外提供的服务方法，该方法用于接收传入的圆形半径数据，计算圆形面积并返回。&lt;/li&gt;
&lt;li&gt;2、第一个参数req代表的是调用者（client）传递提供的参数。&lt;/li&gt;
&lt;li&gt;3、第二个参数resp代表要返回给调用者的计算结果，必须是指针类型。&lt;/li&gt;
&lt;li&gt;4、正常情况下，方法的返回值为是error，为nil。如果遇到异常或特殊情况，则error将作为一个字符串返回给调用者，此时，resp参数就不会再返回给调用者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至此为止，已经实现了服务端的功能定义，接下来就是让服务代码生效，需要将服务进行注册，并启动请求处理。&lt;/p&gt;
&lt;h4 id=&#34;222注册服务及监听请求&#34;&gt;2.2.2、注册服务及监听请求&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;net/rpc包&lt;/strong&gt;为我们提供了注册服务和处理请求的一系列方法,结合本案例实现注册及处理逻辑，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//1、初始化指针数据类型
mathUtil := new(MathUtil) //初始化指针数据类型

//2、调用net/rpc包的功能将服务对象进行注册
err := rpc.Register(mathUtil)
if err != nil {
	panic(err.Error())
}

//3、通过该函数把mathUtil中提供的服务注册到HTTP协议上，方便调用者可以利用http的方式进行数据传递
rpc.HandleHTTP()

//4、在特定的端口进行监听
listen, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:8081&amp;quot;)
if err != nil {
	panic(err.Error())
}
go http.Serve(listen, nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过服务注册和监听处理，RPC调用过程中的服务端实现就已经完成了。接下来需要实现的是客户端请求代码的实现。&lt;/p&gt;
&lt;h4 id=&#34;223客户端调用&#34;&gt;2.2.3、客户端调用&lt;/h4&gt;
&lt;p&gt;在服务端是通过Http的端口监听方式等待连接的，因此在客户端就需要通过http连接，首先与服务端实现连接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端连接服务端&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;client, err := rpc.DialHTTP(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8081&amp;quot;)
	if err != nil {
		panic(err.Error())
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;远端方法调用
客户端成功连接服务端以后，就可以通过方法调用调用服务端的方法，具体调用方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var req float32 //请求值
req = 3

var resp *float32 //返回值
err = client.Call(&amp;quot;MathUtil.CalculateCircleArea&amp;quot;, req, &amp;amp;resp)
if err != nil {
	panic(err.Error())
}
fmt.Println(*resp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述的调用方法核心在于client.Call方法的调用，该方法有三个参数，第一个参数表示要调用的远端服务的方法名，第二个参数是调用时要传入的参数，第三个参数是调用要接收的返回值。
上述的Call方法调用实现的方式是同步的调用，除此之外，还有一种异步的方式可以实现调用。异步调用代码实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var respSync *float32
//异步的调用方式
syncCall := client.Go(&amp;quot;MathUtil.CalculateCircleArea&amp;quot;, req, &amp;amp;respSync, nil)
replayDone := &amp;lt;-syncCall.Done
fmt.Println(replayDone)
fmt.Println(*respSync)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;224多参数的请求调用参数传递&#34;&gt;2.2.4、多参数的请求调用参数传递&lt;/h4&gt;
&lt;p&gt;上述内容演示了单个参数下的RPC调用，对于多参数下的请求该如何实现。我们通过另外一个案例进行演示。&lt;/p&gt;
&lt;p&gt;假设现在需要实现另外一个需求：通过RPC调用实现计算两个数字相加功能并返回计算结果。此时，就需要传递两个参数，具体实现如下：&lt;/p&gt;
&lt;p&gt;将参数定义在一个新的结构体中，存放在param包中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type AddParma struct {
	Args1 float32 //第一个参数
	Args2 float32 //第二个参数
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在server.go文件中，实现两数相加的功能，并实现服务注册的逻辑：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (mu *MathUtil) Add(param param.AddParma, resp *float32) error {
	*resp = param.Args1 + param.Args2 //实现两数相加的功能
	return nil
}
mathUtil := new(MathUtil)

	err := rpc.RegisterName(&amp;quot;MathUtil&amp;quot;, mathUtil)
	if err != nil {
		panic(err.Error())
	}

	rpc.HandleHTTP()

	listen, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:8082&amp;quot;)
	http.Serve(listen, nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在本案例中，我们通过新的注册方法rpc.RegisterName实现了服务的注册和调用。&lt;/p&gt;
&lt;p&gt;至此，我们已经完成了net/rpc包的最基础的使用。&lt;/p&gt;
&lt;h2 id=&#34;三rpc与protobuf结合使用&#34;&gt;三、RPC与Protobuf结合使用&lt;/h2&gt;
&lt;p&gt;上节课我们使用Golang提供的核心net/rpc库实现了RPC调用编程。本节课继续来看一下RPC和之前所学的Protobuf在编程中的结合实现。&lt;/p&gt;
&lt;p&gt;需求：假设在一个系统中，有订单模块（Order），其他模块想要实现RPC的远程工程调用，根据订单ID和时间戳可以获取订单信息。如果获取成功就返回相应的订单信息；如果查询不到返回失败信息。现在，我们来进行需求的编程实现。&lt;/p&gt;
&lt;h3 id=&#34;31传输数据格式定义&#34;&gt;3.1、传输数据格式定义&lt;/h3&gt;
&lt;p&gt;在《Go语言微服务理论实践课程》中，学习过关于Protobuf的相关知识。可以利用Protobuf相关规则定义相应的数据格式,文件扩展名是.proto。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据定义&lt;/strong&gt;
根据需求，定义message.proto文件，详细定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;syntax = &amp;quot;proto3&amp;quot;;
package message;

//订单请求参数
message OrderRequest {
    string orderId = 1;
    int64 timeStamp = 2;
}

//订单信息
message OrderInfo {
    string OrderId = 1;
    string OrderName = 2;
    string OrderStatus = 3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上述文件中，定义了客户端发起RPC调用时的请求数据结构OrderRequest和服务端查询后返回的数据结构OrderInfo。数据定义采用proto3语法实现，整个数据定义被定义在message包下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编译proto文件&lt;/strong&gt;
通过proto编译命令对.proto文件进行编译，自动生成对应结构体的Go语言文件。编译命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;protoc ./message.proto --go_out=./
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行上述命令是在message包下。编译命令结束后，会在message包下生成message.pb.go文件，其中自动生成了OrderRequest和OrderInfo在Go语言中结构体的定义和相关的方法。&lt;/p&gt;
&lt;h3 id=&#34;32protobuf格式数据与rpc结合&#34;&gt;3.2、Protobuf格式数据与RPC结合&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;服务的定义&lt;/strong&gt;
进行RPC远程过程调用，实现调用远程服务器的方法，首先要有服务。在本案例中，定义提供订单查询功能的服务，取名为OrderService，同时提供订单信息查询方法供远程调用。详细的服务和方法定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//订单服务
type OrderService struct {
}
func (os *OrderService) GetOrderInfo(request message.OrderRequest, response *message.OrderInfo) error {
	//201907310003
	orderMap := map[string]message.OrderInfo{
		&amp;quot;201907300001&amp;quot;: message.OrderInfo{OrderId: &amp;quot;201907300001&amp;quot;, OrderName: &amp;quot;衣服&amp;quot;, OrderStatus: &amp;quot;已付款&amp;quot;},
		&amp;quot;201907310001&amp;quot;: message.OrderInfo{OrderId: &amp;quot;201907310001&amp;quot;, OrderName: &amp;quot;零食&amp;quot;, OrderStatus: &amp;quot;已付款&amp;quot;},
		&amp;quot;201907310002&amp;quot;: message.OrderInfo{OrderId: &amp;quot;201907310002&amp;quot;, OrderName: &amp;quot;食品&amp;quot;, OrderStatus: &amp;quot;未付款&amp;quot;},
	}

   current := time.Now().Unix()
   if (request.TimeStamp &amp;gt; current) {
	  *response = message.OrderInfo{OrderId: &amp;quot;0&amp;quot;, OrderName: &amp;quot;&amp;quot;, OrderStatus: &amp;quot;订单信息异常&amp;quot;}
   } else {
	  result := orderMap[request.OrderId]//201907310003
	  if result.OrderId != &amp;quot;&amp;quot; {
		 *response = orderMap[request.OrderId]
	  } else {
		 return errors.New(&amp;quot;server error&amp;quot;)
	  }
   }
   return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在服务的方法定义中，使用orderMap模拟初始订单数据库，方便案例查询展示。GetOrderInfo方法有两个参数，第一个是message.OrderRequest，作为调用者传递的参数，第二个是message.OrderInfo，作为调用返回的参数，通过此处的两个参数，将上文通过.proto定义并自动生成的Go语言结构体数据结合起来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;服务的注册和处理&lt;/strong&gt;
服务定义好以后，需要将服务注册到RPC框架，并开启http请求监听处理。这部分代码与之前的RPC服务端实现逻辑一致，具体实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

	orderService := new(OrderService)

	rpc.Register(orderService)

	rpc.HandleHTTP()

	listen, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:8081&amp;quot;)
	if err != nil {
		panic(err.Error())
	}
	http.Serve(listen, nil)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RPC客户端调用实现&lt;/strong&gt;
在客户端，除了客户端正常访问远程服务器的逻辑外，还需要准备客户端需要传递的请求数据message.OrderInfo。具体实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;client, err := rpc.DialHTTP(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8081&amp;quot;)
	if err != nil {
		panic(err.Error())
	}

	timeStamp := time.Now().Unix()
	request := message.OrderRequest{OrderId: &amp;quot;201907310001&amp;quot;, TimeStamp: timeStamp}

	var response *message.OrderInfo
	err = client.Call(&amp;quot;OrderService.GetOrderInfo&amp;quot;, request, &amp;amp;response)
	if err != nil {
		panic(err.Error())
	}

	fmt.Println(*response)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33运行结果&#34;&gt;3.3、运行结果&lt;/h3&gt;
&lt;p&gt;分别依次运行server.go和client.go程序。运行结果如下：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190802-085939@2x.png&#34; alt=&#34;运行结果&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/rpc/">RPC</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>type关键字</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day14_%E7%AC%AC4%E8%8A%82-type/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day14_%E7%AC%AC4%E8%8A%82-type/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;type关键字&#34;&gt;type关键字&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;type是go语法里的重要而且常用的关键字，type绝不只是对应于C/C++中的typedef。搞清楚type的使用，就容易理解go语言中的核心概念struct、interface、函数等的使用。&lt;/p&gt;
&lt;h2 id=&#34;一类型定义&#34;&gt;一、类型定义&lt;/h2&gt;
&lt;h3 id=&#34;11-定义结构体&#34;&gt;1.1 定义结构体&lt;/h3&gt;
&lt;p&gt;使用type 可以定义结构体类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//1、定义结构体
//结构体定义
type person struct {
   name string //注意后面不能有逗号
   age  int
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-定义接口&#34;&gt;1.2 定义接口&lt;/h3&gt;
&lt;p&gt;使用type 可以定义接口类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type USB interface {
	start()
	end()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-定义其他的新类型&#34;&gt;1.3 定义其他的新类型&lt;/h3&gt;
&lt;p&gt;使用type，还可以定义新类型。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type 类型名 Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type myint int
type mystr string

func main() {

	 var i1 myint
	 var i2 = 100
	 i1 = 100
	 fmt.Println(i1)
	 //i1 = i2 //cannot use i2 (type int) as type myint in assignment
	 fmt.Println(i1,i2)
	 
	 var name mystr
	 name = &amp;quot;王二狗&amp;quot;
	 var s1 string
	 s1 = &amp;quot;李小花&amp;quot;
	 fmt.Println(name)
	 fmt.Println(s1)
	 name = s1 //cannot use s1 (type string) as type mystr in assignment
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14-定义函数的类型&#34;&gt;1.4 定义函数的类型&lt;/h3&gt;
&lt;p&gt;Go语言支持函数式编程，可以使用高阶编程语法。一个函数可以作为另一个函数的参数，也可以作为另一个函数的返回值，那么在定义这个高阶函数的时候，如果函数的类型比较复杂，我们可以使用type来定义这个函数的类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;strconv&amp;quot;
)

func main() {

	 res1 := fun1()
	 fmt.Println(res1(10,20))
}


type my_fun  func (int,int)(string)

//fun1()函数的返回值是my_func类型
func fun1 () my_fun{
	fun := func(a,b int) string {
		s := strconv.Itoa(a) + strconv.Itoa(b)
		return s
	}
	return fun
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二类型别名&#34;&gt;二、类型别名&lt;/h2&gt;
&lt;p&gt;类型别名的写法为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type 别名 = Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类型别名规定：TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。&lt;/p&gt;
&lt;p&gt;类型别名是 Go 1.9 版本添加的新功能。主要用于代码升级、迁移中类型的兼容性问题。在 C/C++语言中，代码重构升级可以使用宏快速定义新的一段代码。Go 语言中没有选择加入宏，而是将解决重构中最麻烦的类型名变更问题。&lt;/p&gt;
&lt;p&gt;在 Go 1.9 版本之前的内建类型定义的代码是这样写的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type byte uint8
type rune int32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在 Go 1.9 版本之后变为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
type byte = uint8
type rune = int32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个修改就是配合类型别名而进行的修改。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {

	var i1 myint
	var i2 = 100
	i1 = 100
	fmt.Println(i1)
	//i1 = i2 //cannot use i2 (type int) as type myint in assignment
	fmt.Println(i1,i2)
	var i3 myint2
	i3 = i2
	fmt.Println(i1,i2,i3)

}

type myint int
type myint2 = int //不是重新定义类型，只是给int起别名


&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;三非本地类型不能定义方法&#34;&gt;三、非本地类型不能定义方法&lt;/h2&gt;
&lt;p&gt;能够随意地为各种类型起名字，是否意味着可以在自己包里为这些类型任意添加方法？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import (
    &amp;quot;time&amp;quot;
)
// 定义time.Duration的别名为MyDuration
type MyDuration = time.Duration
// 为MyDuration添加一个函数
func (m MyDuration) EasySet(a string) { //cannot define new methods on non-local type time.Duration
}
func main() {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码报错。报错信息：cannot define new methods on non-local type time.Duration&lt;/p&gt;
&lt;p&gt;编译器提示：不能在一个非本地的类型 time.Duration 上定义新方法。非本地方法指的就是使用 time.Duration 的代码所在的包，也就是 main 包。因为 time.Duration 是在 time 包中定义的，在 main 包中使用。time.Duration 包与 main 包不在同一个包中，因此不能为不在一个包中的类型定义方法。&lt;/p&gt;
&lt;p&gt;解决这个问题有下面两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将类型别名改为类型定义： type MyDuration time.Duration，也就是将 MyDuration 从别名改为类型。&lt;/li&gt;
&lt;li&gt;将 MyDuration 的别名定义放在 time 包中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四在结构体成员嵌入时使用别名&#34;&gt;四、在结构体成员嵌入时使用别名&lt;/h2&gt;
&lt;p&gt;当类型别名作为结构体嵌入的成员时会发生什么情况？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type Person struct {
	name string
}

func (p Person) Show() {
	fmt.Println(&amp;quot;Person--&amp;gt;&amp;quot;,p.name)
}

//类型别名
type People = Person

type Student struct {
	// 嵌入两个结构
	Person
	People
}

func (p People) Show2(){
	fmt.Println(&amp;quot;People------&amp;gt;&amp;quot;,p.name)
}

func main() {
	//
	var s Student

	//s.name = &amp;quot;王二狗&amp;quot; //ambiguous selector s.name
	s.People.name = &amp;quot;李小花&amp;quot;
	s.Person.name = &amp;quot;王二狗&amp;quot;
	//s.Show() //ambiguous selector s.Show
	s.Person.Show()
	s.People.Show2()
	fmt.Printf(&amp;quot;%T,%T\n&amp;quot;,s.Person,s.People) //main.Person,main.Person

}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在通过s直接访问name的时候，或者s直接调用Show()方法，因为两个类型都有 name字段和Show() 方法，会发生歧义，证明People 的本质确实是Person 类型。&lt;/p&gt;
&lt;p&gt;部分内容引自：http://c.biancheng.net/view/25.html&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>web开发介绍、iris框架安装、HTTP请求和返回、Iris路由处理</title>
                <link>http://www.songx.fun/blog/day54-55iris%E6%A1%86%E6%9E%B6/day54_web%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8Diris%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85http%E8%AF%B7%E6%B1%82%E5%92%8C%E8%BF%94%E5%9B%9Eiris%E8%B7%AF%E7%94%B1%E5%A4%84%E7%90%86/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day54-55iris%E6%A1%86%E6%9E%B6/day54_web%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8Diris%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85http%E8%AF%B7%E6%B1%82%E5%92%8C%E8%BF%94%E5%9B%9Eiris%E8%B7%AF%E7%94%B1%E5%A4%84%E7%90%86/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;web开发介绍iris框架安装http请求和返回iris路由处理&#34;&gt;web开发介绍、iris框架安装、HTTP请求和返回、Iris路由处理&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一-web项目开发介绍及实战项目介绍&#34;&gt;一 Web项目开发介绍及实战项目介绍&lt;/h2&gt;
&lt;h3 id=&#34;11-引言&#34;&gt;1.1 引言&lt;/h3&gt;
&lt;p&gt;本系列课程我们将学些Golang语言中的Web开发框架Iris的相关知识和用法。通过本系列视频课程，大家能够从零到一经历一个完整项目的开发，并在课程中了解实战项目开发的流程和项目设涉及的各个模块。&lt;/p&gt;
&lt;h3 id=&#34;12-web项目开发介绍&#34;&gt;1.2 Web项目开发介绍&lt;/h3&gt;
&lt;h4 id=&#34;121项目架构&#34;&gt;1.2.1项目架构&lt;/h4&gt;
&lt;p&gt;web项目从大的功能上可以分为前台和后台两个部分。前台主要是我们在浏览器中或者桌面应用、Android、iOS移动应用等直接面向用户的程序，直接接受用户的操作和使用，我们称之为前台，也称之为客户端；为前台应用提供数据和功能调用的部署运行在服务器上的程序，用于操作处理前端应用的数据，我们称之为后台，也称之为服务端。类似于上述这种客户端和服务端的架构，我们通常称之为CS模式，C为client的缩写，S为server的缩写。&lt;/p&gt;
&lt;h4 id=&#34;122-开发流程&#34;&gt;1.2.2 开发流程&lt;/h4&gt;
&lt;h5 id=&#34;1221-需求确定&#34;&gt;1.2.2.1 需求确定&lt;/h5&gt;
&lt;p&gt;在需求确定阶段，主要由产品经理进行确定系统的功能与性能。确认了具体需求后，产品经理会将产品功能进行设计，通常称该阶段为产品原型设计过程。在该阶段，核心目标是确定开发需求，完成产品原型设计。&lt;/p&gt;
&lt;h5 id=&#34;1222-分析与设计&#34;&gt;1.2.2.2 分析与设计&lt;/h5&gt;
&lt;p&gt;在需求确定以后，接下来进入到分析与设计阶段。在该阶段中，又分为几个小阶段，分别为：架构分析与设计、业务逻辑分析、业务逻辑设计和界面设计等四个阶段。&lt;br&gt;
架构分析与设计： 逻辑架构、物理架构（服务器配置、数据库配置）、技术选型等
业务逻辑分析：系统用户、使用目的、操作步骤、用户体验与反馈等&lt;br&gt;
业务逻辑设计：数据库详细设计、对象关系字段映射等&lt;br&gt;
界面设计：UI风格、用户体验等&lt;/p&gt;
&lt;h5 id=&#34;1223-开发环境搭建&#34;&gt;1.2.2.3 开发环境搭建&lt;/h5&gt;
&lt;p&gt;当需求和设计阶段都确定以后，就正式进入开发阶段。首先就是开发环境的搭建，这里面包含硬件环境和软件环境两种。硬件环境是指的开发机器，服务器等硬件设施。软件环境包含开发工具，项目管理平台，软件支持等软件支持。开发环境的搭建一般情况下只有在项目刚刚开始和在项目进行大的架构调整时才需要进行，通常的情况下和日常的迭代开发，可以免去此步骤，直接使用已有的开发环境。&lt;/p&gt;
&lt;h5 id=&#34;1224-开发与测试&#34;&gt;1.2.2.4 开发与测试&lt;/h5&gt;
&lt;p&gt;在实际的项目开发周期中，进行代码开发的周期往往较短。同时，在代码功能开发结束以后，还需要对系统功能进行测试，此时由项目测试人员进行专业的白盒测试、黑盒测试、性能测试、压力测试等全方位、多角度的系统测试。该阶段的开发与测试是交替进行，在实际的开发过程中会反复进行多轮，以此来保证开发人员开发的功能的正确性，保证系统的稳定性。&lt;br&gt;
当系统开发测试阶段结束以后，会对代码进行封版进行最终测试。如果最终测试通过，则会进行部署上线。&lt;/p&gt;
&lt;h5 id=&#34;1225-文档编纂&#34;&gt;1.2.2.5 文档编纂&lt;/h5&gt;
&lt;p&gt;在系统设计、项目开发与测试过程中，我们要遵循一套适用于团队使用和可执行可接受的标准化开发步骤。在项目开发过程中，我们需要将项目开发，操作说明，项目架构说明等文档性的内容进行编写并妥善保存，以便在后续项目维护和对接过程中，相关人员对项目能够正确快速的了解和熟悉。&lt;/p&gt;
&lt;h3 id=&#34;13-实战项目功能介绍&#34;&gt;1.3 实战项目功能介绍&lt;/h3&gt;
&lt;p&gt;在本系列课程中，我们将带大家进行一个后台管理平台项目的实战开发，以帮助大家学习Iris框架的相关用法和项目开发流程。&lt;/p&gt;
&lt;h4 id=&#34;131-项目效果&#34;&gt;1.3.1 项目效果&lt;/h4&gt;
&lt;p&gt;首先我们来看一下项目整体运行后的效果：&lt;br&gt;
&lt;img src=&#34;http://www.songx.fun/img/png/iris%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.png&#34; alt=&#34;后台管理平台登录界面&#34;&gt;
&lt;img src=&#34;http://www.songx.fun/img/png/iris%E5%90%8E%E5%8F%B0%E4%B8%BB%E7%95%8C%E9%9D%A2.png&#34; alt=&#34;后台管理平台主界面&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;122-项目架构&#34;&gt;1.2.2 项目架构&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;前端：vue框架&lt;/li&gt;
&lt;li&gt;后端：Go语言Iris框架 + mysql数据库、redis缓存数据库&lt;/li&gt;
&lt;li&gt;接口文档工具：&lt;br&gt;
小幺鸡：&lt;a href=&#34;http://www.xiaoyaoji.cn/doc/yvnmPtdKK&#34;&gt;http://www.xiaoyaoji.cn/doc/yvnmPtdKK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;接口调试工具：Postman&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;123-项目开发周期&#34;&gt;1.2.3 项目开发周期&lt;/h4&gt;
&lt;p&gt;一周&lt;/p&gt;
&lt;h2 id=&#34;二-iris框架&#34;&gt;二 Iris框架&lt;/h2&gt;
&lt;h3 id=&#34;21-golang介绍&#34;&gt;2.1 Golang介绍&lt;/h3&gt;
&lt;p&gt;Go语言是谷歌推出的一种全新的编程语言，可以在不损失应用程序性能的情况下降低代码的复杂性。谷歌首席软件工程师罗布派克(Rob Pike)说：我们之所以开发Go，是因为过去10多年间软件开发的难度令人沮丧。&lt;br&gt;
谷歌资深软件工程师罗布·派克(Rob Pike)表示，“Go让我体验到了从未有过的开发效率。”派克表示，和今天的C++或C一样，Go是一种系统语言。他解释道，“使用它可以进行快速开发，同时它还是一个真正的编译语言，我们之所以现在将其开源，原因是我们认为它已经非常有用和强大。”&lt;br&gt;
Golang语言的一些的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;具有现代的程序语言特色，如垃圾回收，帮助程序设计师处理琐碎和重要的内存管理等问题。Go的速度也非常快，几乎和C或C++程序一样快，且能够快速制作程序。&lt;/li&gt;
&lt;li&gt;该软件是专为构建服务器软件所设计（如Google的Gmail），Google认为Go还可应用到其他领域，包括在浏览器内执行软件，取代JavaScript的角色。&lt;/li&gt;
&lt;li&gt;Go也可解决现今的一大挑战：多核心处理器。一般电脑程序通常依序执行，一次进行一项工作，但多核心处理器更适合并行处理许多工作。
相较于其他语言，Golang之所以发展迅速，与该语言特有的特色密不可分：&lt;/li&gt;
&lt;li&gt;简洁 快速 安全&lt;/li&gt;
&lt;li&gt;并行 有趣 开源&lt;/li&gt;
&lt;li&gt;内存管理，数组安全，编译迅速&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-iris简介&#34;&gt;2.2 Iris简介&lt;/h3&gt;
&lt;p&gt;Iris是一款Go语言中用来开发web应用的框架，该框架支持编写一次并在任何地方以最小的机器功率运行，如Android、ios、Linux和Windows等。该框架只需要一个可执行的服务就可以在平台上运行了。&lt;br&gt;
Iris框架以简单而强大的api而被开发者所熟悉。iris除了为开发者提供非常简单的访问方式外，还同样支持MVC。另外，用iris构建微服务也很容易。&lt;br&gt;
在iris框架的官方网站上，被称为速度最快的Go后端开发框架。在Iris的网站文档上，列出了该框架具备的一些特点和框架特性，列举如下：
1）聚焦高性能&lt;br&gt;
2）健壮的静态路由支持和通配符子域名支持&lt;br&gt;
3）视图系统支持超过5以上模板&lt;br&gt;
4）支持定制事件的高可扩展性Websocket API&lt;br&gt;
5）带有GC, 内存 &amp;amp; redis 提供支持的会话&lt;br&gt;
6）方便的中间件和插件&lt;br&gt;
7）完整REST API&lt;br&gt;
8）能定制HTTP错误&lt;br&gt;
9）源码改变后自动加载&lt;br&gt;
等等还有很多特性，大家可以参考Iris官方文档。在GoWeb开发的诸多框架中，各个维度的性能比较如下：
&lt;img src=&#34;http://www.songx.fun/img/png/Go%E8%AF%AD%E8%A8%80%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94.png&#34; alt=&#34;Iris与其他语言的框架性能对比&#34;&gt;
&lt;img src=&#34;http://www.songx.fun/img/png/Go%E8%AF%AD%E8%A8%80web%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94.png&#34; alt=&#34;GoWeb各框架开发效率对比&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;23-iris框架学习渠道&#34;&gt;2.3 Iris框架学习渠道&lt;/h3&gt;
&lt;p&gt;在学习Iris框架过程时，我们需要有相应的配套资料才能够完成我们的学习。下面是学习Iris框架过程中可能会用到的资料。&lt;/p&gt;
&lt;h4 id=&#34;231-官方网站&#34;&gt;2.3.1 官方网站&lt;/h4&gt;
&lt;p&gt;Iris官网：&lt;a href=&#34;https://iris-go.com/&#34;&gt;https://iris-go.com/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;232-框架源码&#34;&gt;2.3.2 框架源码&lt;/h4&gt;
&lt;p&gt;Iris框架源码地址：&lt;a href=&#34;https://github.com/kataras/iris&#34;&gt;https://github.com/kataras/iris&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;233-框架学习文档&#34;&gt;2.3.3 框架学习文档&lt;/h4&gt;
&lt;p&gt;Iris框架中文学习文档： &lt;a href=&#34;https://studyiris.com/doc/&#34;&gt;https://studyiris.com/doc/&lt;/a&gt;
当然，还有其他相关资料，比如说xorm框架等，这些我们在后面的课程文档中学习到以后再做解释和说明。&lt;/p&gt;
&lt;h3 id=&#34;24-iris框架安装&#34;&gt;2.4 Iris框架安装&lt;/h3&gt;
&lt;h4 id=&#34;241-go版本限制&#34;&gt;2.4.1 Go版本限制&lt;/h4&gt;
&lt;p&gt;**环境要求：**iris框架要求golang版本至少为1.8。各位同学可以通过打开终端，执行：go version 命令来查看自己机器的go环境版本。&lt;/p&gt;
&lt;h4 id=&#34;242-命令安装&#34;&gt;2.4.2 命令安装&lt;/h4&gt;
&lt;p&gt;安装Iris框架非常简单，使用go语言的全局安装第三方代码的命令get即可。安装Iris框架的命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go get -u github.com/kataras/iris
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在本地终端中执行如上的安装命令，等待命令执行成功，即表示Iris源码下载安装完成。安装完成Iris框架以后，能够在本地机器的GoPath环境目录中的src/github.com/目录下找到iris框架对应的包名，如下图所示：&lt;br&gt;
&lt;img src=&#34;http://www.songx.fun/img/png/Iris%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84.png&#34; alt=&#34;Iris框架源码安装图片&#34;&gt;
如图所示的kataras/iris所在的目录就是iris框架的源码，如上图所示即是安装成功。&lt;/p&gt;
&lt;h3 id=&#34;25-源码案例&#34;&gt;2.5 源码案例&lt;/h3&gt;
&lt;p&gt;在iris源码安装完成以后，iris框架为开发者提供了自己学习的实战案例，供开发者自行学习。iris提供的案例在iris框架目录中的_example目录下，在学习时可以进行参考。
接下来我们就可以开始学习iris的相关内容，进行代码开发了。&lt;/p&gt;
&lt;h3 id=&#34;26-iris构造服务实例&#34;&gt;2.6 Iris构造服务实例&lt;/h3&gt;
&lt;p&gt;在安装完成Iris的源码后，我们就开始来编写最简单的一个Iris的服务。在Iris中，构建并运行一个服务实例需要两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、通过iris.New()方法可以实例化一个应用服务对象app&lt;/li&gt;
&lt;li&gt;2、通过Run方法开启端口监听服务，运行服务实例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下是一个最简单的服务案例Demo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;github.com/kataras/iris&amp;quot;
func main() {
	//1.创建app结构体对象
	app := iris.New()
	//2.端口监听
	app.Run(iris.Addr(&amp;quot;:7999&amp;quot;), iris.WithoutServerError(iris.ErrServerClosed))
	////application.Run(iris.Addr(&amp;quot;:8080&amp;quot;))//第一种
	//application.Run(iris.Addr(&amp;quot;:8080&amp;quot;), iris.WithoutServerError(iris.ErrServerClosed)) //第二种
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;三-getpostput等请求及数据返回格式&#34;&gt;三 Get、Post、Put等请求及数据返回格式&lt;/h2&gt;
&lt;h3 id=&#34;31-数据请求方式的分类&#34;&gt;3.1 数据请求方式的分类&lt;/h3&gt;
&lt;p&gt;所有的项目中使用的请求都遵循HTTP协议标准，HTTP协议经过了1.0和1.1两个版本的发展。&lt;/p&gt;
&lt;h4 id=&#34;311-http10&#34;&gt;3.1.1 HTTP1.0&lt;/h4&gt;
&lt;p&gt;HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。&lt;/p&gt;
&lt;h4 id=&#34;312-http11&#34;&gt;3.1.2 HTTP1.1&lt;/h4&gt;
&lt;p&gt;HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。&lt;/p&gt;
&lt;p&gt;因此，我们可以说，HTTP协议一共定义了八种方法用来对Request-URI网络资源的不同操作方式，这些操作具体为：GET、POST、PUT、DELETE、HEAD、OPTIONS、TRACE、CONNECT等八种操作方式。&lt;/p&gt;
&lt;h3 id=&#34;32-iris框架的请求处理方式&#34;&gt;3.2 Iris框架的请求处理方式&lt;/h3&gt;
&lt;h4 id=&#34;321-默认请求处理&#34;&gt;3.2.1 默认请求处理&lt;/h4&gt;
&lt;p&gt;Iris框架中服务实例app中包含多个方法，用来支持对上述HTTP多种请求类型的直接处理，直接定义为get方法、post方法、put方法等，app中包含的自动处理路由请求的方法与http请求类型的分类一致。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;app := iris.New()
//url: http://localhost:8000/getRequest
//type：GET请求
app.Get(&amp;quot;/getRequest&amp;quot;, func(context context.Context) {
		path := context.Path()
		app.Logger().Info(path)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;322--handle自定义处理&#34;&gt;3.2.2  Handle自定义处理&lt;/h4&gt;
&lt;p&gt;除了上述1中自动处理各类别的请求外，框架还支持使用通用的Handle方法来自定义编写自己的请求处理类型及对应的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//url: http://localhost:/user/info
//type：POST请求
app.Handle(&amp;quot;POST&amp;quot;, &amp;quot;/user/info&amp;quot;, func(context context.Context) {
		context.WriteString(&amp;quot; User Info is Post Request , Deal is in handle func &amp;quot;)
})
//启动端口监听服务
app.Run(iris.Addr(&amp;quot;:8000&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;323-get请求&#34;&gt;3.2.3 GET请求&lt;/h4&gt;
&lt;p&gt;向特定的网络资源数据发起请求。GET请求可以携带请求数据，携带的请求数据会以？分割URL和传输数据，参数之间以&amp;amp;相连，比如http://localhost:3000?name=davie&amp;amp;pwd=123。&lt;br&gt;
如下是一个http的get类型的请求：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:8000/userpath
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务端的路由处理方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//url：http://localhost:8000/userpath
//type：GET请求、用GET方法处理
app.Get(&amp;quot;/userpath&amp;quot;, func(context context.Context) {
		//获取Path
		path := context.Path()
		//日志输出
		app.Logger().Info(path)
		//写入返回数据：string类型
		context.WriteString(&amp;quot;请求路径：&amp;quot; + path)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述为使用已经封装的默认的app.Get方式来处理请求，使用Handle方法来进行处理，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//url：http://localhost:8000/hello
//type：GET请求、Handle方法第一个参数为GET，表明是GET请求方式
app.Handle(&amp;quot;GET&amp;quot;, &amp;quot;/hello&amp;quot;, func(context context.Context) {
		context.HTML(&amp;quot;&amp;lt;h1&amp;gt; Hello world. &amp;lt;/h1&amp;gt;&amp;quot;)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;324-post请求&#34;&gt;3.2.4 POST请求&lt;/h4&gt;
&lt;p&gt;POST请求在进行请求时会将请求数据放在请求body中进行请求，请求数据大小没有限制。在开发过程中，我们使用postman工具来进行POST请求的调试。&lt;br&gt;
POST请求的示例如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:8000/postLogin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务端的路由处理方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//type：POST请求
//携带数据：name、pwd命名的请求数据
app.Post(&amp;quot;/postLogin&amp;quot;, func(context context.Context) {
		//获取请求path
		path := context.Path()
		//日志
		app.Logger().Info(path)
		//获取请求数据字段
		name := context.PostValue(&amp;quot;name&amp;quot;)
		pwd, err := context.PostValueInt(&amp;quot;pwd&amp;quot;)
		if err != nil {
			panic(err.Error())
		}
		app.Logger().Info(name, &amp;quot;  &amp;quot;, pwd)
		//返回
		context.HTML(name)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述为使用默认路由请求方法Post方法来进行处理，同时，还可以使用Handle方法来进行处理，如下图：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//url：http://localhost:8000/user/info
//type：POST请求，Handle方法第一个参数为POST，表明是Post请求
app.Handle(&amp;quot;POST&amp;quot;, &amp;quot;/user/info&amp;quot;, func(context context.Context) {
		context.WriteString(&amp;quot; User Info is Post Request , Deal is in handle func &amp;quot;)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;325-putdeleteoptionshead等其他类型请求&#34;&gt;3.2.5 PUT、DELETE、OPTIONS、HEAD等其他类型请求&lt;/h4&gt;
&lt;p&gt;除了上述GET、POST最为常见的两种请求方式以外，还有PUT、DELETE、OPTIONS、HEAD等其他类型请求，对于其他类型的请求，如同GET和POST请求一样，都是可以通过两种方式来进行处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、iris框架提供的自动识别请求类型的处理请求方法，如put方法、head方法、options方法、delete方法等&lt;/li&gt;
&lt;li&gt;2、使用通用的Handle方法对路由请求进行处理，开发者自己选择具体的请求类型以、对应url和要进行处理的func。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下是put和delete的请求处理：&lt;br&gt;
PUT请求&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//type：PUT类型请求
app.Put(&amp;quot;/putinfo&amp;quot;, func(context context.Context) {
		path := context.Path()
		app.Logger().Info(&amp;quot;请求url：&amp;quot;, path)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DELETE请求&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//type：DELETE类型请求  
app.Delete(&amp;quot;/deleteuser&amp;quot;, func(context context.Context) {
		path := context.Path()
		app.Logger().Info(&amp;quot;Delete请求url：&amp;quot;, path)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;33-请求处理的数据格式返回&#34;&gt;3.3 请求处理的数据格式返回&lt;/h3&gt;
&lt;p&gt;在本节课程中，我们已经学习了如何对不同类型的请求进行处理以及如何获取请求所携带的数据，当后台接收到请求后，将会对请求进行处理，处理完毕后将数据返回给请求的客户端。接下来，我们看一看如何将数据进行返回，以及都有哪些形式。
在进行请求处理时，处理方法func有一个参数context。Context是用于处理请求的上下文环境变量，用于处理http请求及相关数据返回。iris框架支持多种数据格式的返回，此处我们学习掌握返回string、json、xml以及html格式的数据。&lt;/p&gt;
&lt;h4 id=&#34;331-返回string类型数据&#34;&gt;3.3.1 返回string类型数据&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;context.WriteString(&amp;quot;hello world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;332-返回json格式的数据&#34;&gt;3.3.2 返回json格式的数据&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;context.JSON(iris.Map{&amp;quot;message&amp;quot;: &amp;quot;hello word&amp;quot;, &amp;quot;requestCode&amp;quot;: 200})
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;333-返回xml格式的数据&#34;&gt;3.3.3 返回xml格式的数据&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;context.XML(Person{Name: &amp;quot;Davie&amp;quot;, Age: 18})
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;334-返回html格式数据&#34;&gt;3.3.4 返回html格式数据&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;context.HTML(&amp;quot;&amp;lt;h1&amp;gt; Davie, 12 &amp;lt;/h1&amp;gt;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过本节课的内容，我们学习了iris框架中的不同类型的数据请求以及返回不同的数据格式。&lt;/p&gt;
&lt;h2 id=&#34;四-路由功能处理方式&#34;&gt;四 路由功能处理方式&lt;/h2&gt;
&lt;h3 id=&#34;41-context概念&#34;&gt;4.1 Context概念&lt;/h3&gt;
&lt;p&gt;Context是iris框架中的一个路由上下文对象，在iris框架中的源码路径定义为：{$goPath}\github.com\kataras\iris\context\context.go。以下是Context的声明和定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package context
type Context interface {
	BeginRequest(http.ResponseWriter, *http.Request)
	EndRequest()
	ResponseWriter() ResponseWriter
	ResetResponseWriter(ResponseWriter)
	Request() *http.Request
	SetCurrentRouteName(currentRouteName string)
	GetCurrentRoute() RouteReadOnly
	Do(Handlers)
	AddHandler(...Handler)
	SetHandlers(Handlers)
	Handlers() Handlers
	HandlerIndex(n int) (currentIndex int)
	Proceed(Handler) bool
	HandlerName() string
	Next()
	NextOr(handlers ...Handler) bool
	NextOrNotFound() bool
	NextHandler() Handler
	Skip()
	StopExecution()
	IsStopped() bool
	Params() *RequestParams
	Values() *memstore.Store
	Translate(format string, args ...interface{}) string
	Method() string
	Path() string
	RequestPath(escape bool) string
	Host() string
	Subdomain() (subdomain string)
	IsWWW() bool
	RemoteAddr() string
	GetHeader(name string) string
	IsAjax() bool
	IsMobile() bool
	Header(name string, value string)
	ContentType(cType string)
	GetContentType() string
	GetContentLength() int64
	StatusCode(statusCode int)
	GetStatusCode() int
	Redirect(urlToRedirect string, statusHeader ...int)
	URLParamExists(name string) bool
	URLParamDefault(name string, def string) string
	URLParam(name string) string
	URLParamTrim(name string) string
	URLParamEscape(name string) string
	View(filename string, optionalViewModel ...interface{}) error
	Text(text string) (int, error)
	HTML(htmlContents string) (int, error)
	JSON(v interface{}, options ...JSON) (int, error)
	JSONP(v interface{}, options ...JSONP) (int, error)
	XML(v interface{}, options ...XML) (int, error)
	Markdown(markdownB []byte, options ...Markdown) (int, error)
	......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在该Context的接口定义中，我们可以发现，包含很多处理请求及数据返回的操作。在iris框架内，提供给开发者一个ContextPool，即存储上下文变量Context的管理池，该变量池中有多个context实例，可以进行复用。每次有新请求，就会获取一个新的context变量实例，来进行请求的路由处理。我们在实际的案例学习中，会向大家展示关于Context的相关用法。&lt;/p&gt;
&lt;h3 id=&#34;42-正则表达式路由&#34;&gt;4.2 正则表达式路由&lt;/h3&gt;
&lt;p&gt;Iris框架在进行处理http请求时，支持请求url中包含正则表达式。&lt;br&gt;
正则表达式的具体规则为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、使用{}对增则表达式进行包裹，url中出现类似{}样式的格式，即识别为正则表达式&lt;/li&gt;
&lt;li&gt;2、支持自定义增则表达式的变量的命名，变量名用字母表示。比如：{name}&lt;/li&gt;
&lt;li&gt;3、支持对自定义正则表达式变量的数据类型限制，变量名和对应的数据类型之间用“:”分隔开。比如：{name:string}表示增则表达式为name，类型限定为string类型&lt;/li&gt;
&lt;li&gt;4、通过context.Params()的Get()和GetXxx()系列方法来获取对应的请求url中的增则表达式的变量&lt;/li&gt;
&lt;li&gt;5、增则表达式支持变量的数据类型包括：string、int、uint、bool等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下是正则表达式的请求示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;app.Get(&amp;quot;/api/users/{isLogin:bool}&amp;quot;, func(context context.Context) {
	isLogin, err := context.Params().GetBool(&amp;quot;isLogin&amp;quot;)
	if err != nil {
		context.StatusCode(iris.StatusNonAuthoritativeInfo)
		return
	}
	if isLogin {
		context.WriteString(&amp;quot; 已登录 &amp;quot;)
	} else {
		context.WriteString(&amp;quot; 未登录 &amp;quot;)
	}
})
&lt;/code&gt;&lt;/pre&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E6%A1%86%E6%9E%B6/">框架</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>安装Goland开发工具</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day1/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day1/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;安装goland开发工具&#34;&gt;安装Goland开发工具&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开发工具：&lt;/p&gt;
&lt;p&gt;文本类的编辑器：记事本，notepad，sublime text，atom。。。&lt;/p&gt;
&lt;p&gt;​	通过命令执行程序&lt;/p&gt;
&lt;p&gt;IED：集成开发环境（integrated development environment）&lt;/p&gt;
&lt;p&gt;​	goland&lt;/p&gt;
&lt;h2 id=&#34;11-使用goland&#34;&gt;1.1 使用Goland&lt;/h2&gt;
&lt;p&gt;Goland是JetBrains公司推出的Go语言IDE，是一款功能强大，使用便捷的产品。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&#34;http://www.jetbrains.com/go&#34;&gt;http://www.jetbrains.com/go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于Mac和Windows，都有直接的安装文件，直接双击后，傻瓜式安装，一路next，直到完成。&lt;/p&gt;
&lt;p&gt;打开Goland工具，goland的激活码：http://idea.iblue.me&lt;/p&gt;
&lt;p&gt;新建Go项目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;.//img/png/land1.png&#34; alt=&#34;land1&#34;&gt;&lt;/p&gt;
&lt;p&gt;创建项目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/chuangjianxiangmu.png&#34; alt=&#34;chuangjianxiangmu&#34;&gt;&lt;/p&gt;
&lt;p&gt;Goland配置goroot：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/gopath1.png&#34; alt=&#34;gopath1&#34;&gt;&lt;/p&gt;
&lt;p&gt;配置gopath：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/goland.png&#34; alt=&#34;goland&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Goland常用快捷键
文件相关快捷键：

CTRL+E，打开最近浏览过的文件。
CTRL+SHIFT+E，打开最近更改的文件。
CTRL+N，可以快速打开struct结构体。
CTRL+SHIFT+N，可以快速打开文件。
代码格式化：

CTRL+ALT+T，可以把代码包在一个块内，例如if{…}else{…}。
CTRL+ALT+L，格式化代码。
CTRL+空格，代码提示。
CTRL+/，单行注释。CTRL+SHIFT+/，进行多行注释。
CTRL+B，快速打开光标处的结构体或方法（跳转到定义处）。
CTRL+“+/-”，可以将当前方法进行展开或折叠。
查找和定位
CTRL+R，替换文本。
CTRL+F，查找文本。
CTRL+SHIFT+F，进行全局查找。
CTRL+G，快速定位到某行。
代码编辑

ALT+Q，可以看到当前方法的声明。
CTRL+Backspace，按单词进行删除。
SHIFT+ENTER，可以向下插入新行，即使光标在当前行的中间。
CTRL+X，删除当前光标所在行。
CTRL+D，复制当前光标所在行。
ALT+SHIFT+UP/DOWN，可以将光标所在行的代码上下移动。
CTRL+SHIFT+U，可以将选中内容进行大小写转化。


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Ubuntu下安装GoLand工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先下载GoLand软件到下载文件夹下。然后在终端输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ruby@ubuntu:~/下载$ sudo tar -xzf goland-2017.3.3.tar.gz -C /opt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进入bin目录下执行以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ruby@ubuntu:/opt/GoLand-2017.3.3/bin$ sh goland.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12-使用atom&#34;&gt;1.2 使用atom&lt;/h2&gt;
&lt;p&gt;安装好atom工具，然后安装go-plus插件和atom-terminal-panel等插件。&lt;/p&gt;
&lt;p&gt;1.安装go-plus插件，这个插件提供了Atom中几乎所有go语言开发的支持，包括 tools, build flows, linters, vet 和 coverage tools。它还包含很多代码片段和一些其它特性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/22188-96e2f6da75383392.png&#34; alt=&#34;22188-96e2f6da75383392&#34;&gt;&lt;/p&gt;
&lt;p&gt;2.language-go&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/language-go.jpg&#34; alt=&#34;language-go&#34;&gt;&lt;/p&gt;
&lt;p&gt;3.安装file-icon插件，它提针对不同后缀的文件，提供了大量的icon显示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/002_chajian.png&#34; alt=&#34;002_chajian&#34;&gt;&lt;/p&gt;
&lt;p&gt;4.设置字体大小等&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/shezhiziti.jpg&#34; alt=&#34;shezhiziti&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;13-其他开发工具&#34;&gt;1.3 其他开发工具&lt;/h2&gt;
&lt;p&gt;比如sublime text，editplus，notpad++，eclipse等等。。&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;heading&#34;&gt;&lt;/h1&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>编码规范</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC11%E8%8A%82-_%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC11%E8%8A%82-_%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;编码规范&#34;&gt;编码规范&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本规范旨在为日常Go项目开发提供一个代码的规范指导，方便团队形成一个统一的代码风格，提高代码的可读性，规范性和统一性。本规范将从命名规范，注释规范，代码风格和 Go 语言提供的常用的工具这几个方面做一个说明。该规范参考了 go 语言官方代码的风格制定。&lt;/p&gt;
&lt;h2 id=&#34;一-命名规范&#34;&gt;一、 命名规范&lt;/h2&gt;
&lt;p&gt;命名是代码规范中很重要的一部分，统一的命名规则有利于提高的代码的可读性，好的命名仅仅通过命名就可以获取到足够多的信息。&lt;/p&gt;
&lt;p&gt;Go在命名时以字母a到Z或a到Z或下划线开头，后面跟着零或更多的字母、下划线和数字(0到9)。Go不允许在命名时中使用@、$和%等标点符号。Go是一种区分大小写的编程语言。因此，Manpower和manpower是两个不同的命名。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;当命名（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就&lt;strong&gt;可以被外部包的代码所使用&lt;/strong&gt;（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;命名如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的&lt;/strong&gt;（像面向对象语言中的 private ）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1包命名package&#34;&gt;1、包命名：package&lt;/h3&gt;
&lt;p&gt;保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为&lt;strong&gt;小写&lt;/strong&gt;单词，不要使用下划线或者混合大小写。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package demo

package main
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-文件命名&#34;&gt;2、 文件命名&lt;/h3&gt;
&lt;p&gt;尽量采取有意义的文件名，简短，有意义，应该为&lt;strong&gt;小写&lt;/strong&gt;单词，使用&lt;strong&gt;下划线&lt;/strong&gt;分隔各个单词。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;my_test.go
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-结构体命名&#34;&gt;3、 结构体命名&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;采用驼峰命名法，首字母根据访问控制大写或者小写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;struct 申明和初始化格式采用多行，例如下面：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 多行申明
type User struct{
    Username  string
    Email     string
}

// 多行初始化
u := User{
    Username: &amp;quot;astaxie&amp;quot;,
    Email:    &amp;quot;astaxie@gmail.com&amp;quot;,
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-接口命名&#34;&gt;4、 接口命名&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;命名规则基本和上面的结构体类型&lt;/li&gt;
&lt;li&gt;单个函数的结构名以 “er” 作为后缀，例如 Reader , Writer 。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Reader interface {
        Read(p []byte) (n int, err error)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5变量命名&#34;&gt;5、变量命名&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;和结构体类似，变量名称一般遵循驼峰法，首字母根据访问控制原则大写或者小写，但遇到特有名词时，需要遵循以下规则：
&lt;ul&gt;
&lt;li&gt;如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient&lt;/li&gt;
&lt;li&gt;其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID&lt;/li&gt;
&lt;li&gt;错误示例：UrlArray，应该写成 urlArray 或者 URLArray&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var isExist bool
var hasConflict bool
var canManage bool
var allowGitHook bool
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6常量命名&#34;&gt;6、常量命名&lt;/h3&gt;
&lt;p&gt;常量均需使用全部大写字母组成，并使用下划线分词&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const APP_VER = &amp;quot;1.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是枚举类型的常量，需要先创建相应类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Scheme string

const (
    HTTP  Scheme = &amp;quot;http&amp;quot;
    HTTPS Scheme = &amp;quot;https&amp;quot;
)

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7-关键字&#34;&gt;7、 关键字&lt;/h3&gt;
&lt;p&gt;下面的列表显示了Go中的保留字。这些保留字不能用作常量或变量或任何其他标识符名称。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://7xtcwd.com1.z0.glb.clouddn.com/guanjianzi.jpg&#34; alt=&#34;guanjianzi&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;二注释&#34;&gt;二、注释&lt;/h2&gt;
&lt;p&gt;Go提供C风格的&lt;code&gt;/* */&lt;/code&gt;块注释和C ++风格的&lt;code&gt;//&lt;/code&gt;行注释。行注释是常态；块注释主要显示为包注释，但在表达式中很有用或禁用大量代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释&lt;/li&gt;
&lt;li&gt;多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;go 语言自带的 godoc 工具可以根据注释生成文档，生成可以自动生成对应的网站（ golang.org 就是使用 godoc 工具直接生成的），注释的质量决定了生成的文档的质量。每个包都应该有一个包注释，在package子句之前有一个块注释。对于多文件包，包注释只需要存在于一个文件中，任何一个都可以。包评论应该介绍包，并提供与整个包相关的信息。它将首先出现在&lt;code&gt;godoc&lt;/code&gt;页面上，并应设置下面的详细文档。&lt;/p&gt;
&lt;p&gt;详细的如何写注释可以
参考：&lt;a href=&#34;http://golang.org/doc/effective_go.html#commentary&#34;&gt;http://golang.org/doc/effective_go.html#commentary&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;1包注释&#34;&gt;1、包注释&lt;/h3&gt;
&lt;p&gt;每个包都应该有一个包注释，一个位于package子句之前的块注释或行注释。包如果有多个go文件，只需要出现在一个go文件中（一般是和包同名的文件）即可。 包注释应该包含下面基本信息(请严格按照这个顺序，简介，创建人，创建时间）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包的基本简介（包名，简介）&lt;/li&gt;
&lt;li&gt;创建者，格式： 创建人： rtx 名&lt;/li&gt;
&lt;li&gt;创建时间，格式：创建时间： yyyyMMdd&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如 util 包的注释示例如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// util 包， 该包包含了项目共用的一些常量，封装了项目中一些共用函数。
// 创建人： hanru
// 创建时间： 20190419
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2结构接口注释&#34;&gt;2、结构（接口）注释&lt;/h3&gt;
&lt;p&gt;每个自定义的结构体或者接口都应该有注释说明，该注释对结构进行简要介绍，放在结构体定义的前一行，格式为： 结构体名， 结构体说明。同时结构体内的每个成员变量都要有说明，该说明放在成员变量的后面（注意对齐），实例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// User ， 用户对象，定义了用户的基础信息
type User struct{
    Username  string // 用户名
    Email     string // 邮箱
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3函数方法注释&#34;&gt;3、函数（方法）注释&lt;/h3&gt;
&lt;p&gt;每个函数，或者方法（结构体或者接口下的函数称为方法）都应该有注释说明，函数的注释应该包括三个方面（严格按照此顺序撰写）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简要说明，格式说明：以函数名开头，“，”分隔说明部分&lt;/li&gt;
&lt;li&gt;参数列表：每行一个参数，参数名开头，“，”分隔说明部分&lt;/li&gt;
&lt;li&gt;返回值： 每行一个返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// NewtAttrModel ， 属性数据层操作类的工厂方法
// 参数：
//      ctx ： 上下文信息
// 返回值：
//      属性操作类指针
func NewAttrModel(ctx *common.Context) *AttrModel {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4代码逻辑注释&#34;&gt;4、代码逻辑注释&lt;/h3&gt;
&lt;p&gt;对于一些关键位置的代码逻辑，或者局部较为复杂的逻辑，需要有相应的逻辑说明，方便其他开发者阅读该段代码，实例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取
xxxxx
xxxxxxx
xxxxxxx
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5注释风格&#34;&gt;5、注释风格&lt;/h3&gt;
&lt;p&gt;统一使用中文注释，对于中英文字符之间严格使用空格分隔， 这个不仅仅是中文和英文之间，英文和中文标点之间也都要使用空格分隔，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面 Redis 、 id 、 DB 和其他中文字符之间都是用了空格分隔。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建议全部使用单行注释&lt;/li&gt;
&lt;li&gt;和代码的规范一样，单行注释不要过长，禁止超过 120 字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三代码风格&#34;&gt;三、代码风格&lt;/h2&gt;
&lt;h3 id=&#34;1缩进和折行&#34;&gt;1、缩进和折行&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;缩进直接使用 gofmt 工具格式化即可（gofmt 是使用 tab 缩进的）；&lt;/li&gt;
&lt;li&gt;折行方面，一行最长不超过120个字符，超过的请使用换行展示，尽量保持格式优雅。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们使用Goland开发工具，可以直接使用快捷键：ctrl+alt+L，即可。&lt;/p&gt;
&lt;h3 id=&#34;2语句的结尾&#34;&gt;2、语句的结尾&lt;/h3&gt;
&lt;p&gt;Go语言中是不需要类似于Java需要冒号结尾，默认一行就是一条数据&lt;/p&gt;
&lt;p&gt;如果你打算将多个语句写在同一行，它们则必须使用 &lt;strong&gt;;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;3括号和空格&#34;&gt;3、括号和空格&lt;/h3&gt;
&lt;p&gt;括号和空格方面，也可以直接使用 gofmt 工具格式化（go 会强制左大括号不换行，换行会报语法错误），所有的运算符和操作数之间要留空格。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 正确的方式
if a &amp;gt; 0 {

} 

// 错误的方式
if a&amp;gt;0  // a ，0 和 &amp;gt; 之间应该空格
{       // 左大括号不可以换行，会报语法错误

}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4import-规范&#34;&gt;4、import 规范&lt;/h3&gt;
&lt;p&gt;import在多行的情况下，goimports会自动帮你格式化，但是我们这里还是规范一下import的一些规范，如果你在一个文件里面引入了一个package，还是建议采用如下格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
    &amp;quot;fmt&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
    &amp;quot;encoding/json&amp;quot;
    &amp;quot;strings&amp;quot;

    &amp;quot;myproject/models&amp;quot;
    &amp;quot;myproject/controller&amp;quot;
    &amp;quot;myproject/utils&amp;quot;

    &amp;quot;github.com/astaxie/beego&amp;quot;
    &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
)   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有顺序的引入包，不同的类型采用空格分离，第一种实标准库，第二是项目包，第三是第三方包。&lt;/p&gt;
&lt;p&gt;在项目中不要使用相对路径引入包：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 这是不好的导入
import “../net”

// 这是正确的做法
import “github.com/repo/proj/src/net”
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是如果是引入本项目中的其他包，最好使用相对路径。&lt;/p&gt;
&lt;h3 id=&#34;5错误处理&#34;&gt;5、错误处理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;错误处理的原则就是不能丢弃任何有返回err的调用，不要使用 _ 丢弃，必须全部处理。接收到错误，要么返回err，或者使用log记录下来&lt;/li&gt;
&lt;li&gt;尽早return：一旦有错误发生，马上返回&lt;/li&gt;
&lt;li&gt;尽量不要使用panic，除非你知道你在做什么&lt;/li&gt;
&lt;li&gt;错误描述如果是英文必须为小写，不需要标点结尾&lt;/li&gt;
&lt;li&gt;采用独立的错误流进行处理&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 错误写法
if err != nil {
    // error handling
} else {
    // normal code
}

// 正确写法
if err != nil {
    // error handling
    return // or continue, etc.
}
// normal code

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6测试&#34;&gt;6、测试&lt;/h3&gt;
&lt;p&gt;单元测试文件名命名规范为 example_test.go
测试用例的函数名称必须以 Test 开头，例如：TestExample
每个重要的函数都要首先编写测试用例，测试用例和正规代码一起提交方便进行回归测试&lt;/p&gt;
&lt;h2 id=&#34;四常用工具&#34;&gt;四、常用工具&lt;/h2&gt;
&lt;p&gt;上面提到了很过规范， go 语言本身在代码规范性这方面也做了很多努力，很多限制都是强制语法要求，例如左大括号不换行，引用的包或者定义的变量不使用会报错，此外 go 还是提供了很多好用的工具帮助我们进行代码的规范，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;gofmt&lt;/strong&gt;
大部分的格式问题可以通过gofmt解决， gofmt 自动格式化代码，保证所有的 go 代码与官方推荐的格式保持一致，于是所有格式有关问题，都以 gofmt 的结果为准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;goimport&lt;/strong&gt;
我们强烈建议使用 goimport ，该工具在 gofmt 的基础上增加了自动删除和引入包.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go get golang.org/x/tools/cmd/goimports
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;go vet&lt;/strong&gt;
vet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go get golang.org/x/tools/cmd/vet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go vet .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>并发性Concurrency</title>
                <link>http://www.songx.fun/blog/day16-20go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/day17_go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91goroutine/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day16-20go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/day17_go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91goroutine/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;一并发性concurrency&#34;&gt;一、并发性Concurrency&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;11-多任务&#34;&gt;1.1 多任务&lt;/h2&gt;
&lt;p&gt;怎么来理解多任务呢？其实就是指我们的操作系统可以同时执行多个任务。举个例子，你一边听音乐，一边刷微博，一边聊QQ，一边用Markdown写作业，这就是多任务，至少同时有4个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是界面上没有显示而已。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/duorenwu1_meitu_1.jpg&#34; alt=&#34;duorenwu1_meitu_1&#34;&gt;&lt;/p&gt;
&lt;p&gt;CPU的速度太快啦。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/sudukuai.jpeg&#34; alt=&#34;sudukuai&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;12-什么是并发&#34;&gt;1.2 什么是并发&lt;/h2&gt;
&lt;p&gt;Go是并发语言，而不是并行语言。在讨论如何在Go中进行并发处理之前，我们首先必须了解什么是并发，以及它与并行性有什么不同。(Go is a concurrent language and not a parallel one. )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并发性Concurrency是同时处理许多事情的能力。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个例子，假设一个人在晨跑。在晨跑时，他的鞋带松了。现在这个人停止跑步，系鞋带，然后又开始跑步。这是一个典型的并发性示例。这个人能够同时处理跑步和系鞋带，这是一个人能够同时处理很多事情。&lt;/p&gt;
&lt;p&gt;什么是并行性parallelism，它与并发concurrency有什么不同?
并行就是同时做很多事情。这听起来可能与并发类似，但实际上是不同的。&lt;/p&gt;
&lt;p&gt;让我们用同样的慢跑例子更好地理解它。在这种情况下，我们假设这个人正在慢跑，并且使用它的手机听音乐。在这种情况下，一个人一边慢跑一边听音乐，那就是他同时在做很多事情。这就是所谓的并行性(parallelism)。&lt;/p&gt;
&lt;p&gt;并发性和并行性——一种技术上的观点。
假设我们正在编写一个web浏览器。web浏览器有各种组件。其中两个是web页面呈现区域和下载文件从internet下载的下载器。假设我们以这样的方式构建了浏览器的代码，这样每个组件都可以独立地执行。当这个浏览器运行在单个核处理器中时，处理器将在浏览器的两个组件之间进行上下文切换。它可能会下载一个文件一段时间，然后它可能会切换到呈现用户请求的网页的html。这就是所谓的并发性。并发进程从不同的时间点开始，它们的执行周期重叠。在这种情况下，下载和呈现从不同的时间点开始，它们的执行重叠。&lt;/p&gt;
&lt;p&gt;假设同一浏览器运行在多核处理器上。在这种情况下，文件下载组件和HTML呈现组件可能同时在不同的内核中运行。这就是所谓的并行性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190730-100944.png&#34; alt=&#34;WX20190730-100944&#34;&gt;&lt;/p&gt;
&lt;p&gt;并行性Parallelism不会总是导致更快的执行时间。这是因为并行运行的组件可能需要相互通信。例如，在我们的浏览器中，当文件下载完成时，应该将其传递给用户，比如使用弹出窗口。这种通信发生在负责下载的组件和负责呈现用户界面的组件之间。这种通信开销在并发concurrent 系统中很低。当组件在多个内核中并行concurrent 运行时，这种通信开销很高。因此，并行程序并不总是导致更快的执行时间!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/t.png&#34; alt=&#34;t&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;13-进程线程协程&#34;&gt;1.3 进程、线程、协程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;进程(Process)，线程(Thread)，协程(Coroutine，也叫轻量级线程)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程
进程是一个程序在一个数据集中的一次动态执行过程，可以简单理解为“正在执行的程序”，它是CPU资源分配和调度的独立单位。
进程一般由程序、数据集、进程控制块三部分组成。我们编写的程序用来描述进程要完成哪些功能以及如何完成；数据集则是程序在执行过程中所需要使用的资源；进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。 &lt;strong&gt;进程的局限是创建、撤销和切换的开销比较大。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程
线程是在进程之后发展出来的概念。 线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，由线程ID、程序计数器、寄存器集合和堆栈共同组成。一个进程可以包含多个线程。
线程的优点是减小了程序并发执行时的开销，提高了操作系统的并发性能，缺点是线程没有自己的系统资源，只拥有在运行时必不可少的资源，但同一进程的各线程可以共享进程所拥有的系统资源，如果把进程比作一个车间，那么线程就好比是车间里面的工人。不过对于某些独占性资源存在锁机制，处理不当可能会产生“死锁”。&lt;/p&gt;
&lt;p&gt;协程
协程是一种用户态的轻量级线程，又称微线程，英文名Coroutine，协程的调度完全由用户控制。人们通常将协程和子程序（函数）比较着理解。
子程序调用总是一个入口，一次返回，一旦退出即完成了子程序的执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与传统的系统级线程和进程相比，协程的最大优势在于其&amp;quot;轻量级&amp;quot;，可以轻松创建上百万个而不会导致系统资源衰竭，而线程和进程通常最多也不能超过1万的。这也是协程也叫轻量级线程的原因。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;协程与多线程相比，其优势体现在：协程的执行效率极高。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Go语言对于并发的实现是靠协程，Goroutine&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;二go语言的并发模型&#34;&gt;二、Go语言的并发模型&lt;/h1&gt;
&lt;p&gt;Go 语言相比Java等一个很大的优势就是可以方便地编写并发程序。Go 语言内置了 goroutine 机制，使用goroutine可以快速地开发并发程序， 更好的利用多核处理器资源。接下来我们来了解一下Go语言的并发原理。&lt;/p&gt;
&lt;h2 id=&#34;21-线程模型&#34;&gt;2.1 线程模型&lt;/h2&gt;
&lt;p&gt;在现代操作系统中，线程是处理器调度和分配的基本单位，进程则作为资源拥有的基本单位。每个进程是由私有的虚拟地址空间、代码、数据和其它各种系统资源组成。线程是进程内部的一个执行单元。 每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。 用户根据需要在应用程序中创建其它线程，多个线程并发地运行于同一个进程中。&lt;/p&gt;
&lt;p&gt;我们先从线程讲起，无论语言层面何种并发模型，到了操作系统层面，一定是以线程的形态存在的。而操作系统根据资源访问权限的不同，体系架构可分为用户空间和内核空间；内核空间主要操作访问CPU资源、I/O资源、内存资源等硬件资源，为上层应用程序提供最基本的基础资源，用户空间呢就是上层应用程序的固定活动空间，用户空间不可以直接访问资源，必须通过“系统调用”、“库函数”或“Shell脚本”来调用内核空间提供的资源。&lt;/p&gt;
&lt;p&gt;我们现在的计算机语言，可以狭义的认为是一种“软件”，它们中所谓的“线程”，往往是用户态的线程，和操作系统本身内核态的线程（简称KSE），还是有区别的。&lt;/p&gt;
&lt;p&gt;Go并发编程模型在底层是由操作系统所提供的线程库支撑的，因此还是得从线程实现模型说起。&lt;/p&gt;
&lt;p&gt;线程可以视为进程中的控制流。一个进程至少会包含一个线程，因为其中至少会有一个控制流持续运行。因而，一个进程的第一个线程会随着这个进程的启动而创建，这个线程称为该进程的主线程。当然，一个进程也可以包含多个线程。这些线程都是由当前进程中已存在的线程创建出来的，创建的方法就是调用系统调用，更确切地说是调用
pthread create函数。拥有多个线程的进程可以并发执行多个任务，并且即使某个或某些任务被阻塞，也不会影响其他任务正常执行，这可以大大改善程序的响应时间和吞吐量。另一方面，线程不可能独立于进程存在。它的生命周期不可能逾越其所属进程的生命周期。&lt;/p&gt;
&lt;p&gt;线程的实现模型主要有3个，分别是:用户级线程模型、内核级线程模型和两级线程模型。它们之间最大的差异就在于线程与内核调度实体( Kernel Scheduling Entity,简称KSE)之间的对应关系上。顾名思义，内核调度实体就是可以被内核的调度器调度的对象。在很多文献和书中，它也称为内核级线程，是操作系统内核的最小调度单元。&lt;/p&gt;
&lt;h4 id=&#34;211-内核级线程模型&#34;&gt;2.1.1 内核级线程模型&lt;/h4&gt;
&lt;p&gt;用户线程与KSE是1对1关系(1:1)。大部分编程语言的线程库(如linux的pthread，Java的java.lang.Thread，C++11的std::thread等等)都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个不同的KSE静态关联，因此其调度完全由OS调度器来做。这种方式实现简单，直接借助OS提供的线程能力，并且不同用户线程之间一般也不会相互影响。但其创建，销毁以及多个线程之间的上下文切换等操作都是直接由OS层面亲自来做，在需要使用大量线程的场景下对OS的性能影响会很大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/moxing2.jpg&#34; alt=&#34;moxing2&#34;&gt;&lt;/p&gt;
&lt;p&gt;每个线程由内核调度器独立的调度，所以如果一个线程阻塞则不影响其他的线程。&lt;/p&gt;
&lt;p&gt;优点：在多核处理器的硬件的支持下，内核空间线程模型支持了真正的并行，当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。&lt;/p&gt;
&lt;p&gt;缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。&lt;/p&gt;
&lt;h4 id=&#34;212-用户级线程模型&#34;&gt;2.1.2 用户级线程模型&lt;/h4&gt;
&lt;p&gt;用户线程与KSE是多对1关系(M:1)，这种线程的创建，销毁以及多个线程之间的协调等操作都是由用户自己实现的线程库来负责，对OS内核透明，一个进程中所有创建的线程都与同一个KSE在运行时动态关联。现在有许多语言实现的 &lt;strong&gt;协程&lt;/strong&gt; 基本上都属于这种方式。这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此可以创建的数量与上下文切换所花费的代价也会小得多。但该模型有个致命的缺点，如果我们在某个用户线程上调用阻塞式系统调用(如用阻塞方式read网络IO)，那么一旦KSE因阻塞被内核调度出CPU的话，剩下的所有对应的用户线程全都会变为阻塞状态（整个进程挂起）。
所以这些语言的&lt;strong&gt;协程库&lt;/strong&gt;会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/moxing1.jpg&#34; alt=&#34;moxing1&#34;&gt;&lt;/p&gt;
&lt;p&gt;优点： 这种模型的好处是线程上下文切换都发生在用户空间，避免的模态切换（mode switch），从而对于性能有积极的影响。&lt;/p&gt;
&lt;p&gt;缺点：所有的线程基于一个内核调度实体即内核线程，这意味着只有一个处理器可以被利用，在多处理器环境下这是不能够被接受的，本质上，用户线程只解决了并发问题，但是没有解决并行问题。如果线程因为 I/O 操作陷入了内核态，内核态线程阻塞等待 I/O 数据，则所有的线程都将会被阻塞，用户空间也可以使用非阻塞而 I/O，但是不能避免性能及复杂度问题。&lt;/p&gt;
&lt;h4 id=&#34;213-两级线程模型&#34;&gt;2.1.3 两级线程模型&lt;/h4&gt;
&lt;p&gt;用户线程与KSE是多对多关系(M:N)，这种实现综合了前两种模型的优点，为一个进程中创建多个KSE，并且线程可以与不同的KSE在运行时进行动态关联，当某个KSE由于其上工作的线程的阻塞操作被内核调度出CPU时，当前与其关联的其余用户线程可以重新与其他KSE建立关联关系。当然这种动态关联机制的实现很复杂，也需要用户自己去实现，这算是它的一个缺点吧。Go语言中的并发就是使用的这种实现方式，Go为了实现该模型自己实现了一个运行时调度器来负责Go中的&amp;quot;线程&amp;quot;与KSE的动态关联。此模型有时也被称为 &lt;strong&gt;混合型线程模型&lt;/strong&gt;，&lt;strong&gt;即用户调度器实现用户线程到KSE的“调度”，内核调度器实现KSE到CPU上的调度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/moxing3.jpg&#34; alt=&#34;moxing3&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-go并发调度-g-p-m模型&#34;&gt;2.2 Go并发调度: G-P-M模型&lt;/h2&gt;
&lt;p&gt;在操作系统提供的内核线程之上，Go搭建了一个特有的两级线程模型。goroutine机制实现了M : N的线程模型，goroutine机制是协程（coroutine）的一种实现，golang内置的调度器，可以让多核CPU中每个CPU执行一个协程。&lt;/p&gt;
&lt;h4 id=&#34;221-调度器是如何工作的&#34;&gt;2.2.1 调度器是如何工作的&lt;/h4&gt;
&lt;p&gt;有了上面的认识，我们可以开始真正的介绍Go的并发机制了，先用一段代码展示一下在Go语言中新建一个“线程”(Go语言中称为Goroutine)的样子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 用go关键字加上一个函数（这里用了匿名函数）
// 调用就做到了在一个新的“线程”并发执行任务
go func() { 
    // do something in one new goroutine
}()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;功能上等价于Java8的代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new java.lang.Thread(() -&amp;gt; { 
    // do something in one new thread
}).start();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;理解goroutine机制的原理，关键是理解Go语言scheduler的实现。&lt;/p&gt;
&lt;p&gt;Go语言中支撑整个scheduler实现的主要有4个重要结构，分别是M、G、P、Sched， 前三个定义在runtime.h中，Sched定义在proc.c中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sched结构就是调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。&lt;/li&gt;
&lt;li&gt;M结构是Machine，系统线程，它由操作系统管理的，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。&lt;/li&gt;
&lt;li&gt;P结构是Processor，处理器，它的主要用途就是用来执行goroutine的，它维护了一个goroutine队列，即runqueue。Processor是让我们从N:1调度到M:N调度的重要部分。&lt;/li&gt;
&lt;li&gt;G是goroutine实现的核心结构，它包含了栈，指令指针，以及其他对调度goroutine很重要的信息，例如其阻塞的channel。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Processor的数量是在启动时被设置为环境变量GOMAXPROCS的值，或者通过运行时调用函数GOMAXPROCS()进行设置。Processor数量固定意味着任意时刻只有GOMAXPROCS个线程在运行go代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们分别用三角形，矩形和圆形表示Machine Processor和Goroutine。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/moxing4.jpg&#34; alt=&#34;moxing4&#34;&gt;&lt;/p&gt;
&lt;p&gt;在单核处理器的场景下，所有goroutine运行在同一个M系统线程中，每一个M系统线程维护一个Processor，任何时刻，一个Processor中只有一个goroutine，其他goroutine在runqueue中等待。一个goroutine运行完自己的时间片后，让出上下文，回到runqueue中。 多核处理器的场景下，为了运行goroutines，每个M系统线程会持有一个Processor。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/moxing5.jpg&#34; alt=&#34;moxing5&#34;&gt;&lt;/p&gt;
&lt;p&gt;在正常情况下，scheduler会按照上面的流程进行调度，但是线程会发生阻塞等情况，看一下goroutine对线程阻塞等的处理。&lt;/p&gt;
&lt;h4 id=&#34;222-线程阻塞&#34;&gt;2.2.2 线程阻塞&lt;/h4&gt;
&lt;p&gt;当正在运行的goroutine阻塞的时候，例如进行系统调用，会再创建一个系统线程（M1），当前的M线程放弃了它的Processor，P转到新的线程中去运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/moxing6.jpg&#34; alt=&#34;moxing6&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;223-runqueue执行完成&#34;&gt;2.2.3 runqueue执行完成&lt;/h4&gt;
&lt;p&gt;当其中一个Processor的runqueue为空，没有goroutine可以调度。它会从另外一个上下文偷取一半的goroutine。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/moxing7.jpg&#34; alt=&#34;moxing7&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其图中的G，P和M都是Go语言运行时系统（其中包括内存分配器，并发调度器，垃圾收集器等组件，可以想象为Java中的JVM）抽象出来概念和数据结构对象：
G：Goroutine的简称，上面用go关键字加函数调用的代码就是创建了一个G对象，是对一个要并发执行的任务的封装，也可以称作用户态线程。属于用户级资源，对OS透明，具备轻量级，可以大量创建，上下文切换成本低等特点。
M：Machine的简称，在linux平台上是用clone系统调用创建的，其与用linux pthread库创建出来的线程本质上是一样的，都是利用系统调用创建出来的OS线程实体。M的作用就是执行G中包装的并发任务。&lt;strong&gt;Go运行时系统中的调度器的主要职责就是将G公平合理的安排到多个M上去执行&lt;/strong&gt;。其属于OS资源，可创建的数量上也受限了OS，通常情况下G的数量都多于活跃的M的。
P：Processor的简称，逻辑处理器，主要作用是管理G对象（每个P都有一个G队列），并为G在M上的运行提供本地化资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从两级线程模型来看，似乎并不需要P的参与，有G和M就可以了，那为什么要加入P这个东东呢？
其实Go语言运行时系统早期(Go1.0)的实现中并没有P的概念，Go中的调度器直接将G分配到合适的M上运行。但这样带来了很多问题，例如，不同的G在不同的M上并发运行时可能都需向系统申请资源（如堆内存），由于资源是全局的，将会由于资源竞争造成很多系统性能损耗，为了解决类似的问题，后面的Go（Go1.1）运行时系统加入了P，让P去管理G对象，M要想运行G必须先与一个P绑定，然后才能运行该P管理的G。这样带来的好处是，我们可以在P对象中预先申请一些系统资源（本地资源），G需要的时候先向自己的本地P申请（无需锁保护），如果不够用或没有再向全局申请，而且从全局拿的时候会多拿一部分，以供后面高效的使用。就像现在我们去政府办事情一样，先去本地政府看能搞定不，如果搞不定再去中央，从而提供办事效率。
而且由于P解耦了G和M对象，这样即使M由于被其上正在运行的G阻塞住，其余与该M关联的G也可以随着P一起迁移到别的活跃的M上继续运行，从而让G总能及时找到M并运行自己，从而提高系统的并发能力。
Go运行时系统通过构造G-P-M对象模型实现了一套用户态的并发调度系统，可以自己管理和调度自己的并发任务，所以可以说Go语言&lt;strong&gt;原生支持并发&lt;/strong&gt;。&lt;strong&gt;自己实现的调度器负责将并发任务分配到不同的内核线程上运行，然后内核调度器接管内核线程在CPU上的执行与调度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以看到Go的并发用起来非常简单，用了一个语法糖将内部复杂的实现结结实实的包装了起来。其内部可以用下面这张图来概述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/goroutine2.png&#34; alt=&#34;goroutine2&#34;&gt;&lt;/p&gt;
&lt;p&gt;写在最后，Go运行时完整的调度系统是很复杂，很难用一篇文章描述的清楚，这里只能从宏观上介绍一下，让大家有个整体的认识。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Goroutine1
func task1() {
    go task2()
    go task3()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假如我们有一个G(Goroutine1)已经通过P被安排到了一个M上正在执行，在Goroutine1执行的过程中我们又创建两个G，这两个G会被马上放入与Goroutine1相同的P的本地G任务队列中，排队等待与该P绑定的M的执行，这是最基本的结构，很好理解。 关键问题是:
&lt;strong&gt;a.如何在一个多核心系统上尽量合理分配G到多个M上运行，充分利用多核，提高并发能力呢？&lt;/strong&gt;
如果我们在一个Goroutine中通过&lt;strong&gt;go&lt;/strong&gt;关键字创建了大量G，这些G虽然暂时会被放在同一个队列, 但如果这时还有空闲P（系统内P的数量默认等于系统cpu核心数），Go运行时系统始终能保证至少有一个（通常也只有一个）活跃的M与空闲P绑定去各种G队列去寻找可运行的G任务，该种M称为&lt;strong&gt;自旋的M&lt;/strong&gt;。一般寻找顺序为：自己绑定的P的队列，全局队列，然后其他P队列。如果自己P队列找到就拿出来开始运行，否则去全局队列看看，由于全局队列需要锁保护，如果里面有很多任务，会转移一批到本地P队列中，避免每次都去竞争锁。如果全局队列还是没有，就要开始玩狠的了，直接从其他P队列偷任务了（偷一半任务回来）。这样就保证了在还有可运行的G任务的情况下，总有与CPU核心数相等的M+P组合 在执行G任务或在执行G的路上(寻找G任务)。
&lt;strong&gt;b. 如果某个M在执行G的过程中被G中的系统调用阻塞了，怎么办？&lt;/strong&gt;
在这种情况下，这个M将会被内核调度器调度出CPU并处于阻塞状态，与该M关联的其他G就没有办法继续执行了，但Go运行时系统的一个监控线程(sysmon线程)能探测到这样的M，并把与该M绑定的P剥离，寻找其他空闲或新建M接管该P，然后继续运行其中的G，大致过程如下图所示。然后等到该M从阻塞状态恢复，需要重新找一个空闲P来继续执行原来的G，如果这时系统正好没有空闲的P，就把原来的G放到全局队列当中，等待其他M+P组合发掘并执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c. 如果某一个G在M运行时间过长，有没有办法做抢占式调度，让该M上的其他G获得一定的运行时间，以保证调度系统的公平性?&lt;/strong&gt;
我们知道linux的内核调度器主要是基于时间片和优先级做调度的。对于相同优先级的线程，内核调度器会尽量保证每个线程都能获得一定的执行时间。为了防止有些线程&amp;quot;饿死&amp;quot;的情况，内核调度器会发起抢占式调度将长期运行的线程中断并让出CPU资源，让其他线程获得执行机会。当然在Go的运行时调度器中也有类似的抢占机制，但并不能保证抢占能成功，因为Go运行时系统并没有内核调度器的中断能力，它只能通过向运行时间过长的G中设置抢占flag的方法温柔的让运行的G自己主动让出M的执行权。
说到这里就不得不提一下Goroutine在运行过程中可以动态扩展自己线程栈的能力，可以从初始的2KB大小扩展到最大1G（64bit系统上），因此在每次调用函数之前需要先计算该函数调用需要的栈空间大小，然后按需扩展（超过最大值将导致运行时异常）。Go抢占式调度的机制就是利用在判断要不要扩栈的时候顺便查看以下自己的抢占flag，决定是否继续执行，还是让出自己。
运行时系统的监控线程会计时并设置抢占flag到运行时间过长的G，然后G在有函数调用的时候会检查该抢占flag，如果已设置就将自己放入全局队列，这样该M上关联的其他G就有机会执行了。但如果正在执行的G是个很耗时的操作且没有任何函数调用(如只是for循环中的计算操作)，即使抢占flag已经被设置，该G还是将一直霸占着当前M直到执行完自己的任务。&lt;/p&gt;
&lt;h1 id=&#34;三runtime包&#34;&gt;三、runtime包&lt;/h1&gt;
&lt;p&gt;官网文档对runtime包的介绍：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Package runtime contains operations that interact with Go&#39;s runtime system, such as functions to control goroutines. It also includes the low-level type information used by the reflect package; see reflect&#39;s documentation for the programmable interface to the run-time type system.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190806-100406.png&#34; alt=&#34;WX20190806-100406&#34;&gt;&lt;/p&gt;
&lt;p&gt;尽管 Go 编译器产生的是本地可执行代码，这些代码仍旧运行在 Go 的 runtime（这部分的代码可以在 runtime 包中找到）当中。这个 runtime 类似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收（第 10.8 节）、栈处理、goroutine、channel、切片（slice）、map 和反射（reflection）等等。&lt;/p&gt;
&lt;h2 id=&#34;31-常用函数&#34;&gt;3.1 常用函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;runtime&lt;/code&gt; 调度器是个非常有用的东西，关于 &lt;code&gt;runtime&lt;/code&gt; 包几个方法:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NumCPU&lt;/strong&gt;：返回当前系统的 &lt;code&gt;CPU&lt;/code&gt; 核数量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GOMAXPROCS&lt;/strong&gt;：设置最大的可同时使用的 &lt;code&gt;CPU&lt;/code&gt; 核数&lt;/p&gt;
&lt;p&gt;通过runtime.GOMAXPROCS函数，应用程序何以在运行期间设置运行时系统中得P最大数量。但这会引起“Stop the World”。所以，应在应用程序最早的调用。并且最好是在运行Go程序之前设置好操作程序的环境变量GOMAXPROCS，而不是在程序中调用runtime.GOMAXPROCS函数。&lt;/p&gt;
&lt;p&gt;无论我们传递给函数的整数值是什么值，运行时系统的P最大值总会在1~256之间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;go1.8后，默认让程序运行在多个核上,可以不用设置了
go1.8前，还是要设置一下，可以更高效的利益cpu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Gosched&lt;/strong&gt;：让当前线程让出 &lt;code&gt;cpu&lt;/code&gt; 以让其它线程运行,它不会挂起当前线程，因此当前线程未来会继续执行&lt;/p&gt;
&lt;p&gt;这个函数的作用是让当前 &lt;code&gt;goroutine&lt;/code&gt; 让出 &lt;code&gt;CPU&lt;/code&gt;，当一个 &lt;code&gt;goroutine&lt;/code&gt; 发生阻塞，&lt;code&gt;Go&lt;/code&gt; 会自动地把与该 &lt;code&gt;goroutine&lt;/code&gt; 处于同一系统线程的其他 &lt;code&gt;goroutine&lt;/code&gt; 转移到另一个系统线程上去，以使这些 &lt;code&gt;goroutine&lt;/code&gt; 不阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Goexit&lt;/strong&gt;：退出当前 &lt;code&gt;goroutine&lt;/code&gt;(但是&lt;code&gt;defer&lt;/code&gt;语句会照常执行)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NumGoroutine&lt;/strong&gt;：返回正在执行和排队的任务总数&lt;/p&gt;
&lt;p&gt;runtime.NumGoroutine函数在被调用后，会返回系统中的处于特定状态的Goroutine的数量。这里的特指是指Grunnable\Gruning\Gsyscall\Gwaition。处于这些状态的Groutine即被看做是活跃的或者说正在被调度。&lt;/p&gt;
&lt;p&gt;注意：垃圾回收所在Groutine的状态也处于这个范围内的话，也会被纳入该计数器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GOOS&lt;/strong&gt;：目标操作系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;runtime.GC&lt;/strong&gt;:会让运行时系统进行一次强制性的垃圾收集&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;强制的垃圾回收：不管怎样，都要进行的垃圾回收。&lt;/li&gt;
&lt;li&gt;非强制的垃圾回收：只会在一定条件下进行的垃圾回收（即运行时，系统自上次垃圾回收之后新申请的堆内存的单元（也成为单元增量）达到指定的数值）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GOROOT&lt;/strong&gt; :获取goroot目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GOOS&lt;/strong&gt; : 查看目标操作系统
很多时候，我们会根据平台的不同实现不同的操作，就而已用GOOS了：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;。。。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;32-示例代码&#34;&gt;3.2 示例代码：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;获取goroot和os：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  //获取goroot目录：
  	fmt.Println(&amp;quot;GOROOT--&amp;gt;&amp;quot;,runtime.GOROOT())
  
  	//获取操作系统
  	fmt.Println(&amp;quot;os/platform--&amp;gt;&amp;quot;,runtime.GOOS) // GOOS--&amp;gt; darwin，mac系统
  
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;获取CPU数量，和设置CPU数量：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func init(){
	//1.获取逻辑cpu的数量
	fmt.Println(&amp;quot;逻辑CPU的核数：&amp;quot;,runtime.NumCPU())
	//2.设置go程序执行的最大的：[1,256]
	n := runtime.GOMAXPROCS(runtime.NumCPU())
	fmt.Println(n)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190806-103956.png&#34; alt=&#34;WX20190806-103956&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Gosched()：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	go func() {
		for i := 0; i &amp;lt; 5; i++ {
			fmt.Println(&amp;quot;goroutine。。。&amp;quot;)
		}

	}()

	for i := 0; i &amp;lt; 4; i++ {
		//让出时间片，先让别的协议执行，它执行完，再回来执行此协程
		runtime.Gosched()
		fmt.Println(&amp;quot;main。。&amp;quot;)
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190806-104235.png&#34; alt=&#34;WX20190806-104235&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Goexit的使用（终止协程）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
func main() {
	//创建新建的协程
	go func() {
		fmt.Println(&amp;quot;goroutine开始。。。&amp;quot;)

		//调用了别的函数
		fun()

		fmt.Println(&amp;quot;goroutine结束。。&amp;quot;)
	}() //别忘了()

	//睡一会儿，不让主协程结束
	time.Sleep(3*time.Second)
}



func fun() {
	defer fmt.Println(&amp;quot;defer。。。&amp;quot;)

	//return           //终止此函数
	runtime.Goexit() //终止所在的协程

	fmt.Println(&amp;quot;fun函数。。。&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190806-105752.png&#34; alt=&#34;WX20190806-105752&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;四临界资源安全问题&#34;&gt;四、临界资源安全问题&lt;/h1&gt;
&lt;h2 id=&#34;41-临界资源&#34;&gt;4.1 临界资源&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;临界资源:&lt;/strong&gt; 指并发环境中多个进程/线程/协程共享的资源。&lt;/p&gt;
&lt;p&gt;但是在并发编程中对临界资源的处理不当， 往往会导致数据不一致的问题。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main()  {
	a := 1
	go func() {
		a = 2
		fmt.Println(&amp;quot;子goroutine。。&amp;quot;,a)
	}()
	a = 3
	time.Sleep(1)
	fmt.Println(&amp;quot;main goroutine。。&amp;quot;,a)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们通过终端命令来执行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190806-155844.png&#34; alt=&#34;WX20190806-155844&#34;&gt;&lt;/p&gt;
&lt;p&gt;能够发现一处被多个goroutine共享的数据。&lt;/p&gt;
&lt;h2 id=&#34;42-临界资源安全问题&#34;&gt;4.2 临界资源安全问题&lt;/h2&gt;
&lt;p&gt;并发本身并不复杂，但是因为有了资源竞争的问题，就使得我们开发出好的并发程序变得复杂起来，因为会引起很多莫名其妙的问题。&lt;/p&gt;
&lt;p&gt;如果多个goroutine在访问同一个数据资源的时候，其中一个线程修改了数据，那么这个数值就被修改了，对于其他的goroutine来讲，这个数值可能是不对的。&lt;/p&gt;
&lt;p&gt;举个例子，我们通过并发来实现火车站售票这个程序。一共有100张票，4个售票口同时出售。&lt;/p&gt;
&lt;p&gt;我们先来看一下示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/rand&amp;quot;
	&amp;quot;time&amp;quot;
)

//全局变量
var ticket = 10 // 100张票

func main() {
	/*
	4个goroutine，模拟4个售票口，4个子程序操作同一个共享数据。
	 */
	go saleTickets(&amp;quot;售票口1&amp;quot;) // g1,100
	go saleTickets(&amp;quot;售票口2&amp;quot;) // g2,100
	go saleTickets(&amp;quot;售票口3&amp;quot;) //g3,100
	go saleTickets(&amp;quot;售票口4&amp;quot;) //g4,100

	time.Sleep(5*time.Second)
}

func saleTickets(name string) {
	rand.Seed(time.Now().UnixNano())
	//for i:=1;i&amp;lt;=100;i++{
	//	fmt.Println(name,&amp;quot;售出：&amp;quot;,i)
	//}
	for { //ticket=1
		if ticket &amp;gt; 0 { //g1,g3,g2,g4
			//睡眠
			time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
			// g1 ,g3, g2,g4
			fmt.Println(name, &amp;quot;售出：&amp;quot;, ticket)  // 1 , 0, -1 , -2
			ticket--   //0 , -1 ,-2 , -3
		} else {
			fmt.Println(name,&amp;quot;售罄，没有票了。。&amp;quot;)
			break
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们为了更好的观察临界资源问题，每个goroutine先睡眠一个随机数，然后再售票，我们发现程序的运行结果，还可以卖出编号为负数的票。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190806-160844.png&#34; alt=&#34;WX20190806-160844&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们的卖票逻辑是先判断票数的编号是否为负数，如果大于0，然后我们就进行卖票，只不过在卖票钱先睡眠，然后再卖，假如说此时已经卖票到只剩最后1张了，某一个goroutine持有了CPU的时间片，那么它再片段是否有票的时候，条件是成立的，所以它可以卖票编号为1的最后一张票。但是因为它在卖之前，先睡眠了，那么其他的goroutine就会持有CPU的时间片，而此时这张票还没有被卖出，那么第二个goroutine再判断是否有票的时候，条件也是成立的，那么它可以卖出这张票，然而它也进入了睡眠。。其他的第三个第四个goroutine都是这样的逻辑，当某个goroutine醒来的时候，不会再判断是否有票，而是直接售出，这样就卖出最后一张票了，然而其他的goroutine醒来的时候，就会陆续卖出了第0张，-1张，-2张。&lt;/p&gt;
&lt;p&gt;这就是临界资源的不安全问题。某一个goroutine在访问某个数据资源的时候，按照数值，已经判断好了条件，然后又被其他的goroutine抢占了资源，并修改了数值，等这个goroutine再继续访问这个数据的时候，数值已经不对了。&lt;/p&gt;
&lt;h2 id=&#34;43-临界资源安全问题的解决&#34;&gt;4.3 临界资源安全问题的解决&lt;/h2&gt;
&lt;p&gt;要想解决临界资源安全的问题，很多编程语言的解决方案都是同步。通过上锁的方式，某一时间段，只能允许一个goroutine来访问这个共享数据，当前goroutine访问完毕，解锁后，其他的goroutine才能来访问。&lt;/p&gt;
&lt;p&gt;我们可以借助于sync包下的锁操作。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/rand&amp;quot;
	&amp;quot;time&amp;quot;
	&amp;quot;sync&amp;quot;
)

//全局变量
var ticket = 10 // 100张票

var wg sync.WaitGroup
var matex sync.Mutex // 创建锁头

func main() {
	/*
	4个goroutine，模拟4个售票口，4个子程序操作同一个共享数据。
	 */
	wg.Add(4)
	go saleTickets(&amp;quot;售票口1&amp;quot;) // g1,100
	go saleTickets(&amp;quot;售票口2&amp;quot;) // g2,100
	go saleTickets(&amp;quot;售票口3&amp;quot;) //g3,100
	go saleTickets(&amp;quot;售票口4&amp;quot;) //g4,100
	wg.Wait()              // main要等待。。。

	//time.Sleep(5*time.Second)
}

func saleTickets(name string) {
	rand.Seed(time.Now().UnixNano())
	defer wg.Done()
	//for i:=1;i&amp;lt;=100;i++{
	//	fmt.Println(name,&amp;quot;售出：&amp;quot;,i)
	//}
	for { //ticket=1
		matex.Lock()
		if ticket &amp;gt; 0 { //g1,g3,g2,g4
			//睡眠
			time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
			// g1 ,g3, g2,g4
			fmt.Println(name, &amp;quot;售出：&amp;quot;, ticket) // 1 , 0, -1 , -2
			ticket--                         //0 , -1 ,-2 , -3
		} else {
			matex.Unlock() //解锁
			fmt.Println(name, &amp;quot;售罄，没有票了。。&amp;quot;)
			break
		}
		matex.Unlock() //解锁
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190806-162433.png&#34; alt=&#34;WX20190806-162433&#34;&gt;&lt;/p&gt;
&lt;p&gt;在Go的并发编程中有一句很经典的话：&lt;strong&gt;不要以共享内存的方式去通信，而要以通信的方式去共享内存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Go语言中并不鼓励用锁保护共享状态的方式在不同的Goroutine中分享信息(以共享内存的方式去通信)。而是鼓励通过&lt;strong&gt;channel&lt;/strong&gt;将共享状态或共享状态的变化在各个Goroutine之间传递（以通信的方式去共享内存），这样同样能像用锁一样保证在同一的时间只有一个Goroutine访问共享状态。&lt;/p&gt;
&lt;p&gt;当然，在主流的编程语言中为了保证多线程之间共享数据安全性和一致性，都会提供一套基本的同步工具集，如锁，条件变量，原子操作等等。Go语言标准库也毫不意外的提供了这些同步机制，使用方式也和其他语言也差不多。&lt;/p&gt;
&lt;h1 id=&#34;五sync包&#34;&gt;五、sync包&lt;/h1&gt;
&lt;p&gt;官网文档对sync包的介绍：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Package sync provides basic synchronization primitives such as mutual exclusion locks. Other than the Once and WaitGroup types, most are intended for use by low-level library routines. Higher-level synchronization is better done via channels and communication.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190807-101109.png&#34; alt=&#34;WX20190807-101109&#34;&gt;&lt;/p&gt;
&lt;p&gt;sync是synchronization同步这个词的缩写，所以也会叫做同步包。这里提供了基本同步的操作，比如互斥锁等等。这里除了Once和WaitGroup类型之外，大多数类型都是供低级库例程使用的。更高级别的同步最好通过channel通道和communication通信来完成&lt;/p&gt;
&lt;h2 id=&#34;51-waitgroup&#34;&gt;5.1 WaitGroup&lt;/h2&gt;
&lt;p&gt;WaitGroup，同步等待组。&lt;/p&gt;
&lt;p&gt;在类型上，它是一个结构体。一个WaitGroup的用途是等待一个goroutine的集合执行完成。主goroutine调用了Add()方法来设置要等待的goroutine的数量。然后，每个goroutine都会执行并且执行完成后调用Done()这个方法。与此同时，可以使用Wait()方法来阻塞，直到所有的goroutine都执行完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190807-101436.png&#34; alt=&#34;WX20190807-101436&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;511-add方法&#34;&gt;5.1.1 Add()方法：&lt;/h3&gt;
&lt;p&gt;Add这个方法，用来设置到WaitGroup的计数器的值。我们可以理解为每个waitgroup中都有一个计数器
用来表示这个同步等待组中要执行的goroutin的数量。&lt;/p&gt;
&lt;p&gt;如果计数器的数值变为0，那么就表示等待时被阻塞的goroutine都被释放，如果计数器的数值为负数，那么就会引发恐慌，程序就报错了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190807-102137.png&#34; alt=&#34;WX20190807-102137&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;512-done方法&#34;&gt;5.1.2 Done()方法&lt;/h3&gt;
&lt;p&gt;Done()方法，就是当WaitGroup同步等待组中的某个goroutine执行完毕后，设置这个WaitGroup的counter数值减1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190807-102843.png&#34; alt=&#34;WX20190807-102843&#34;&gt;&lt;/p&gt;
&lt;p&gt;其实Done()的底层代码就是调用了Add()方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Done decrements the WaitGroup counter by one.
func (wg *WaitGroup) Done() {
	wg.Add(-1)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;513-wait方法&#34;&gt;5.1.3 Wait()方法&lt;/h3&gt;
&lt;p&gt;Wait()方法，表示让当前的goroutine等待，进入阻塞状态。一直到WaitGroup的计数器为零。才能解除阻塞，
这个goroutine才能继续执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190807-103015.png&#34; alt=&#34;WX20190807-103015&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;514-示例代码&#34;&gt;5.1.4 示例代码：&lt;/h3&gt;
&lt;p&gt;我们创建并启动两个goroutine，来打印数字和字母，并在main goroutine中，将这两个子goroutine加入到一个WaitGroup中，同时让main goroutine进入Wait()，让两个子goroutine先执行。当每个子goroutine执行完毕后，调用Done()方法，设置WaitGroup的counter减1。当两条子goroutine都执行完毕后，WaitGroup中的counter的数值为零，解除main goroutine的阻塞。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;sync&amp;quot;
)
var wg sync.WaitGroup // 创建同步等待组对象
func main()  {
	/*
	WaitGroup：同步等待组
		可以使用Add(),设置等待组中要 执行的子goroutine的数量，
		
		在main 函数中，使用wait(),让主程序处于等待状态。直到等待组中子程序执行完毕。解除阻塞

		子gorotuine对应的函数中。wg.Done()，用于让等待组中的子程序的数量减1
	 */
	//设置等待组中，要执行的goroutine的数量
	wg.Add(2)
	go fun1()
	go fun2()
	fmt.Println(&amp;quot;main进入阻塞状态。。。等待wg中的子goroutine结束。。&amp;quot;)
	wg.Wait() //表示main goroutine进入等待，意味着阻塞
	fmt.Println(&amp;quot;main，解除阻塞。。&amp;quot;)

}
func fun1()  {
	for i:=1;i&amp;lt;=10;i++{
		fmt.Println(&amp;quot;fun1.。。i:&amp;quot;,i)
	}
	wg.Done() //给wg等待中的执行的goroutine数量减1.同Add(-1)
}
func fun2()  {
	defer wg.Done()
	for j:=1;j&amp;lt;=10;j++{
		fmt.Println(&amp;quot;\tfun2..j,&amp;quot;,j)
	}
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190807-103748.png&#34; alt=&#34;WX20190807-103748&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GOROOT=/usr/local/go #gosetup
GOPATH=/Users/ruby/go #gosetup
/usr/local/go/bin/go build -i -o /private/var/folders/kt/nlhsnpgn6lgd_q16f8j83sbh0000gn/T/___go_build_demo05_waitgroup_go /Users/ruby/go/src/l_goroutine/demo05_waitgroup.go #gosetup
/private/var/folders/kt/nlhsnpgn6lgd_q16f8j83sbh0000gn/T/___go_build_demo05_waitgroup_go #gosetup
fun1.。。i: 1
fun1.。。i: 2
fun1.。。i: 3
fun1.。。i: 4
fun1.。。i: 5
fun1.。。i: 6
fun1.。。i: 7
fun1.。。i: 8
fun1.。。i: 9
fun1.。。i: 10
main进入阻塞状态。。。等待wg中的子goroutine结束。。
	fun2..j, 1
	fun2..j, 2
	fun2..j, 3
	fun2..j, 4
	fun2..j, 5
	fun2..j, 6
	fun2..j, 7
	fun2..j, 8
	fun2..j, 9
	fun2..j, 10
main，解除阻塞。。

Process finished with exit code 0

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;52-mutex互斥锁&#34;&gt;5.2 Mutex(互斥锁)&lt;/h2&gt;
&lt;p&gt;通过上一小节，我们知道了在并发程序中，会存在临界资源问题。就是当多个协程来访问共享的数据资源，那么这个共享资源是不安全的。为了解决协程同步的问题我们使用了channel，但是Go语言也提供了传统的同步工具。&lt;/p&gt;
&lt;p&gt;什么是锁呢？就是某个协程（线程）在访问某个资源时先锁住，防止其它协程的访问，等访问完毕解锁后其他协程再来加锁进行访问。一般用于处理并发中的临界资源问题。&lt;/p&gt;
&lt;p&gt;Go语言包中的 sync 包提供了两种锁类型：sync.Mutex 和 sync.RWMutex。&lt;/p&gt;
&lt;p&gt;Mutex 是最简单的一种锁类型，互斥锁，同时也比较暴力，当一个 goroutine 获得了 Mutex 后，其他 goroutine 就只能乖乖等到这个 goroutine 释放该 Mutex。&lt;/p&gt;
&lt;p&gt;每个资源都对应于一个可称为 “互斥锁” 的标记，这个标记用来保证在任意时刻，只能有一个协程（线程）访问该资源。其它的协程只能等待。&lt;/p&gt;
&lt;p&gt;互斥锁是传统并发编程对共享资源进行访问控制的主要手段，它由标准库sync中的Mutex结构体类型表示。sync.Mutex类型只有两个公开的指针方法，Lock和Unlock。Lock锁定当前的共享资源，Unlock进行解锁。&lt;/p&gt;
&lt;p&gt;在使用互斥锁时，一定要注意：对资源操作完成后，一定要解锁，否则会出现流程执行异常，死锁等问题。通常借助defer。锁定后，立即使用defer语句保证互斥锁及时解锁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190808-092409.png&#34; alt=&#34;WX20190807-101436&#34;&gt;&lt;/p&gt;
&lt;p&gt;部分源码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/ A Mutex is a mutual exclusion lock.
// The zero value for a Mutex is an unlocked mutex.
//
// A Mutex must not be copied after first use.
type Mutex struct {
	state int32 //互斥锁上锁状态枚举值如下所示
	sema  uint32 //信号量，向处于Gwaitting的G发送信号
}

// A Locker represents an object that can be locked and unlocked.
type Locker interface {
	Lock()
	Unlock()
}

const (
	mutexLocked = 1 &amp;lt;&amp;lt; iota // mutex is locked  ，1 互斥锁是锁定的
	mutexWoken // 2 唤醒锁
	mutexStarving
	mutexWaiterShift = iota // 统计阻塞在这个互斥锁上的goroutine数目需要移位的数值
	starvationThresholdNs = 1e6
)

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;521-lock方法&#34;&gt;5.2.1 Lock()方法：&lt;/h3&gt;
&lt;p&gt;Lock()这个方法，锁定m。如果该锁已在使用中，则调用goroutine将阻塞，直到互斥体可用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190808-104517.png&#34; alt=&#34;WX20190807-102137&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;522-unlock方法&#34;&gt;5.2.2 Unlock()方法&lt;/h3&gt;
&lt;p&gt;Unlock()方法，解锁解锁m。如果m未在要解锁的条目上锁定，则为运行时错误。&lt;/p&gt;
&lt;p&gt;锁定的互斥体不与特定的goroutine关联。允许一个goroutine锁定互斥体，然后安排另一个goroutine解锁互斥体。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190808-104744.png&#34; alt=&#34;WX20190807-102843&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;523-示例代码&#34;&gt;5.2.3 示例代码：&lt;/h3&gt;
&lt;p&gt;我们针对于上次课程汇总，使用goroutine，模拟4个售票口出售火车票的案例。4个售票口同时卖票，会发生临界资源数据安全问题。我们使用互斥锁解决一下。(Go语言推崇的是使用Channel来实现数据共享，但是也还是提供了传统的同步处理方式)&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
	&amp;quot;math/rand&amp;quot;
	&amp;quot;sync&amp;quot;
)

//全局变量，表示票
var ticket = 10 //100张票


var mutex sync.Mutex //创建锁头

var wg sync.WaitGroup //同步等待组对象
func main() {
	/*
	4个goroutine，模拟4个售票口，


	在使用互斥锁的时候，对资源操作完，一定要解锁。否则会出现程序异常，死锁等问题。
	defer语句
	 */

	 wg.Add(4)
	go saleTickets(&amp;quot;售票口1&amp;quot;)
	go saleTickets(&amp;quot;售票口2&amp;quot;)
	go saleTickets(&amp;quot;售票口3&amp;quot;)
	go saleTickets(&amp;quot;售票口4&amp;quot;)

	wg.Wait() //main要等待
	fmt.Println(&amp;quot;程序结束了。。。&amp;quot;)

	//time.Sleep(5*time.Second)
}

func saleTickets(name string){
	rand.Seed(time.Now().UnixNano())
	defer wg.Done()
	for{
		//上锁
		mutex.Lock() //g2
		if ticket &amp;gt; 0{ //ticket 1 g1
			time.Sleep(time.Duration(rand.Intn(1000))*time.Millisecond)
			fmt.Println(name,&amp;quot;售出：&amp;quot;,ticket) // 1
			ticket-- // 0
		}else{
			mutex.Unlock() //条件不满足，也要解锁
			fmt.Println(name,&amp;quot;售罄，没有票了。。&amp;quot;)
			break
		}
		mutex.Unlock() //解锁
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190808-153743.png&#34; alt=&#34;WX20190807-103748&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GOROOT=/usr/local/go #gosetup
GOPATH=/Users/ruby/go #gosetup
/usr/local/go/bin/go build -i -o /private/var/folders/kt/nlhsnpgn6lgd_q16f8j83sbh0000gn/T/___go_build_demo06_mutex_go /Users/ruby/go/src/l_goroutine/demo06_mutex.go #gosetup
/private/var/folders/kt/nlhsnpgn6lgd_q16f8j83sbh0000gn/T/___go_build_demo06_mutex_go #gosetup
售票口4 售出： 10
售票口4 售出： 9
售票口2 售出： 8
售票口1 售出： 7
售票口3 售出： 6
售票口4 售出： 5
售票口2 售出： 4
售票口1 售出： 3
售票口3 售出： 2
售票口4 售出： 1
售票口2 售罄，没有票了。。
售票口1 售罄，没有票了。。
售票口3 售罄，没有票了。。
售票口4 售罄，没有票了。。
程序结束了。。。

Process finished with exit code 0

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;53-rwmutex读写锁&#34;&gt;5.3 RWMutex(读写锁)&lt;/h2&gt;
&lt;p&gt;通过对互斥锁的学习，我们已经知道了锁的概念以及用途。主要是用于处理并发中的临界资源问题。&lt;/p&gt;
&lt;p&gt;Go语言包中的 sync 包提供了两种锁类型：sync.Mutex 和 sync.RWMutex。其中RWMutex是基于Mutex实现的，只读锁的实现使用类似引用计数器的功能。&lt;/p&gt;
&lt;p&gt;RWMutex是读/写互斥锁。锁可以由任意数量的读取器或单个编写器持有。RWMutex的零值是未锁定的mutex。&lt;/p&gt;
&lt;p&gt;如果一个goroutine持有一个rRWMutex进行读取，而另一个goroutine可能调用lock，那么在释放初始读取锁之前，任何goroutine都不应该期望能够获取读取锁。特别是，这禁止递归读取锁定。这是为了确保锁最终可用；被阻止的锁调用会将新的读卡器排除在获取锁之外。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190808-160432.png&#34; alt=&#34;WX20190807-101436&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们怎么理解读写锁呢？当有一个 goroutine 获得写锁定，其它无论是读锁定还是写锁定都将阻塞直到写解锁；当有一个 goroutine 获得读锁定，其它读锁定仍然可以继续；当有一个或任意多个读锁定，写锁定将等待所有读锁定解锁之后才能够进行写锁定。所以说这里的读锁定（RLock）目的其实是告诉写锁定：有很多人正在读取数据，你给我站一边去，等它们读（读解锁）完你再来写（写锁定）。我们可以将其总结为如下三条：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同时只能有一个 goroutine 能够获得写锁定。&lt;/li&gt;
&lt;li&gt;同时可以有任意多个 gorouinte 获得读锁定。&lt;/li&gt;
&lt;li&gt;同时只能存在写锁定或读锁定（读和写互斥）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，RWMutex这个读写锁，该锁可以加多个读锁或者一个写锁，其经常用于读次数远远多于写次数的场景。&lt;/p&gt;
&lt;p&gt;读写锁的写锁只能锁定一次，解锁前不能多次锁定，读锁可以多次，但读解锁次数最多只能比读锁次数多一次，一般情况下我们不建议读解锁次数多余读锁次数。&lt;/p&gt;
&lt;p&gt;基本遵循两大原则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、可以随便读，多个goroutine同时读。

2、写的时候，啥也不能干。不能读也不能写。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;读写锁即是针对于读写操作的互斥锁。它与普通的互斥锁最大的不同就是，它可以分别针对读操作和写操作进行锁定和解锁操作。读写锁遵循的访问控制规则与互斥锁有所不同。在读写锁管辖的范围内，它允许任意个读操作的同时进行。但是在同一时刻，它只允许有一个写操作在进行。&lt;/p&gt;
&lt;p&gt;并且在某一个写操作被进行的过程中，读操作的进行也是不被允许的。也就是说读写锁控制下的多个写操作之间都是互斥的，并且写操作与读操作之间也都是互斥的。但是，多个读操作之间却不存在互斥关系。&lt;/p&gt;
&lt;h3 id=&#34;531-rlock方法&#34;&gt;5.3.1 RLock()方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (rw *RWMutex) RLock()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;读锁，当有写锁时，无法加载读锁，当只有读锁或者没有锁时，可以加载读锁，读锁可以加载多个，所以适用于“读多写少”的场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190809-101020.png&#34; alt=&#34;WX20190807-102843&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;532-runlock方法&#34;&gt;5.3.2 RUnlock()方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (rw *RWMutex) RUnlock()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;读锁解锁，RUnlock 撤销单次RLock调用，它对于其它同时存在的读取器则没有效果。若rw并没有为读取而锁定，调用RUnlock就会引发一个运行时错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190809-101051.png&#34; alt=&#34;WX20190807-102843&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;533-lock方法&#34;&gt;5.3.3 Lock()方法：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (rw *RWMutex) Lock()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写锁，如果在添加写锁之前已经有其他的读锁和写锁，则Lock就会阻塞直到该锁可用，为确保该锁最终可用，已阻塞的Lock调用会从获得的锁中排除新的读取锁，即写锁权限高于读锁，有写锁时优先进行写锁定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190809-100627.png&#34; alt=&#34;WX20190807-102137&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;534-unlock方法&#34;&gt;5.3.4 Unlock()方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (rw *RWMutex) Unlock()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写锁解锁，如果没有进行写锁定，则就会引起一个运行时错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190809-100753.png&#34; alt=&#34;WX20190807-102843&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;535-示例代码&#34;&gt;5.3.5 示例代码：&lt;/h3&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;
)


var rwMutex *sync.RWMutex
var wg *sync.WaitGroup
func main() {
	rwMutex = new(sync.RWMutex)
	wg = new (sync.WaitGroup)

	//wg.Add(2)
	//
	////多个同时读取
	//go readData(1)
	//go readData(2)

	wg.Add(3)
	go writeData(1)
	go readData(2)
	go writeData(3)

	wg.Wait()
	fmt.Println(&amp;quot;main..over...&amp;quot;)
}


func writeData(i int){
	defer wg.Done()
	fmt.Println(i,&amp;quot;开始写：write start。。&amp;quot;)
	rwMutex.Lock()//写操作上锁
	fmt.Println(i,&amp;quot;正在写：writing。。。。&amp;quot;)
	time.Sleep(3*time.Second)
	rwMutex.Unlock()
	fmt.Println(i,&amp;quot;写结束：write over。。&amp;quot;)
}

func readData(i int) {
	defer wg.Done()

	fmt.Println(i, &amp;quot;开始读：read start。。&amp;quot;)

	rwMutex.RLock() //读操作上锁
	fmt.Println(i,&amp;quot;正在读取数据：reading。。。&amp;quot;)
	time.Sleep(3*time.Second)
	rwMutex.RUnlock() //读操作解锁
	fmt.Println(i,&amp;quot;读结束：read over。。。&amp;quot;)
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190809-112822.png&#34; alt=&#34;WX20190807-103748&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GOROOT=/usr/local/go #gosetup
GOPATH=/Users/ruby/go #gosetup
/usr/local/go/bin/go build -i -o /private/var/folders/kt/nlhsnpgn6lgd_q16f8j83sbh0000gn/T/___go_build_demo07_rwmutex_go /Users/ruby/go/src/l_goroutine/demo07_rwmutex.go #gosetup
/private/var/folders/kt/nlhsnpgn6lgd_q16f8j83sbh0000gn/T/___go_build_demo07_rwmutex_go #gosetup
3 开始写：write start
3 正在写：writing
2 开始读：read start
1 开始写：write start
3 写结束：write over
2 正在读：reading
2 读结束：read over
1 正在写：writing
1 写结束：write over
main..over...

Process finished with exit code 0

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后概括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读锁不能阻塞读锁&lt;/li&gt;
&lt;li&gt;读锁需要阻塞写锁，直到所有读锁都释放&lt;/li&gt;
&lt;li&gt;写锁需要阻塞读锁，直到所有写锁都释放&lt;/li&gt;
&lt;li&gt;写锁需要阻塞写锁&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bbsmax.com/A/kPzOQY3a5x/&#34;&gt;https://www.bbsmax.com/A/kPzOQY3a5x/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://studygolang.com/articles/11322?fr=sidebar&#34;&gt;https://studygolang.com/articles/11322?fr=sidebar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/williamjie/p/9456764.html&#34;&gt;https://www.cnblogs.com/williamjie/p/9456764.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56860636&#34;&gt;https://www.bilibili.com/video/av56860636&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56945376&#34;&gt;https://www.bilibili.com/video/av56945376&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_goroutine&#34;&gt;https://github.com/rubyhan1314/go_goroutine&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B9%B6%E5%8F%91/">并发</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>程序的流程结构</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day04_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day04_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;一程序的流程结构&#34;&gt;一、程序的流程结构&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序的流程控制结构一共有三种：顺序结构，选择结构，循环结构。&lt;/p&gt;
&lt;p&gt;顺序结构：从上向下，逐行执行。&lt;/p&gt;
&lt;p&gt;选择结构：条件满足，某些代码才会执行。0-1次&lt;/p&gt;
&lt;p&gt;​	分支语句：if，switch，select&lt;/p&gt;
&lt;p&gt;循环结构：条件满足，某些代码会被反复的执行多次。0-N次&lt;/p&gt;
&lt;p&gt;​	循环语句：for&lt;/p&gt;
&lt;h1 id=&#34;二条件语句&#34;&gt;二、条件语句&lt;/h1&gt;
&lt;h2 id=&#34;21-if-语句&#34;&gt;2.1 if 语句&lt;/h2&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if 布尔表达式 {
   /* 在布尔表达式为 true 时执行 */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if 布尔表达式 {
   /* 在布尔表达式为 true 时执行 */
} else {
  /* 在布尔表达式为 false 时执行 */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if 布尔表达式1 {
   /* 在布尔表达式1为 true 时执行 */
} else if 布尔表达式2{
   /* 在布尔表达式1为 false ,布尔表达式2为true时执行 */
} else{
   /* 在上面两个布尔表达式都为false时，执行*/
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   /* 定义局部变量 */
   var a int = 10
 
   /* 使用 if 语句判断布尔表达式 */
   if a &amp;lt; 20 {
       /* 如果条件为 true 则执行以下语句 */
       fmt.Printf(&amp;quot;a 小于 20\n&amp;quot; )
   }
   fmt.Printf(&amp;quot;a 的值为 : %d\n&amp;quot;, a)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22-if-变体&#34;&gt;2.2 if 变体&lt;/h2&gt;
&lt;p&gt;如果其中包含一个可选的语句组件(在评估条件之前执行)，则还有一个变体。它的语法是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if statement; condition {  
}

if condition{
    
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    if num := 10; num % 2 == 0 { //checks if number is even
        fmt.Println(num,&amp;quot;is even&amp;quot;) 
    }  else {
        fmt.Println(num,&amp;quot;is odd&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是，num的定义在if里，那么只能够在该if..else语句块中使用，否则编译器会报错的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;23-switch语句开关&#34;&gt;2.3 switch语句：“开关”&lt;/h2&gt;
&lt;p&gt;switch是一个条件语句，它计算表达式并将其与可能匹配的列表进行比较，并根据匹配执行代码块。它可以被认为是一种惯用的方式来写多个if else子句。&lt;/p&gt;
&lt;p&gt;switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上直下逐一测试，直到匹配为止。
switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加break。&lt;/p&gt;
&lt;p&gt;而如果switch没有表达式，它会匹配true&lt;/p&gt;
&lt;p&gt;Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。&lt;/p&gt;
&lt;p&gt;变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。
您可以&lt;strong&gt;同时测试多个可能符合条件的值，使用逗号分割它们&lt;/strong&gt;，例如：case val1, val2, val3。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;switch var1 {
    case val1:
        ...
    case val2:
        ...
    default:
        ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   /* 定义局部变量 */
   var grade string = &amp;quot;B&amp;quot;
   var marks int = 90

   switch marks {
      case 90: grade = &amp;quot;A&amp;quot;
      case 80: grade = &amp;quot;B&amp;quot;
      case 50,60,70 : grade = &amp;quot;C&amp;quot;  //case 后可以由多个数值
      default: grade = &amp;quot;D&amp;quot;  
   }

   switch {
      case grade == &amp;quot;A&amp;quot; :
         fmt.Printf(&amp;quot;优秀!\n&amp;quot; )     
      case grade == &amp;quot;B&amp;quot;, grade == &amp;quot;C&amp;quot; :
         fmt.Printf(&amp;quot;良好\n&amp;quot; )      
      case grade == &amp;quot;D&amp;quot; :
         fmt.Printf(&amp;quot;及格\n&amp;quot; )      
      case grade == &amp;quot;F&amp;quot;:
         fmt.Printf(&amp;quot;不及格\n&amp;quot; )
      default:
         fmt.Printf(&amp;quot;差\n&amp;quot; );
   }
   fmt.Printf(&amp;quot;你的等级是 %s\n&amp;quot;, grade );      
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;24-fallthrough&#34;&gt;2.4 fallthrough&lt;/h2&gt;
&lt;p&gt;如需贯通后续的case，就添加fallthrough&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type data [2]int

func main() {
	switch x := 5; x {
	default:
		fmt.Println(x)
	case 5:
		x += 10
		fmt.Println(x)
		fallthrough
	case 6:
		x += 20
		fmt.Println(x)

	}

}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;15
35
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;case中的表达式是可选的，可以省略。如果该表达式被省略，则被认为是switch true，并且每个case表达式都被计算为true，并执行相应的代码块。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    num := 75
    switch { // expression is omitted
    case num &amp;gt;= 0 &amp;amp;&amp;amp; num &amp;lt;= 50:
        fmt.Println(&amp;quot;num is greater than 0 and less than 50&amp;quot;)
    case num &amp;gt;= 51 &amp;amp;&amp;amp; num &amp;lt;= 100:
        fmt.Println(&amp;quot;num is greater than 51 and less than 100&amp;quot;)
    case num &amp;gt;= 101:
        fmt.Println(&amp;quot;num is greater than 100&amp;quot;)
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;switch的注意事项&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;case后的常量值不能重复&lt;/li&gt;
&lt;li&gt;case后可以有多个常量值&lt;/li&gt;
&lt;li&gt;fallthrough应该是某个case的最后一行。如果它出现在中间的某个地方，编译器就会抛出错误。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;25-type-switch&#34;&gt;2.5 Type Switch&lt;/h2&gt;
&lt;p&gt;switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;switch x.(type){
    case type:
       statement(s);      
    case type:
       statement(s); 
    /* 你可以定义任意个数的case */
    default: /* 可选 */
       statement(s);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   var x interface{}
     
   switch i := x.(type) {
      case nil:	  
         fmt.Printf(&amp;quot; x 的类型 :%T&amp;quot;,i)                
      case int:	  
         fmt.Printf(&amp;quot;x 是 int 型&amp;quot;)                       
      case float64:
         fmt.Printf(&amp;quot;x 是 float64 型&amp;quot;)           
      case func(int) float64:
         fmt.Printf(&amp;quot;x 是 func(int) 型&amp;quot;)                      
      case bool, string:
         fmt.Printf(&amp;quot;x 是 bool 或 string 型&amp;quot; )       
      default:
         fmt.Printf(&amp;quot;未知型&amp;quot;)     
   }   
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x 的类型 :&amp;lt;nil&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>错误处理</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day15_%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day15_%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;错误处理&#34;&gt;错误处理&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在实际工程项目中，我们希望通过程序的错误信息快速定位问题，但是又不喜欢错误处理代码写的冗余而又啰嗦。&lt;code&gt;Go&lt;/code&gt;语言没有提供像&lt;code&gt;Java&lt;/code&gt;、&lt;code&gt;C#&lt;/code&gt;语言中的&lt;code&gt;try...catch&lt;/code&gt;异常处理方式，而是通过函数返回值逐层往上抛。这种设计，鼓励工程师在代码中显式的检查错误，而非忽略错误，好处就是避免漏掉本应处理的错误。但是带来一个弊端，让代码啰嗦。&lt;/p&gt;
&lt;h2 id=&#34;11-什么是错误&#34;&gt;1.1 什么是错误&lt;/h2&gt;
&lt;p&gt;错误是什么?&lt;/p&gt;
&lt;p&gt;错误指的是可能出现问题的地方出现了问题。比如打开一个文件时失败，这种情况在人们的意料之中 。&lt;/p&gt;
&lt;p&gt;而异常指的是不应该出现问题的地方出现了问题。比如引用了空指针，这种情况在人们的意料之外。可见，错误是业务过程的一部分，而异常不是 。&lt;/p&gt;
&lt;p&gt;Go中的错误也是一种类型。错误用内置的&lt;code&gt;error&lt;/code&gt; 类型表示。就像其他类型的，如int，float64，。错误值可以存储在变量中，从函数中返回，等等。&lt;/p&gt;
&lt;h2 id=&#34;12-演示错误&#34;&gt;1.2 演示错误&lt;/h2&gt;
&lt;p&gt;让我们从一个示例程序开始，这个程序尝试打开一个不存在的文件。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;os&amp;quot;
)

func main() {  
    f, err := os.Open(&amp;quot;/test.txt&amp;quot;)
    if err != nil {
        fmt.Println(err)
        return
    }
  //根据f进行文件的读或写
    fmt.Println(f.Name(), &amp;quot;opened successfully&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在os包中有打开文件的功能函数：&lt;/p&gt;
&lt;p&gt;​	func Open(name string) (file *File, err error)&lt;/p&gt;
&lt;p&gt;如果文件已经成功打开，那么Open函数将返回文件处理。如果在打开文件时出现错误，将返回一个非nil错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;如果一个函数或方法返回一个错误，那么按照惯例，它必须是函数返回的最后一个值。因此，&lt;code&gt;Open&lt;/code&gt; 函数返回的值是最后一个值。&lt;/p&gt;
&lt;p&gt;处理错误的惯用方法是将返回的错误与nil进行比较。nil值表示没有发生错误，而非nil值表示出现错误。在我们的例子中，我们检查错误是否为nil。如果它不是nil，我们只需打印错误并从主函数返回。&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;open /test.txt: No such file or directory
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们得到一个错误，说明该文件不存在。&lt;/p&gt;
&lt;h2 id=&#34;13-错误类型表示&#34;&gt;1.3 错误类型表示&lt;/h2&gt;
&lt;p&gt;Go 语言通过内置的错误接口提供了非常简单的错误处理机制。&lt;/p&gt;
&lt;p&gt;让我们再深入一点，看看如何定义错误类型的构建。错误是一个带有以下定义的接口类型，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type error interface {
    Error() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它包含一个带有Error（）字符串的方法。任何实现这个接口的类型都可以作为一个错误使用。这个方法提供了对错误的描述。&lt;/p&gt;
&lt;p&gt;当打印错误时，fmt.Println函数在内部调用Error() 方法来获取错误的描述。这就是错误描述是如何在一行中打印出来的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从错误中提取更多信息的不同方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然我们知道错误是一种接口类型，那么让我们看看如何提取更多关于错误的信息。&lt;/p&gt;
&lt;p&gt;在上面的例子中，我们仅仅是打印了错误的描述。如果我们想要的是导致错误的文件的实际路径。一种可能的方法是解析错误字符串。这是我们程序的输出，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;open /test.txt: No such file or directory  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以解析这个错误消息并从中获取文件路径&amp;quot;/test.txt&amp;quot;。但这是一个糟糕的方法。在新版本的语言中，错误描述可以随时更改，我们的代码将会中断。&lt;/p&gt;
&lt;p&gt;是否有办法可靠地获取文件名？答案是肯定的，它可以做到，标准Go库使用不同的方式提供更多关于错误的信息。让我们一看一看。&lt;/p&gt;
&lt;p&gt;1.断言底层结构类型并从结构字段获取更多信息&lt;/p&gt;
&lt;p&gt;如果仔细阅读打开函数的文档，可以看到它返回的是PathError类型的错误。PathError是一个struct类型，它在标准库中的实现如下，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type PathError struct {  
    Op   string
    Path string
    Err  error
}

func (e *PathError) Error() string { return e.Op + &amp;quot; &amp;quot; + e.Path + &amp;quot;: &amp;quot; + e.Err.Error() }  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面的代码中，您可以理解PathError通过声明&lt;code&gt;Error()string&lt;/code&gt;方法实现了错误接口。该方法连接操作、路径和实际错误并返回它。这样我们就得到了错误信息，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;open /test.txt: No such file or directory 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PathError结构的路径字段包含导致错误的文件的路径。让我们修改上面写的程序，并打印出路径。&lt;/p&gt;
&lt;p&gt;修改代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;os&amp;quot;
)

func main() {  
    f, err := os.Open(&amp;quot;/test.txt&amp;quot;)
    if err, ok := err.(*os.PathError); ok {
        fmt.Println(&amp;quot;File at path&amp;quot;, err.Path, &amp;quot;failed to open&amp;quot;)
        return
    }
    fmt.Println(f.Name(), &amp;quot;opened successfully&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的程序中，我们使用类型断言获得错误接口的基本值。然后我们用错误来打印路径.这个程序输出,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;File at path /test.txt failed to open  
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;断言底层结构类型，并使用方法获取更多信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;获得更多信息的第二种方法是断言底层类型，并通过调用struct类型的方法获取更多信息。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type DNSError struct {  
    ...
}

func (e *DNSError) Error() string {  
    ...
}
func (e *DNSError) Timeout() bool {  
    ... 
}
func (e *DNSError) Temporary() bool {  
    ... 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面的代码中可以看到，DNSError struct有两个方法Timeout() bool和Temporary() bool，它们返回一个布尔值，表示错误是由于超时还是临时的。&lt;/p&gt;
&lt;p&gt;让我们编写一个断言*DNSError类型的程序，并调用这些方法来确定错误是临时的还是超时的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;net&amp;quot;
)

func main() {  
    addr, err := net.LookupHost(&amp;quot;golangbot123.com&amp;quot;)
    if err, ok := err.(*net.DNSError); ok {
        if err.Timeout() {
            fmt.Println(&amp;quot;operation timed out&amp;quot;)
        } else if err.Temporary() {
            fmt.Println(&amp;quot;temporary error&amp;quot;)
        } else {
            fmt.Println(&amp;quot;generic error: &amp;quot;, err)
        }
        return
    }
    fmt.Println(addr)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的程序中，我们正在尝试获取一个无效域名的ip地址，这是一个无效的域名。golangbot123.com。我们通过声明它来输入*net.DNSError来获得错误的潜在价值。&lt;/p&gt;
&lt;p&gt;在我们的例子中，错误既不是暂时的，也不是由于超时，因此程序会打印出来，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;generic error:  lookup golangbot123.com: no such host  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果错误是临时的或超时的，那么相应的If语句就会执行，我们可以适当地处理它。&lt;/p&gt;
&lt;p&gt;3.直接比较&lt;/p&gt;
&lt;p&gt;获得更多关于错误的详细信息的第三种方法是直接与类型错误的变量进行比较。让我们通过一个例子来理解这个问题。&lt;/p&gt;
&lt;p&gt;filepath包的Glob函数用于返回与模式匹配的所有文件的名称。当模式出现错误时，该函数将返回一个错误ErrBadPattern。&lt;/p&gt;
&lt;p&gt;在filepath包中定义了ErrBadPattern，如下所述：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var ErrBadPattern = errors.New(&amp;quot;syntax error in pattern&amp;quot;)  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;errors.New()用于创建新的错误。&lt;/p&gt;
&lt;p&gt;当模式出现错误时，由Glob函数返回ErrBadPattern。&lt;/p&gt;
&lt;p&gt;让我们写一个小程序来检查这个错误：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;path/filepath&amp;quot;
)

func main() {  
    files, error := filepath.Glob(&amp;quot;[&amp;quot;)
    if error != nil &amp;amp;&amp;amp; error == filepath.ErrBadPattern {
        fmt.Println(error)
        return
    }
    fmt.Println(&amp;quot;matched files&amp;quot;, files)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;syntax error in pattern  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;不要忽略错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;永远不要忽略一个错误。忽视错误会招致麻烦。让我重新编写一个示例，该示例列出了与模式匹配的所有文件的名称，而忽略了错误处理代码。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;path/filepath&amp;quot;
)

func main() {  
    files, _ := filepath.Glob(&amp;quot;[&amp;quot;)
    fmt.Println(&amp;quot;matched files&amp;quot;, files)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们从前面的例子中已经知道模式是无效的。我忽略了Glob函数返回的错误，方法是使用行号中的空白标识符。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;matched files []  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于我们忽略了这个错误，输出看起来好像没有文件匹配这个模式，但是实际上这个模式本身是畸形的。所以不要忽略错误。&lt;/p&gt;
&lt;h2 id=&#34;14-自定义错误&#34;&gt;1.4 自定义错误&lt;/h2&gt;
&lt;p&gt;创建自定义错误可以使用errors包下的New()函数，以及fmt包下的：Errorf()函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//errors包：
func New(text string) error {}

//fmt包：
func Errorf(format string, a ...interface{}) error {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在使用New()函数创建自定义错误之前，让我们了解它是如何实现的。下面提供了错误包中的新功能的实现。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Package errors implements functions to manipulate errors.
  package errors

  // New returns an error that formats as the given text.
  func New(text string) error {
      return &amp;amp;errorString{text}
  }

  // errorString is a trivial implementation of error.
  type errorString struct {
      s string
  }

  func (e *errorString) Error() string {
      return e.s
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;既然我们知道了New()函数是如何工作的，那么就让我们在自己的程序中使用它来创建一个自定义错误。&lt;/p&gt;
&lt;p&gt;我们将创建一个简单的程序，计算一个圆的面积，如果半径为负，将返回一个错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;errors&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;math&amp;quot;
)

func circleArea(radius float64) (float64, error) {  
    if radius &amp;lt; 0 {
        return 0, errors.New(&amp;quot;Area calculation failed, radius is less than zero&amp;quot;)
    }
    return math.Pi * radius * radius, nil
}

func main() {  
    radius := -20.0
    area, err := circleArea(radius)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Printf(&amp;quot;Area of circle %0.2f&amp;quot;, area)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Area calculation failed, radius is less than zero 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用Errorf向错误添加更多信息&lt;/p&gt;
&lt;p&gt;上面的程序运行得很好，但是如果我们打印出导致错误的实际半径，那就不好了。这就是fmt包的Errorf函数的用武之地。这个函数根据一个格式说明器格式化错误，并返回一个字符串作为值来满足错误。&lt;/p&gt;
&lt;p&gt;使用Errorf函数，修改程序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;math&amp;quot;
)

func circleArea(radius float64) (float64, error) {  
    if radius &amp;lt; 0 {
        return 0, fmt.Errorf(&amp;quot;Area calculation failed, radius %0.2f is less than zero&amp;quot;, radius)
    }
    return math.Pi * radius * radius, nil
}

func main() {  
    radius := -20.0
    area, err := circleArea(radius)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Printf(&amp;quot;Area of circle %0.2f&amp;quot;, area)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Area calculation failed, radius -20.00 is less than zero  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用struct类型和字段提供关于错误的更多信息&lt;/p&gt;
&lt;p&gt;还可以使用将错误接口实现为错误的struct类型。这给我们提供了更多的错误处理的灵活性。在我们的示例中，如果我们想要访问导致错误的半径，那么现在唯一的方法是解析错误描述区域计算失败，半径-20.00小于零。这不是一种正确的方法，因为如果描述发生了变化，我们的代码就会中断。&lt;/p&gt;
&lt;p&gt;我们将使用在前面的教程中解释的标准库的策略，在“断言底层结构类型并从struct字段获取更多信息”，并使用struct字段来提供对导致错误的半径的访问。我们将创建一个实现错误接口的struct类型，并使用它的字段来提供关于错误的更多信息。&lt;/p&gt;
&lt;p&gt;第一步是创建一个struct类型来表示错误。错误类型的命名约定是，名称应该以文本Error结束。让我们把struct类型命名为areaError&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type areaError struct {  
    err    string
    radius float64
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的struct类型有一个字段半径，它存储了为错误负责的半径的值，并且错误字段存储了实际的错误消息。&lt;/p&gt;
&lt;p&gt;下一步，是实现error 接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (e *areaError) Error() string {  
    return fmt.Sprintf(&amp;quot;radius %0.2f: %s&amp;quot;, e.radius, e.err)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的代码片段中，我们使用一个指针接收器区域错误来实现错误接口的Error() string方法。这个方法打印出半径和错误描述。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;math&amp;quot;
)

type areaError struct {  
    err    string
    radius float64
}

func (e *areaError) Error() string {  
    return fmt.Sprintf(&amp;quot;radius %0.2f: %s&amp;quot;, e.radius, e.err)
}

func circleArea(radius float64) (float64, error) {  
    if radius &amp;lt; 0 {
        return 0, &amp;amp;areaError{&amp;quot;radius is negative&amp;quot;, radius}
    }
    return math.Pi * radius * radius, nil
}

func main() {  
    radius := -20.0
    area, err := circleArea(radius)
    if err != nil {
        if err, ok := err.(*areaError); ok {
            fmt.Printf(&amp;quot;Radius %0.2f is less than zero&amp;quot;, err.radius)
            return
        }
        fmt.Println(err)
        return
    }
    fmt.Printf(&amp;quot;Area of circle %0.2f&amp;quot;, area)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;程序输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Radius -20.00 is less than zero
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用结构类型的方法提供关于错误的更多信息&lt;/p&gt;
&lt;p&gt;在本节中，我们将编写一个程序来计算矩形的面积。如果长度或宽度小于0，这个程序将输出一个错误。&lt;/p&gt;
&lt;p&gt;第一步是创建一个结构来表示错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type areaError struct {  
    err    string //error description
    length float64 //length which caused the error
    width  float64 //width which caused the error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的错误结构类型包含一个错误描述字段，以及导致错误的长度和宽度。&lt;/p&gt;
&lt;p&gt;现在我们有了错误类型，让我们实现错误接口，并在错误类型上添加一些方法来提供关于错误的更多信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (e *areaError) Error() string {  
    return e.err
}

func (e *areaError) lengthNegative() bool {  
    return e.length &amp;lt; 0
}

func (e *areaError) widthNegative() bool {  
    return e.width &amp;lt; 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的代码片段中，我们返回&lt;code&gt;Error() string&lt;/code&gt; 方法的错误描述。当长度小于0时，lengthNegative() bool方法返回true;当宽度小于0时，widthNegative() bool方法返回true。这两种方法提供了更多关于误差的信息，在这种情况下，他们说面积计算是否失败，因为长度是负的，还是宽度为负的。因此，我们使用了struct错误类型的方法来提供更多关于错误的信息。&lt;/p&gt;
&lt;p&gt;下一步是写出面积计算函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func rectArea(length, width float64) (float64, error) {  
    err := &amp;quot;&amp;quot;
    if length &amp;lt; 0 {
        err += &amp;quot;length is less than zero&amp;quot;
    }
    if width &amp;lt; 0 {
        if err == &amp;quot;&amp;quot; {
            err = &amp;quot;width is less than zero&amp;quot;
        } else {
            err += &amp;quot;, width is less than zero&amp;quot;
        }
    }
    if err != &amp;quot;&amp;quot; {
        return 0, &amp;amp;areaError{err, length, width}
    }
    return length * width, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的rectArea函数检查长度或宽度是否小于0，如果它返回一个错误消息，则返回矩形的面积为nil。&lt;/p&gt;
&lt;p&gt;主函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {  
    length, width := -5.0, -9.0
    area, err := rectArea(length, width)
    if err != nil {
        if err, ok := err.(*areaError); ok {
            if err.lengthNegative() {
                fmt.Printf(&amp;quot;error: length %0.2f is less than zero\n&amp;quot;, err.length)

            }
            if err.widthNegative() {
                fmt.Printf(&amp;quot;error: width %0.2f is less than zero\n&amp;quot;, err.width)

            }
        }
        fmt.Println(err)
        return
    }
    fmt.Println(&amp;quot;area of rect&amp;quot;, area)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: length -5.00 is less than zero  
error: width -9.00 is less than zero 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;15-panic和recover&#34;&gt;1.5 panic()和recover()&lt;/h2&gt;
&lt;p&gt;Golang中引入两个内置函数panic和recover来触发和终止异常处理流程，同时引入关键字defer来延迟执行defer后面的函数。
一直等到包含defer语句的函数执行完毕时，延迟函数（defer后的函数）才会被执行，而不管包含defer语句的函数是通过return的正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。
当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数等。如果一路在延迟函数中没有recover函数的调用，则会到达该协程的起点，该协程结束，然后终止其他所有协程，包括主协程（类似于C语言中的主线程，该协程ID为1）。&lt;/p&gt;
&lt;p&gt;panic：
1、内建函数
2、假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行
3、返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行，这里的defer 有点类似 try-catch-finally 中的 finally
4、直到goroutine整个退出，并报告错误&lt;/p&gt;
&lt;p&gt;recover：
1、内建函数
2、用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为
3、一般的调用建议
a). 在defer函数中，通过recever来终止一个gojroutine的panicking过程，从而恢复正常代码的执行
b). 可以获取通过panic传递的error&lt;/p&gt;
&lt;p&gt;简单来讲：go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。&lt;/p&gt;
&lt;p&gt;错误和异常从Golang机制上讲，就是error和panic的区别。很多其他语言也一样，比如C++/Java，没有error但有errno，没有panic但有throw。&lt;/p&gt;
&lt;p&gt;Golang错误和异常是可以互相转换的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;错误转异常，比如程序逻辑上尝试请求某个URL，最多尝试三次，尝试三次的过程中请求失败是错误，尝试完第三次还不成功的话，失败就被提升为异常了。&lt;/li&gt;
&lt;li&gt;异常转错误，比如panic触发的异常被recover恢复后，将返回值中error类型的变量进行赋值，以便上层函数继续走错误处理流程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;什么情况下用错误表达，什么情况下用异常表达，就得有一套规则，否则很容易出现一切皆错误或一切皆异常的情况。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下给出异常处理的作用域（场景）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空指针引用&lt;/li&gt;
&lt;li&gt;下标越界&lt;/li&gt;
&lt;li&gt;除数为0&lt;/li&gt;
&lt;li&gt;不应该出现的分支，比如default&lt;/li&gt;
&lt;li&gt;输入不应该引起函数错误&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他场景我们使用错误处理，这使得我们的函数接口很精炼。对于异常，我们可以选择在一个合适的上游去recover，并打印堆栈信息，使得部署后的程序不会终止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明： Golang错误处理方式一直是很多人诟病的地方，有些人吐槽说一半的代码都是&amp;quot;if err != nil { / 打印 &amp;amp;&amp;amp; 错误处理 / }&amp;quot;，严重影响正常的处理逻辑。当我们区分错误和异常，根据规则设计函数，就会大大提高可读性和可维护性。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;16-错误处理的正确姿势&#34;&gt;1.6 错误处理的正确姿势&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;姿势一：失败的原因只有一个时，不使用error&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们看一个案例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (self *AgentContext) CheckHostType(host_type string) error {
    switch host_type {
    case &amp;quot;virtual_machine&amp;quot;:
        return nil
    case &amp;quot;bare_metal&amp;quot;:
        return nil
    }
    return errors.New(&amp;quot;CheckHostType ERROR:&amp;quot; + host_type)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以看出，该函数失败的原因只有一个，所以返回值的类型应该为bool，而不是error，重构一下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (self *AgentContext) IsValidHostType(hostType string) bool {
    return hostType == &amp;quot;virtual_machine&amp;quot; || hostType == &amp;quot;bare_metal&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：大多数情况，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息，这时的返回值类型不再是简单的bool，而是error。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;姿势二：没有失败时，不使用error&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;error在Golang中是如此的流行，以至于很多人设计函数时不管三七二十一都使用error，即使没有一个失败原因。
我们看一下示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (self *CniParam) setTenantId() error {
    self.TenantId = self.PodNs
    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于上面的函数设计，就会有下面的调用代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;err := self.setTenantId()
if err != nil {
    // log
    // free resource
    return errors.New(...)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据我们的正确姿势，重构一下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (self *CniParam) setTenantId() {
    self.TenantId = self.PodNs
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是调用代码变为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;self.setTenantId()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;姿势三：error应放在返回值类型列表的最后&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于返回值类型error，用来传递错误信息，在Golang中通常放在最后一个。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;resp, err := http.Get(url)
if err != nil {
    return nill, err
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bool作为返回值类型时也一样。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;value, ok := cache.Lookup(key) 
if !ok {
    // ...cache[key] does not exist… 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;姿势四：错误值统一定义，而不是跟着感觉走&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多人写代码时，到处return errors.New(value)，而错误value在表达同一个含义时也可能形式不同，比如“记录不存在”的错误value可能为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;quot;record is not existed.&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;record is not exist!&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;###record is not existed！！！&amp;quot;&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这使得相同的错误value撒在一大片代码里，当上层函数要对特定错误value进行统一处理时，需要漫游所有下层代码，以保证错误value统一，不幸的是有时会有漏网之鱼，而且这种方式严重阻碍了错误value的重构。&lt;/p&gt;
&lt;p&gt;于是，我们可以参考C/C++的错误码定义文件，在Golang的每个包中增加一个错误对象定义文件，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var ERR_EOF = errors.New(&amp;quot;EOF&amp;quot;)
var ERR_CLOSED_PIPE = errors.New(&amp;quot;io: read/write on closed pipe&amp;quot;)
var ERR_NO_PROGRESS = errors.New(&amp;quot;multiple Read calls return no data or error&amp;quot;)
var ERR_SHORT_BUFFER = errors.New(&amp;quot;short buffer&amp;quot;)
var ERR_SHORT_WRITE = errors.New(&amp;quot;short write&amp;quot;)
var ERR_UNEXPECTED_EOF = errors.New(&amp;quot;unexpected EOF&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;姿势五：错误逐层传递时，层层都加日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;层层都加日志非常方便故障定位。&lt;/p&gt;
&lt;p&gt;说明：至于通过测试来发现故障，而不是日志，目前很多团队还很难做到。如果你或你的团队能做到，那么请忽略这个姿势。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;姿势六：错误处理使用defer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们一般通过判断error的值来处理错误，如果当前操作失败，需要将本函数中已经create的资源destroy掉，示例代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func deferDemo() error {
    err := createResource1()
    if err != nil {
        return ERR_CREATE_RESOURCE1_FAILED
    }
    err = createResource2()
    if err != nil {
        destroyResource1()
        return ERR_CREATE_RESOURCE2_FAILED
    }

    err = createResource3()
    if err != nil {
        destroyResource1()
        destroyResource2()
        return ERR_CREATE_RESOURCE3_FAILED
    }

    err = createResource4()
    if err != nil {
        destroyResource1()
        destroyResource2()
        destroyResource3()
        return ERR_CREATE_RESOURCE4_FAILED
    } 
    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当Golang的代码执行时，如果遇到defer的闭包调用，则压入堆栈。当函数返回时，会按照后进先出的顺序调用闭包。
&lt;strong&gt;对于闭包的参数是值传递，而对于外部变量却是引用传递，所以闭包中的外部变量err的值就变成外部函数返回时最新的err值。&lt;/strong&gt;
根据这个结论，我们重构上面的示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func deferDemo() error {
    err := createResource1()
    if err != nil {
        return ERR_CREATE_RESOURCE1_FAILED
    }
    defer func() {
        if err != nil {
            destroyResource1()
        }
    }()
    err = createResource2()
    if err != nil {
        return ERR_CREATE_RESOURCE2_FAILED
    }
    defer func() {
        if err != nil {
            destroyResource2()
                   }
    }()

    err = createResource3()
    if err != nil {
        return ERR_CREATE_RESOURCE3_FAILED
    }
    defer func() {
        if err != nil {
            destroyResource3()
        }
    }()

    err = createResource4()
    if err != nil {
        return ERR_CREATE_RESOURCE4_FAILED
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;姿势七：当尝试几次可以避免失败时，不要立即返回错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果错误的发生是偶然性的，或由不可预知的问题导致。一个明智的选择是重新尝试失败的操作，有时第二次或第三次尝试时会成功。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。&lt;/p&gt;
&lt;p&gt;两个案例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们平时上网时，尝试请求某个URL，有时第一次没有响应，当我们再次刷新时，就有了惊喜。&lt;/li&gt;
&lt;li&gt;团队的一个QA曾经建议当Neutron的attach操作失败时，最好尝试三次，这在当时的环境下验证果然是有效的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;姿势八：当上层函数不关心错误时，建议不返回error&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一些资源清理相关的函数（destroy/delete/clear），如果子函数出错，打印日志即可，而无需将错误进一步反馈到上层函数，因为一般情况下，上层函数是不关心执行结果的，或者即使关心也无能为力，于是我们建议将相关函数设计为不返回error。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;姿势九：当发生错误时，不忽略有用的返回值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常，当函数返回non-nil的error时，其他的返回值是未定义的(undefined)，这些未定义的返回值应该被忽略。然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，应该将读取到的字符串和错误信息一起打印出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：对函数的返回值要有清晰的说明，以便于其他人使用。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;17-异常处理的正确姿势&#34;&gt;1.7 异常处理的正确姿势&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;姿势一：在程序开发阶段，坚持速错&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;速错，简单来讲就是“让它挂”，只有挂了你才会第一时间知道错误。在早期开发以及任何发布阶段之前，最简单的同时也可能是最好的方法是调用panic函数来中断程序的执行以强制发生错误，使得该错误不会被忽略，因而能够被尽快修复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;姿势二：在程序部署后，应恢复异常避免程序终止&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Golang中，某个Goroutine如果panic了，并且没有recover，那么整个Golang进程就会异常退出。所以，一旦Golang程序部署后，在任何情况下发生的异常都不应该导致程序异常退出，我们在上层函数中加一个延迟执行的recover调用来达到这个目的，并且是否进行recover需要根据环境变量或配置文件来定，默认需要recover。
这个姿势类似于C语言中的断言，但还是有区别：一般在Release版本中，断言被定义为空而失效，但需要有if校验存在进行异常保护，尽管契约式设计中不建议这样做。在Golang中，recover完全可以终止异常展开过程，省时省力。&lt;/p&gt;
&lt;p&gt;我们在调用recover的延迟函数中以最合理的方式响应该异常：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打印堆栈的异常调用信息和关键的业务信息，以便这些问题保留可见；&lt;/li&gt;
&lt;li&gt;将异常转换为错误，以便调用者让程序恢复到健康状态并继续安全运行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们看一个简单的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func funcA() error {
    defer func() {
        if p := recover(); p != nil {
            fmt.Printf(&amp;quot;panic recover! p: %v&amp;quot;, p)
            debug.PrintStack()
        }
    }()
    return funcB()
}

func funcB() error {
    // simulation
    panic(&amp;quot;foo&amp;quot;)
    return errors.New(&amp;quot;success&amp;quot;)
}

func test() {
    err := funcA()
    if err == nil {
        fmt.Printf(&amp;quot;err is nil\\n&amp;quot;)
    } else {
        fmt.Printf(&amp;quot;err is %v\\n&amp;quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们期望test函数的输出是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;err is foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上test函数的输出是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;err is nil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因是panic异常处理机制不会自动将错误信息传递给error，所以要在funcA函数中进行显式的传递，代码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func funcA() (err error) {
    defer func() {
        if p := recover(); p != nil {
            fmt.Println(&amp;quot;panic recover! p:&amp;quot;, p)
            str, ok := p.(string)
            if ok {
                err = errors.New(str)
            } else {
                err = errors.New(&amp;quot;panic&amp;quot;)
            }
            debug.PrintStack()
        }
    }()
    return funcB()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;姿势三：对于不应该出现的分支，使用异常处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当某些不应该发生的场景发生时，我们就应该调用panic函数来触发异常。比如，当程序到达了某条逻辑上不可能到达的路径：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;switch s := suit(drawCard()); s {
    case &amp;quot;Spades&amp;quot;:
    // ...
    case &amp;quot;Hearts&amp;quot;:
    // ...
    case &amp;quot;Diamonds&amp;quot;:
    // ... 
    case &amp;quot;Clubs&amp;quot;:
    // ...
    default:
        panic(fmt.Sprintf(&amp;quot;invalid suit %v&amp;quot;, s))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;姿势四：针对入参不应该有问题的函数，使用panic设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;入参不应该有问题一般指的是硬编码，我们先看这两个函数（Compile和MustCompile），其中MustCompile函数是对Compile函数的包装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func MustCompile(str string) *Regexp {
    regexp, error := Compile(str)
    if error != nil {
        panic(`regexp: Compile(` + quote(str) + `): ` + error.Error())
    }
    return regexp
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以，对于同时支持用户输入场景和硬编码场景的情况，一般支持硬编码场景的函数是对支持用户输入场景函数的包装。
对于只支持硬编码单一场景的情况，函数设计时直接使用panic，即返回值类型列表中不会有error，这使得函数的调用处理非常方便（没有了乏味的&amp;quot;if err != nil {/ 打印 &amp;amp;&amp;amp; 错误处理 /}&amp;quot;代码块）。&lt;/p&gt;
&lt;p&gt;本文部分内容引自https://www.jianshu.com/p/f30da01eea97&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_advanced&#34;&gt;https://github.com/rubyhan1314/go_advanced&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>第一个程序：HelloWorld</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC8%E8%8A%82_%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8Fhelloworld/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC8%E8%8A%82_%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8Fhelloworld/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;第一个程序helloworld&#34;&gt;第一个程序：HelloWorld&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一go项目工程结构&#34;&gt;一、go项目工程结构&lt;/h2&gt;
&lt;p&gt;配置好工作目录后，就可以编码开发了，在这之前，我们看下go的通用项目结构，这里的结构主要是源代码相应地资源文件存放目录结构。&lt;/p&gt;
&lt;h3 id=&#34;11-gopath目录&#34;&gt;1.1 gopath目录&lt;/h3&gt;
&lt;p&gt;gopath目录就是我们存储我们所编写源代码的目录。该目录下往往要有3个子目录：src，bin，pkg。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;src ---- 里面每一个子目录，就是一个包。包内是Go的源码文件&lt;/p&gt;
&lt;p&gt;pkg ---- 编译后生成的，包的目标文件&lt;/p&gt;
&lt;p&gt;bin ---- 生成的可执行文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-编写第一个程序&#34;&gt;1.2 编写第一个程序&lt;/h3&gt;
&lt;p&gt;每个编程语言的学习，都是从一个&amp;quot;Hello, World.&amp;quot;程序开始的，这个例子首次出现于1978年出版的C语言圣经《The C Programming Language》。关于&amp;quot;Hello, World.&amp;quot;还有一个很美好的故事，那就是所有的程序员期待着计算机有一天能拥有真正的智能，然后对创造他的人们&amp;quot;发自内心&amp;quot;的说一句，Hello, World。&lt;/p&gt;
&lt;p&gt;1.在HOME/go的目录下，(就是GOPATH目录里)，创建一个目录叫src，然后再该目录下创建一个文件夹叫hello，在该目录下创建一个文件叫helloworld.go，并双击打开，输入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   fmt.Println(&amp;quot;Hello, World!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.执行go程序&lt;/p&gt;
&lt;p&gt;执行go程序由几种方式&lt;/p&gt;
&lt;p&gt;方式一：使用go run命令&lt;/p&gt;
&lt;p&gt;​	step1：打开终端：&lt;/p&gt;
&lt;p&gt;​			window下使用快捷键win+R，输入cmd打开命令行提示符&lt;/p&gt;
&lt;p&gt;​			linux下可以使用快捷键：ctrl+alt+T&lt;/p&gt;
&lt;p&gt;​			mac下command+空格，输入termainl&lt;/p&gt;
&lt;p&gt;​	step2：进入helloworld.go所在的目录&lt;/p&gt;
&lt;p&gt;​	step3：输入go run helloworld.go命令并观察运行结果。&lt;/p&gt;
&lt;p&gt;方式二：使用go build命令&lt;/p&gt;
&lt;p&gt;​	step1：打开终端：在任意文件路径下，运行:
​			go install hello&lt;/p&gt;
&lt;p&gt;​		也可以进入项目(应用包)的路径，然后运行：
​			go install&lt;/p&gt;
&lt;p&gt;注意，在编译生成go程序的时，go实际上会去两个地方找程序包：
GOROOT下的src文件夹下，以及GOPATH下的src文件夹下。&lt;/p&gt;
&lt;p&gt;在程序包里，自动找main包的main函数作为程序入口，然后进行编译。&lt;/p&gt;
&lt;p&gt;​	step2：运行go程序
​		在/home/go/bin/下(如果之前没有bin目录则会自动创建)，会发现出现了一个hello的可执行文件，用如下命令运行:
​		./hello&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h3 id=&#34;13-第一个程序的解释说明&#34;&gt;1.3 第一个程序的解释说明&lt;/h3&gt;
&lt;h4 id=&#34;321-package&#34;&gt;3.2.1 package&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在同一个包下面的文件属于同一个工程文件，不用&lt;code&gt;import&lt;/code&gt;包，可以直接使用&lt;/li&gt;
&lt;li&gt;在同一个包下面的所有文件的package名，都是一样的&lt;/li&gt;
&lt;li&gt;在同一个包下面的文件&lt;code&gt;package&lt;/code&gt;名都建议设为是该目录名，但也可以不是&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;322--import&#34;&gt;3.2.2  import&lt;/h4&gt;
&lt;p&gt;import &amp;quot;fmt&amp;quot; 告诉 Go 编译器这个程序需要使用 fmt 包的函数，fmt 包实现了格式化 IO（输入/输出）的函数&lt;/p&gt;
&lt;p&gt;可以是相对路径也可以是绝对路径，推荐使用绝对路径（起始于工程根目录）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;点操作
我们有时候会看到如下的方式导入包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import(
	. &amp;quot;fmt&amp;quot;
) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调&lt;/p&gt;
&lt;p&gt;用的&lt;code&gt;fmt.Println(&amp;quot;hello world&amp;quot;)&lt;/code&gt;可以省略的写成&lt;code&gt;Println(&amp;quot;hello world&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;别名操作
别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import(
	f &amp;quot;fmt&amp;quot;
) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;别名操作的话调用包函数时前缀变成了我们的前缀，即&lt;code&gt;f.Println(&amp;quot;hello world&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;_操作
这个操作经常是让很多人费解的一个操作符，请看下面这个import&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
  &amp;quot;database/sql&amp;quot;
  _ &amp;quot;github.com/ziutek/mymysql/godrv&amp;quot;
) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;_操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;333-main&#34;&gt;3.3.3 main&lt;/h4&gt;
&lt;p&gt;main(),是程序运行的入口。&lt;/p&gt;
&lt;h3 id=&#34;14-包的说明&#34;&gt;1.4 包的说明&lt;/h3&gt;
&lt;p&gt;我们知道源代码都是存放在GOPATH的src目录下，那么多个多个项目的时候，怎么区分呢？答案是通过包，使用包来组织我们的项目目录结构。有过java开发的都知道，使用包进行组织代码，包以网站域名开头就不会有重复，比如千锋的网站是&lt;code&gt;http://www.mobiletrain.org&lt;/code&gt;，我们就可以以&lt;code&gt;mobiletrain.org&lt;/code&gt;的名字创建一个文件夹，我自己的go项目都放在这个文件夹里，这样就不会和其他人的项目冲突，包名也是唯一的。&lt;/p&gt;
&lt;p&gt;如果有自己的域名，那也可以使用自己的域名。如果没有个人域名，现在流行的做法是使用你个人的github名，因为每个人的是唯一的，所以也不会有重复。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://7xtcwd.com1.z0.glb.clouddn.com/package1.png&#34; alt=&#34;package1&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上，src目录下跟着一个个域名命名的文件夹。再以github.com文件夹为例，它里面又是以github用户名命名的文件夹，用于存储属于这个github用户编写的go源代码。&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>反射reflect</title>
                <link>http://www.songx.fun/blog/day16-20go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/day19_go%E8%AF%AD%E8%A8%80%E5%8F%8D%E5%B0%84/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day16-20go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/day19_go%E8%AF%AD%E8%A8%80%E5%8F%8D%E5%B0%84/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;#反射reflect&lt;/p&gt;
&lt;h2 id=&#34;一引入&#34;&gt;一、引入&lt;/h2&gt;
&lt;p&gt;先看官方Doc中Rob Pike给出的关于反射的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Reflection in computing is the ability of a program to examine its own structure, particularly through types; it’s a form of metaprogramming. It’s also a great source of confusion.
(在计算机领域，反射是一种让程序——主要是通过类型——理解其自身结构的一种能力。它是元编程的组成之一，同时它也是一大引人困惑的难题。)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;维基百科中的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不同语言的反射模型不尽相同，有些语言还不支持反射。《Go 语言圣经》中是这样定义反射的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么要用反射&lt;/p&gt;
&lt;p&gt;需要反射的 2 个常见场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有时你需要编写一个函数，但是并不知道传给你的参数类型是什么，可能是没约定好；也可能是传入的类型很多，这些类型并不能统一表示。这时反射就会用的上了。&lt;/li&gt;
&lt;li&gt;有时候需要根据某些条件决定调用哪个函数，比如根据用户的输入来决定。这时就需要对函数和函数的参数进行反射，在运行期间动态地执行函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是对于反射，还是有几点不太建议使用反射的理由：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;与反射相关的代码，经常是难以阅读的。在软件工程中，代码可读性也是一个非常重要的指标。&lt;/li&gt;
&lt;li&gt;Go 语言作为一门静态语言，编码过程中，编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。所以包含反射相关的代码，很可能会运行很久，才会出错，这时候经常是直接 panic，可能会造成严重的后果。&lt;/li&gt;
&lt;li&gt;反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。所以，对于一个项目中处于运行效率关键位置的代码，尽量避免使用反射特性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二相关基础&#34;&gt;二、相关基础&lt;/h2&gt;
&lt;p&gt;反射是如何实现的？我们以前学习过 interface，它是 Go 语言实现抽象的一个非常强大的工具。当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息，反射就是通过接口的类型信息实现的，反射建立在类型的基础上。&lt;/p&gt;
&lt;p&gt;Go 语言在 reflect 包里定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息、改变类型的值。在进行更加详细的了解之前，我们需要重新温习一下Go语言相关的一些特性，所谓温故知新，从这些特性中了解其反射机制是如何使用的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特点&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;go语言是静态类型语言。&lt;/td&gt;
&lt;td&gt;编译时类型已经确定，比如对已基本数据类型的再定义后的类型，反射时候需要确认返回的是何种类型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;空接口interface{}&lt;/td&gt;
&lt;td&gt;go的反射机制是要通过接口来进行的，而类似于Java的Object的空接口可以和任何类型进行交互，因此对基本数据类型等的反射也直接利用了这一特点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go语言的类型：&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;变量包括（type, value）两部分&lt;/p&gt;
&lt;p&gt;​	理解这一点就知道为什么nil != nil了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类型断言能否成功，取决于变量的concrete type，而不是static type。因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Go是静态类型语言。每个变量都拥有一个静态类型，这意味着每个变量的类型在编译时都是确定的：int，float32, *AutoType, []byte,  chan []int 诸如此类。&lt;/p&gt;
&lt;p&gt;在反射的概念中， 编译时就知道变量类型的是静态类型；运行时才知道一个变量类型的叫做动态类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态类型
静态类型就是变量声明时的赋予的类型。比如：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type MyInt int // int 就是静态类型

type A struct{
   Name string  // string就是静态
}
var i *int  // *int就是静态类型

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;动态类型
动态类型：运行时给这个变量赋值时，这个值的类型(如果值为nil的时候没有动态类型)。一个变量的动态类型在运行时可能改变，这主要依赖于它的赋值（前提是这个变量是接口类型）。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var A interface{} // 静态类型interface{}
A = 10            // 静态类型为interface{}  动态为int
A = &amp;quot;String&amp;quot;      // 静态类型为interface{}  动态为string
var M *int
A = M             // A的值可以改变

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go语言的反射就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。&lt;/p&gt;
&lt;p&gt;在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;(value, type)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;value是实际变量值，type是实际变量的类型。一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】。&lt;/p&gt;
&lt;p&gt;例如，创建类型为*os.File的变量，然后将其赋给一个接口变量r：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;tty, err := os.OpenFile(&amp;quot;/dev/tty&amp;quot;, os.O_RDWR, 0)

var r io.Reader
r = tty
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口变量r的pair中将记录如下信息：(tty, *os.File)，这个pair在接口变量的连续赋值过程中是不变的，将接口变量r赋给另一个接口变量w:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var w io.Writer
w = r.(io.Writer)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口变量w的pair与r的pair相同，都是:(tty, *os.File)，即使w是空接口类型，pair也是不变的。&lt;/p&gt;
&lt;p&gt;interface及其pair的存在，是Golang中实现反射的前提，理解了pair，就更容易理解反射。反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。&lt;/p&gt;
&lt;p&gt;所以我们要理解两个基本概念 Type 和 Value，它们也是 Go语言包中 reflect 空间里最重要的两个类型。&lt;/p&gt;
&lt;h2 id=&#34;三type和value&#34;&gt;三、Type和Value&lt;/h2&gt;
&lt;p&gt;我们一般用到的包是reflect包。&lt;/p&gt;
&lt;p&gt;既然反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。那么在Golang的reflect反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？ 它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是reflect.ValueOf() 和 reflect.TypeOf()，看看官方的解释&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ValueOf returns a new Value initialized to the concrete value
// stored in the interface i.  ValueOf(nil) returns the zero 
func ValueOf(i interface{}) Value {...}

翻译一下：ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0


// TypeOf returns the reflection Type that represents the dynamic type of i.
// If i is a nil interface value, TypeOf returns nil.
func TypeOf(i interface{}) Type {...}

翻译一下：TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;reflect.TypeOf()是获取pair中的type，reflect.ValueOf()获取pair中的value。&lt;/p&gt;
&lt;p&gt;首先需要把它转化成reflect对象(reflect.Type或者reflect.Value，根据不同的情况调用不同的函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;t := reflect.TypeOf(i) //得到类型的元数据,通过t我们能获取类型定义里面的所有元素
v := reflect.ValueOf(i) //得到实际的值，通过v我们获取存储在里面的值，还可以去改变值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;reflect&amp;quot;
)

func main() {
	//反射操作：通过反射，可以获取一个接口类型变量的 类型和数值
	var x float64 =3.4

	fmt.Println(&amp;quot;type:&amp;quot;,reflect.TypeOf(x)) //type: float64
	fmt.Println(&amp;quot;value:&amp;quot;,reflect.ValueOf(x)) //value: 3.4

	fmt.Println(&amp;quot;-------------------&amp;quot;)
	//根据反射的值，来获取对应的类型和数值
	v := reflect.ValueOf(x)
	fmt.Println(&amp;quot;kind is float64: &amp;quot;,v.Kind() == reflect.Float64)
	fmt.Println(&amp;quot;type : &amp;quot;,v.Type())
	fmt.Println(&amp;quot;value : &amp;quot;,v.Float())
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: float64
value: 3.4
-------------------
kind is float64:  true
type :  float64
value :  3.4

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型&lt;/li&gt;
&lt;li&gt;reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;amp;{1 &amp;quot;Allen.Wu&amp;quot; 25} 这样的结构体struct的值&lt;/li&gt;
&lt;li&gt;也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Type 和 Value 都包含了大量的方法，其中第一个有用的方法应该是 Kind，这个方法返回该类型的具体信息：Uint、Float64 等。Value 类型还包含了一系列类型方法，比如 Int()，用于返回对应的值。以下是Kind的种类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
// A Kind represents the specific kind of type that a Type represents.
// The zero Kind is not a valid kind.
type Kind uint

const (
	Invalid Kind = iota
	Bool
	Int
	Int8
	Int16
	Int32
	Int64
	Uint
	Uint8
	Uint16
	Uint32
	Uint64
	Uintptr
	Float32
	Float64
	Complex64
	Complex128
	Array
	Chan
	Func
	Interface
	Map
	Ptr
	Slice
	String
	Struct
	UnsafePointer
)

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四反射的规则&#34;&gt;四、反射的规则&lt;/h2&gt;
&lt;p&gt;其实反射的操作步骤非常的简单，就是通过实体对象获取反射对象(Value、Type)，然后操作相应的方法即可。&lt;/p&gt;
&lt;p&gt;下图描述了实例、Value、Type 三者之间的转换关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190827-170219.png&#34; alt=&#34;WX20190827-170219&#34;&gt;&lt;/p&gt;
&lt;p&gt;反射 API 的分类总结如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) 从实例到 Value&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过实例获取 Value 对象，直接使用 reflect.ValueOf() 函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ValueOf(i interface {}) Value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2) 从实例到 Type&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过实例获取反射对象的 Type，直接使用 reflect.TypeOf() 函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TypeOf(i interface{}) Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3) 从 Type 到 Value&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Type 里面只有类型信息，所以直接从一个 Type 接口变量里面是无法获得实例的 Value 的，但可以通过该 Type 构建一个新实例的 Value。reflect 包提供了两种方法，示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//New 返回的是一个 Value，该 Value 的 type 为 PtrTo(typ)，即 Value 的 Type 是指定 typ 的指针类型
func New(typ Type) Value
//Zero 返回的是一个 typ 类型的零佳，注意返回的 Value 不能寻址，位不可改变
func Zero(typ Type) Value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果知道一个类型值的底层存放地址，则还有一个函数是可以依据 type 和该地址值恢复出 Value 的。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewAt(typ Type, p unsafe.Pointer) Value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4) 从 Value 到 Type&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从反射对象 Value 到 Type 可以直接调用 Value 的方法，因为 Value 内部存放着到 Type 类型的指针。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (v Value) Type() Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5) 从 Value 到实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Value 本身就包含类型和值信息，reflect 提供了丰富的方法来实现从 Value 到实例的转换。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//该方法最通用，用来将 Value 转换为空接口，该空接口内部存放具体类型实例
//可以使用接口类型查询去还原为具体的类型
func (v Value) Interface() （i interface{})

//Value 自身也提供丰富的方法，直接将 Value 转换为简单类型实例，如果类型不匹配，则直接引起 panic
func (v Value) Bool () bool
func (v Value) Float() float64
func (v Value) Int() int64
func (v Value) Uint() uint64
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6) 从 Value 的指针到值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从一个指针类型的 Value 获得值类型 Value 有两种方法，示例如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//如果 v 类型是接口，则 Elem() 返回接口绑定的实例的 Value，如采 v 类型是指针，则返回指针值的 Value，否则引起 panic
func (v Value) Elem() Value
//如果 v 是指针，则返回指针值的 Value，否则返回 v 自身，该函数不会引起 panic
func Indirect(v Value) Value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;7) Type 指针和值的相互转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指针类型 Type 到值类型 Type。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//t 必须是 Array、Chan、Map、Ptr、Slice，否则会引起 panic
//Elem 返回的是其内部元素的 Type
t.Elem() Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值类型 Type 到指针类型 Type。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//PtrTo 返回的是指向 t 的指针型 Type
func PtrTo(t Type) Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;8) Value 值的可修改性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Value 值的修改涉及如下两个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//通过 CanSet 判断是否能修改
func (v Value ) CanSet() bool
//通过 Set 进行修改
func (v Value ) Set(x Value)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Value 值在什么情况下可以修改？我们知道实例对象传递给接口的是一个完全的值拷贝，如果调用反射的方法 reflect.ValueOf() 传进去的是一个值类型变量， 则获得的 Value 实际上是原对象的一个副本，这个 Value 是无论如何也不能被修改的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据 Go 官方关于反射的博客，反射有三大定律：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Reflection goes from interface value to reflection object.&lt;/li&gt;
&lt;li&gt;Reflection goes from reflection object to interface value.&lt;/li&gt;
&lt;li&gt;To modify a reflection object, the value must be settable.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一条是最基本的：反射可以从接口值得到反射对象。&lt;/p&gt;
&lt;p&gt;​		反射是一种检测存储在 interface中的类型和值机制。这可以通过 TypeOf函数和 ValueOf函数得到。&lt;/p&gt;
&lt;p&gt;第二条实际上和第一条是相反的机制，反射可以从反射对象获得接口值。&lt;/p&gt;
&lt;p&gt;​		它将 ValueOf的返回值通过 Interface()函数反向转变成 interface变量。&lt;/p&gt;
&lt;p&gt;前两条就是说 接口型变量和 反射类型对象可以相互转化，反射类型对象实际上就是指的前面说的 reflect.Type和 reflect.Value。&lt;/p&gt;
&lt;p&gt;第三条不太好懂：如果需要操作一个反射变量，则其值必须可以修改。&lt;/p&gt;
&lt;p&gt;​		反射变量可设置的本质是它存储了原变量本身，这样对反射变量的操作，就会反映到原变量本身；反之，如果反射变量不能代表原变量，那么操作了反射变量，不会对原变量产生任何影响，这会给使用者带来疑惑。所以第二种情况在语言层面是不被允许的。&lt;/p&gt;
&lt;h2 id=&#34;五反射的使用&#34;&gt;五、反射的使用&lt;/h2&gt;
&lt;h3 id=&#34;51-从relfectvalue中获取接口interface的信息&#34;&gt;5.1 从relfect.Value中获取接口interface的信息&lt;/h3&gt;
&lt;p&gt;当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。不过，我们可能是已知原有类型，也有可能是未知原有类型，因此，下面分两种情况进行说明。&lt;/p&gt;
&lt;h4 id=&#34;已知原有类型&#34;&gt;已知原有类型&lt;/h4&gt;
&lt;p&gt;已知类型后转换为其对应的类型的做法如下，直接通过Interface方法然后强制转换，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;realValue := value.Interface().(已知的类型)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;reflect&amp;quot;
)

func main() {
	var num float64 = 1.2345

	pointer := reflect.ValueOf(&amp;amp;num)
	value := reflect.ValueOf(num)

	// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic
	// Golang 对类型要求非常严格，类型一定要完全符合
	// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic
	convertPointer := pointer.Interface().(*float64)
	convertValue := value.Interface().(float64)

	fmt.Println(convertPointer)
	fmt.Println(convertValue)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0xc000098000
1.2345
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;转换的时候，如果转换的类型不完全符合，则直接panic，类型要求非常严格！&lt;/li&gt;
&lt;li&gt;转换的时候，要区分是指针还是指&lt;/li&gt;
&lt;li&gt;也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;未知原有类型&#34;&gt;未知原有类型&lt;/h4&gt;
&lt;p&gt;很多情况下，我们可能并不知道其具体类型，那么这个时候，该如何做呢？需要我们进行遍历探测其Filed来得知，示例如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;reflect&amp;quot;
)




type Person struct {
	Name string
	Age int
	Sex string
}

func (p Person)Say(msg string)  {
	fmt.Println(&amp;quot;hello，&amp;quot;,msg)
}
func (p Person)PrintInfo()  {
	fmt.Printf(&amp;quot;姓名：%s,年龄：%d，性别：%s\n&amp;quot;,p.Name,p.Age,p.Sex)
}



func main() {
	p1 := Person{&amp;quot;王二狗&amp;quot;,30,&amp;quot;男&amp;quot;}

	DoFiledAndMethod(p1)

}

// 通过接口来获取任意参数
func DoFiledAndMethod(input interface{}) {

	getType := reflect.TypeOf(input) //先获取input的类型
	fmt.Println(&amp;quot;get Type is :&amp;quot;, getType.Name()) // Person
	fmt.Println(&amp;quot;get Kind is : &amp;quot;, getType.Kind()) // struct

	getValue := reflect.ValueOf(input)
	fmt.Println(&amp;quot;get all Fields is:&amp;quot;, getValue) //{王二狗 30 男}

	// 获取方法字段
	// 1. 先获取interface的reflect.Type，然后通过NumField进行遍历
	// 2. 再通过reflect.Type的Field获取其Field
	// 3. 最后通过Field的Interface()得到对应的value
	for i := 0; i &amp;lt; getType.NumField(); i++ {
		field := getType.Field(i)
		value := getValue.Field(i).Interface() //获取第i个值
		fmt.Printf(&amp;quot;字段名称:%s, 字段类型:%s, 字段数值:%v \n&amp;quot;, field.Name, field.Type, value)
	}

	// 通过反射，操作方法
	// 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历
	// 2. 再公国reflect.Type的Method获取其Method
	for i := 0; i &amp;lt; getType.NumMethod(); i++ {
		method := getType.Method(i)
		fmt.Printf(&amp;quot;方法名称:%s, 方法类型:%v \n&amp;quot;, method.Name, method.Type)
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get Type is : Person
get Kind is :  struct
get all Fields is: {王二狗 30 男}
字段名称:Name, 字段类型:string, 字段数值:王二狗 
字段名称:Age, 字段类型:int, 字段数值:30 
字段名称:Sex, 字段类型:string, 字段数值:男 
方法名称:PrintInfo, 方法类型:func(main.Person) 
方法名称:Say, 方法类型:func(main.Person, string) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;p&gt;通过运行结果可以得知获取未知类型的interface的具体变量及其类型的步骤为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先获取interface的reflect.Type，然后通过NumField进行遍历&lt;/li&gt;
&lt;li&gt;再通过reflect.Type的Field获取其Field&lt;/li&gt;
&lt;li&gt;最后通过Field的Interface()得到对应的value&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先获取interface的reflect.Type，然后通过NumMethod进行遍历&lt;/li&gt;
&lt;li&gt;再分别通过reflect.Type的Method获取对应的真实的方法（函数）&lt;/li&gt;
&lt;li&gt;最后对结果取其Name和Type得知具体的方法名&lt;/li&gt;
&lt;li&gt;也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”&lt;/li&gt;
&lt;li&gt;struct 或者 struct 的嵌套都是一样的判断处理方式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果是struct的话，可以使用Elem()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;tag := t.Elem().Field(0).Tag //获取定义在struct里面的Tag属性
name := v.Elem().Field(0).String() //获取存储在第一个字段里面的值
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;52-通过reflectvalue设置实际变量的值&#34;&gt;5.2 通过reflect.Value设置实际变量的值&lt;/h3&gt;
&lt;p&gt;reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。&lt;/p&gt;
&lt;p&gt;这里需要一个方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190826-143547.png&#34; alt=&#34;WX20190826-143547&#34;&gt;&lt;/p&gt;
&lt;p&gt;解释起来就是：Elem返回接口v包含的值或指针v指向的值。如果v的类型不是interface或ptr，它会恐慌。如果v为零，则返回零值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;reflect&amp;quot;
)

func main() {

	var num float64 = 1.2345
	fmt.Println(&amp;quot;old value of pointer:&amp;quot;, num)

	// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值
	pointer := reflect.ValueOf(&amp;amp;num)
	newValue := pointer.Elem()

	fmt.Println(&amp;quot;type of pointer:&amp;quot;, newValue.Type())
	fmt.Println(&amp;quot;settability of pointer:&amp;quot;, newValue.CanSet())

	// 重新赋值
	newValue.SetFloat(77)
	fmt.Println(&amp;quot;new value of pointer:&amp;quot;, num)

	////////////////////
	// 如果reflect.ValueOf的参数不是指针，会如何？
	//pointer = reflect.ValueOf(num)
	//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;old value of pointer: 1.2345
type of pointer: float64
settability of pointer: true
new value of pointer: 77
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要传入的参数是* float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，&lt;strong&gt;注意一定要是指针&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果传入的参数不是指针，而是变量，那么
&lt;ul&gt;
&lt;li&gt;通过Elem获取原始值对应的对象则直接panic&lt;/li&gt;
&lt;li&gt;通过CanSet方法查询是否可以设置返回false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。&lt;/li&gt;
&lt;li&gt;reflect.Value.Elem() 表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的&lt;/li&gt;
&lt;li&gt;也就是说如果要修改反射类型对象，其值必须是“addressable”【对应的要传入的是指针，同时要通过Elem方法获取原始值对应的反射对象】&lt;/li&gt;
&lt;li&gt;struct 或者 struct 的嵌套都是一样的判断处理方式&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;53-通过reflectvalue来进行方法的调用&#34;&gt;5.3 通过reflect.Value来进行方法的调用&lt;/h3&gt;
&lt;p&gt;这算是一个高级用法了，前面我们只说到对类型、变量的几种反射的用法，包括如何获取其值、其类型、以及如何重新设置新值。但是在项目应用中，另外一个常用并且属于高级的用法，就是通过reflect来进行方法【函数】的调用。比如我们要做框架工程的时候，需要可以随意扩展方法，或者说用户可以自定义方法，那么我们通过什么手段来扩展让用户能够自定义呢？关键点在于用户的自定义方法是未可知的，因此我们可以通过reflect来搞定。&lt;/p&gt;
&lt;p&gt;Call()方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190902-144001.png&#34; alt=&#34;WX20190902-144001&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过反射，调用方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先获取结构体对象，然后&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;reflect&amp;quot;
)




type Person struct {
	Name string
	Age int
	Sex string
}

func (p Person)Say(msg string)  {
	fmt.Println(&amp;quot;hello，&amp;quot;,msg)
}
func (p Person)PrintInfo()  {
	fmt.Printf(&amp;quot;姓名：%s,年龄：%d，性别：%s\n&amp;quot;,p.Name,p.Age,p.Sex)
}

func (p Person) Test(i,j int,s string){
	fmt.Println(i,j,s)
}


// 如何通过反射来进行方法的调用？
// 本来可以用结构体对象.方法名称()直接调用的，
// 但是如果要通过反射，
// 那么首先要将方法注册，也就是MethodByName，然后通过反射调动mv.Call

func main() {
	p2 := Person{&amp;quot;Ruby&amp;quot;,30,&amp;quot;男&amp;quot;}
	// 1. 要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，
	// 得到“反射类型对象”后才能做下一步处理
	getValue := reflect.ValueOf(p2)

	// 2.一定要指定参数为正确的方法名
	// 先看看没有参数的调用方法

	methodValue1 := getValue.MethodByName(&amp;quot;PrintInfo&amp;quot;)
	fmt.Printf(&amp;quot;Kind : %s, Type : %s\n&amp;quot;,methodValue1.Kind(),methodValue1.Type())
	methodValue1.Call(nil) //没有参数，直接写nil

	args1 := make([]reflect.Value, 0) //或者创建一个空的切片也可以
	methodValue1.Call(args1)

	// 有参数的方法调用
	methodValue2 := getValue.MethodByName(&amp;quot;Say&amp;quot;)
	fmt.Printf(&amp;quot;Kind : %s, Type : %s\n&amp;quot;,methodValue2.Kind(),methodValue2.Type())
	args2 := []reflect.Value{reflect.ValueOf(&amp;quot;反射机制&amp;quot;)}
	methodValue2.Call(args2)

	methodValue3 := getValue.MethodByName(&amp;quot;Test&amp;quot;)
	fmt.Printf(&amp;quot;Kind : %s, Type : %s\n&amp;quot;,methodValue3.Kind(),methodValue3.Type())
	args3 := []reflect.Value{reflect.ValueOf(100), reflect.ValueOf(200),reflect.ValueOf(&amp;quot;Hello&amp;quot;)}

	methodValue3.Call(args3)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Kind : func, Type : func()
姓名：Ruby,年龄：30，性别：男
姓名：Ruby,年龄：30，性别：男
Kind : func, Type : func(string)
hello， 反射机制
Kind : func, Type : func(int, int, string)
100 200 Hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通过反射，调用函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们要先确认一点，函数像普通的变量一样，之前的章节中我们在讲到函数的本质的时候，是可以把函数作为一种变量类型的，而且是引用类型。如果说Fun()是一个函数，那么f1 := Fun也是可以的，那么f1也是一个函数，如果直接调用f1()，那么运行的就是Fun()函数。&lt;/p&gt;
&lt;p&gt;那么我们就先通过ValueOf()来获取函数的反射对象，可以判断它的Kind，是一个func，那么就可以执行Call()进行函数的调用。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;reflect&amp;quot;
)

func main() {
	//函数的反射
	f1 := fun1
	value := reflect.ValueOf(f1)
	fmt.Printf(&amp;quot;Kind : %s , Type : %s\n&amp;quot;,value.Kind(),value.Type()) //Kind : func , Type : func()

	value2 := reflect.ValueOf(fun2)
	fmt.Printf(&amp;quot;Kind : %s , Type : %s\n&amp;quot;,value2.Kind(),value2.Type()) //Kind : func , Type : func(int, string)


	//通过反射调用函数
	value.Call(nil)

	value2.Call([]reflect.Value{reflect.ValueOf(100),reflect.ValueOf(&amp;quot;hello&amp;quot;)})

}

func fun1(){
	fmt.Println(&amp;quot;我是函数fun1()，无参的。。&amp;quot;)
}

func fun2(i int, s string){
	fmt.Println(&amp;quot;我是函数fun2()，有参数。。&amp;quot;,i,s)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理&lt;/li&gt;
&lt;li&gt;reflect.Value.MethodByName这个MethodByName，需要指定准确真实的方法名字，如果错误将直接panic，MethodByName返回一个函数值对应的reflect.Value方法的名字。&lt;/li&gt;
&lt;li&gt;[]reflect.Value，这个是最终需要调用的方法的参数，可以没有或者一个或者多个，根据实际参数来定。&lt;/li&gt;
&lt;li&gt;reflect.Value的 Call 这个方法，这个方法将最终调用真实的方法，参数务必保持一致，如果reflect.Value.Kind不是一个方法，那么将直接panic。&lt;/li&gt;
&lt;li&gt;本来可以用对象访问方法直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调用methodValue.Call&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;heading&#34;&gt;&lt;/h2&gt;
&lt;p&gt;本文参照：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sohu.com/a/313420275_657921&#34;&gt;http://www.sohu.com/a/313420275_657921&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://studygolang.com/articles/12348?fr=sidebar&#34;&gt;https://studygolang.com/articles/12348?fr=sidebar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://c.biancheng.net/golang/&#34;&gt;http://c.biancheng.net/golang/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;github知识库：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314&#34;&gt;https://github.com/rubyhan1314&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Golang网址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.qfgolang.com/&#34;&gt;https://www.qfgolang.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_reflect&#34;&gt;https://github.com/rubyhan1314/go_reflect&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B9%B6%E5%8F%91/">并发</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>方法</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day14_%E7%AC%AC1%E8%8A%82_%E6%96%B9%E6%B3%95/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day14_%E7%AC%AC1%E8%8A%82_%E6%96%B9%E6%B3%95/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;方法&#34;&gt;方法&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;11-什么是方法&#34;&gt;1.1 什么是方法&lt;/h2&gt;
&lt;p&gt;Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集&lt;/p&gt;
&lt;p&gt;方法只是一个函数，它带有一个特殊的接收器类型，它是在func关键字和方法名之间编写的。接收器可以是struct类型或非struct类型。接收方可以在方法内部访问。&lt;/p&gt;
&lt;p&gt;方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者。&lt;/p&gt;
&lt;p&gt;在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。&lt;/p&gt;
&lt;p&gt;也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。&lt;/p&gt;
&lt;h2 id=&#34;12-方法的语法&#34;&gt;1.2 方法的语法&lt;/h2&gt;
&lt;p&gt;定义方法的语法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (t Type) methodName(parameter list)(return list) {
  
}
func funcName(parameter list)(return list){
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

type Employee struct {  
    name     string
    salary   int
    currency string
}

/*
 displaySalary() method has Employee as the receiver type
*/
func (e Employee) displaySalary() {  
    fmt.Printf(&amp;quot;Salary of %s is %s%d&amp;quot;, e.name, e.currency, e.salary)
}

func main() {  
    emp1 := Employee {
        name:     &amp;quot;Sam Adolf&amp;quot;,
        salary:   5000,
        currency: &amp;quot;$&amp;quot;,
    }
    emp1.displaySalary() //Calling displaySalary() method of Employee type
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;可以定义相同的方法名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math&amp;quot;
)

type Rectangle struct {
	width, height float64
}
type Circle struct {
	radius float64
}


func (r Rectangle) area() float64 {
	return r.width * r.height
}
//该 method 属于 Circle 类型对象中的方法
func (c Circle) area() float64 {
	return c.radius * c.radius * math.Pi
}
func main() {
	r1 := Rectangle{12, 2}
	r2 := Rectangle{9, 4}
	c1 := Circle{10}
	c2 := Circle{25}
	fmt.Println(&amp;quot;Area of r1 is: &amp;quot;, r1.area())
	fmt.Println(&amp;quot;Area of r2 is: &amp;quot;, r2.area())
	fmt.Println(&amp;quot;Area of c1 is: &amp;quot;, c1.area())
	fmt.Println(&amp;quot;Area of c2 is: &amp;quot;, c2.area())
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Area of r1 is:  24
Area of r2 is:  36
Area of c1 is:  314.1592653589793
Area of c2 is:  1963.4954084936207
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样&lt;/li&gt;
&lt;li&gt;method里面可以访问接收者的字段&lt;/li&gt;
&lt;li&gt;调用method通过.访问，就像struct里面访问字段一样&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;13-方法和函数&#34;&gt;1.3 方法和函数&lt;/h2&gt;
&lt;p&gt;既然我们已经有了函数，为什么还要使用方法？&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

type Employee struct {  
    name     string
    salary   int
    currency string
}

/*
 displaySalary() method converted to function with Employee as parameter
*/
func displaySalary(e Employee) {  
    fmt.Printf(&amp;quot;Salary of %s is %s%d&amp;quot;, e.name, e.currency, e.salary)
}

func main() {  
    emp1 := Employee{
        name:     &amp;quot;Sam Adolf&amp;quot;,
        salary:   5000,
        currency: &amp;quot;$&amp;quot;,
    }
    displaySalary(emp1)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在上面的程序中，displaySalary方法被转换为一个函数，而Employee struct作为参数传递给它。这个程序也产生了相同的输出：Salary of Sam Adolf is $5000.。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么我们可以用函数来写相同的程序呢?有以下几个原因&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Go不是一种纯粹面向对象的编程语言，它不支持类。因此，类型的方法是一种实现类似于类的行为的方法。&lt;/li&gt;
&lt;li&gt;相同名称的方法可以在不同的类型上定义，而具有相同名称的函数是不允许的。假设我们有一个正方形和圆形的结构。可以在正方形和圆形上定义一个名为Area的方法。这是在下面的程序中完成的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;14-变量作用域&#34;&gt;1.4 变量作用域&lt;/h2&gt;
&lt;p&gt;作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。&lt;/p&gt;
&lt;p&gt;Go 语言中变量可以在三个地方声明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数内定义的变量称为局部变量&lt;/li&gt;
&lt;li&gt;函数外定义的变量称为全局变量&lt;/li&gt;
&lt;li&gt;函数定义中的变量称为形式参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;局部变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在函数体外声明的变量称之为全局变量，首字母大写全局变量可以在整个包甚至外部包（被导出后）使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

/* 声明全局变量 */
var g int

func main() {

   /* 声明局部变量 */
   var a, b int

   /* 初始化参数 */
   a = 10
   b = 20
   g = a + b

   fmt.Printf(&amp;quot;结果： a = %d, b = %d and g = %d\n&amp;quot;, a, b, g)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;结果&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;结果： a = 10, b = 20 and g = 30
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;形式参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;形式参数会作为函数的局部变量来使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指针作为接收者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若不是以指针作为接收者，实际只是获取了一个copy，而不能真正改变接收者的中的数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (b *Box) SetColor(c Color) {
	b.color = c
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type Rectangle struct {
	width, height int
}

func (r *Rectangle) setVal() {
	r.height = 20
}

func main() {
	p := Rectangle{1, 2}
	s := p
	p.setVal()
	fmt.Println(p.height, s.height)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;20 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果没有那个*，则值就是&lt;code&gt;2 2&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;15-method继承&#34;&gt;1.5 method继承&lt;/h2&gt;
&lt;p&gt;method是可以继承的，如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Human struct {
	name  string
	age   int
	phone string
}
type Student struct {
	Human  //匿名字段
	school string
}
type Employee struct {
	Human   //匿名字段
	company string
}

func (h *Human) SayHi() {
	fmt.Printf(&amp;quot;Hi, I am %s you can call me on %s\n&amp;quot;, h.name, h.phone)
}
func main() {
	mark := Student{Human{&amp;quot;Mark&amp;quot;, 25, &amp;quot;222-222-YYYY&amp;quot;}, &amp;quot;MIT&amp;quot;}
	sam := Employee{Human{&amp;quot;Sam&amp;quot;, 45, &amp;quot;111-888-XXXX&amp;quot;}, &amp;quot;Golang Inc&amp;quot;}
	mark.SayHi()
	sam.SayHi()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Hi, I am Mark you can call me on 222-222-YYYY
Hi, I am Sam you can call me on 111-888-XXXX
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;16-method重写&#34;&gt;1.6 method重写&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Human struct {
	name  string
	age   int
	phone string
}
type Student struct {
	Human  //匿名字段
	school string
}
type Employee struct {
	Human   //匿名字段
	company string
}

//Human定义method
func (h *Human) SayHi() {
	fmt.Printf(&amp;quot;Hi, I am %s you can call me on %s\n&amp;quot;, h.name, h.phone)
}

//Employee的method重写Human的method
func (e *Employee) SayHi() {
	fmt.Printf(&amp;quot;Hi, I am %s, I work at %s. Call me on %s\n&amp;quot;, e.name,
		e.company, e.phone) //Yes you can split into 2 lines here.
}
func main() {
	mark := Student{Human{&amp;quot;Mark&amp;quot;, 25, &amp;quot;222-222-YYYY&amp;quot;}, &amp;quot;MIT&amp;quot;}
	sam := Employee{Human{&amp;quot;Sam&amp;quot;, 45, &amp;quot;111-888-XXXX&amp;quot;}, &amp;quot;Golang Inc&amp;quot;}
	mark.SayHi()
	sam.SayHi()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Hi, I am Mark you can call me on 222-222-YYYY
Hi, I am Sam, I work at Golang Inc. Call me on 111-888-XXXX
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;方法是可以继承和重写的&lt;/li&gt;
&lt;li&gt;存在继承关系时，按照就近原则，进行调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_advanced&#34;&gt;https://github.com/rubyhan1314/go_advanced&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>函数的概念</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day10_%E5%87%BD%E6%95%B0/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day10_%E5%87%BD%E6%95%B0/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;一函数的概念&#34;&gt;一、函数的概念&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;11-什么是函数&#34;&gt;1.1 什么是函数&lt;/h2&gt;
&lt;p&gt;函数是执行特定任务的代码块。&lt;/p&gt;
&lt;h2 id=&#34;12-函数的声明&#34;&gt;1.2 函数的声明&lt;/h2&gt;
&lt;p&gt;go语言至少有一个main函数&lt;/p&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func funcName(parametername type1, parametername type2) (output1 type1, output2 type2) {
//这里是处理逻辑代码
//返回多个值
return value1, value2
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;func：函数由 func 开始声明&lt;/li&gt;
&lt;li&gt;funcName：函数名称，函数名和参数列表一起构成了函数签名。&lt;/li&gt;
&lt;li&gt;parametername type：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。&lt;/li&gt;
&lt;li&gt;output1 type1, output2 type2：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。&lt;/li&gt;
&lt;li&gt;上面返回值声明了两个变量output1和output2，如果你不想声明也可以，直接就两个类型。&lt;/li&gt;
&lt;li&gt;如果只有一个返回值且不声明返回值变量，那么你可以省略包括返回值的括号（即一个返回值可以不声明返回类型）&lt;/li&gt;
&lt;li&gt;函数体：函数定义的代码集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;13-函数的使用&#34;&gt;1.3 函数的使用&lt;/h2&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int = 200
   var ret int

   /* 调用函数并返回最大值 */
   ret = max(a, b)

   fmt.Printf( &amp;quot;最大值是 : %d\n&amp;quot;, ret )
}

/* 函数返回两个数的最大值 */
func max(num1, num2 int) int {
   /* 定义局部变量 */
   var result int

   if (num1 &amp;gt; num2) {
      result = num1
   } else {
      result = num2
   }
   return result 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;最大值是 : 200
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二函数的参数&#34;&gt;二、函数的参数&lt;/h1&gt;
&lt;h2 id=&#34;21-参数的使用&#34;&gt;2.1 参数的使用&lt;/h2&gt;
&lt;p&gt;形式参数：定义函数时，用于接收外部传入的数据，叫做形式参数，简称形参。&lt;/p&gt;
&lt;p&gt;实际参数：调用函数时，传给形参的实际的数据，叫做实际参数，简称实参。&lt;/p&gt;
&lt;p&gt;函数调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A：函数名称必须匹配

B：实参与形参必须一一对应：顺序，个数，类型
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22-可变参&#34;&gt;2.2 可变参&lt;/h2&gt;
&lt;p&gt;Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func myfunc(arg ...int) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;arg ...int&lt;/code&gt;告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是int。在函数体中，变量arg是一个int的slice：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for _, n := range arg {
fmt.Printf(&amp;quot;And the number is: %d\n&amp;quot;, n)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;23-参数传递&#34;&gt;2.3 参数传递&lt;/h2&gt;
&lt;p&gt;go语言函数的参数也是存在&lt;strong&gt;值传递&lt;/strong&gt;和&lt;strong&gt;引用传递&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数运用场景&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值传递&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
   &amp;quot;fmt&amp;quot;
   &amp;quot;math&amp;quot;
)

func main(){
   /* 声明函数变量 */
   getSquareRoot := func(x float64) float64 {
      return math.Sqrt(x)
   }

   /* 使用函数 */
   fmt.Println(getSquareRoot(9))

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;引用传递&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这就牵扯到了所谓的指针。我们知道，变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内
存。只有add1函数知道x变量所在的地址，才能修改x变量的值。所以我们需要将x所在地址&amp;amp;x传入函数，并将函数的参数的类型由int改为*int，即改为指针类型，才能在函数中修改x变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。请看下面的例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;
//简单的一个函数，实现了参数+1的操作
func add1(a *int) int { // 请注意，
*a = *a+1 // 修改了a的值
return *a // 返回新值
} f
unc main() {
x := 3
fmt.Println(&amp;quot;x = &amp;quot;, x) // 应该输出 &amp;quot;x = 3&amp;quot;
x1 := add1(&amp;amp;x) // 调用 add1(&amp;amp;x) 传x的地址
fmt.Println(&amp;quot;x+1 = &amp;quot;, x1) // 应该输出 &amp;quot;x+1 = 4&amp;quot;
fmt.Println(&amp;quot;x = &amp;quot;, x) // 应该输出 &amp;quot;x = 4&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;传指针使得多个函数能操作同一个对象。&lt;/li&gt;
&lt;li&gt;传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go语言中slice，map这三种类型的实现机制类似指针&lt;/strong&gt;，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;三函数的返回值&#34;&gt;三、函数的返回值&lt;/h1&gt;
&lt;h2 id=&#34;31-什么是函数的返回值&#34;&gt;3.1 什么是函数的返回值&lt;/h2&gt;
&lt;p&gt;一个函数被调用后，返回给调用处的执行结果，叫做函数的返回值。&lt;/p&gt;
&lt;p&gt;调用处需要使用变量接收该结果&lt;/p&gt;
&lt;h2 id=&#34;32-一个函数可以返回多个值&#34;&gt;3.2 一个函数可以返回多个值&lt;/h2&gt;
&lt;p&gt;一个函数可以没有返回值，也可以有一个返回值，也可以有返回多个值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func swap(x, y string) (string, string) {
   return y, x
}

func main() {
   a, b := swap(&amp;quot;Mahesh&amp;quot;, &amp;quot;Kumar&amp;quot;)
   fmt.Println(a, b)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func SumAndProduct(A, B int) (add int, Multiplied int) {
add = A+B
Multiplied = A*B
return
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;33-空白标识符&#34;&gt;3.3 空白标识符&lt;/h2&gt;
&lt;p&gt;_是Go中的空白标识符。它可以代替任何类型的任何值。让我们看看这个空白标识符的用法。&lt;/p&gt;
&lt;p&gt;比如rectProps函数返回的结果是面积和周长，如果我们只要面积，不要周长，就可以使用空白标识符。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func rectProps(length, width float64) (float64, float64) {  
    var area = length * width
    var perimeter = (length + width) * 2
    return area, perimeter
}
func main() {  
    area, _ := rectProps(10.8, 5.6) // perimeter is discarded
    fmt.Printf(&amp;quot;Area %f &amp;quot;, area)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四函数的作用域&#34;&gt;四、函数的作用域&lt;/h1&gt;
&lt;p&gt;作用域：变量可以使用的范围。&lt;/p&gt;
&lt;h2 id=&#34;41-局部变量&#34;&gt;4.1 局部变量&lt;/h2&gt;
&lt;p&gt;一个函数内部定义的变量，就叫做局部变量&lt;/p&gt;
&lt;p&gt;变量在哪里定义，就只能在哪个范围使用，超出这个范围，我们认为变量就被销毁了。&lt;/p&gt;
&lt;h2 id=&#34;42-全局变量&#34;&gt;4.2 全局变量&lt;/h2&gt;
&lt;p&gt;一个函数外部定义的变量，就叫做全局变量&lt;/p&gt;
&lt;p&gt;所有的函数都可以使用，而且共享这一份数据&lt;/p&gt;
&lt;h1 id=&#34;五函数的本质&#34;&gt;五、函数的本质&lt;/h1&gt;
&lt;p&gt;函数也是Go语言中的一种数据类型，可以作为另一个函数的参数，也可以作为另一个函数的返回值。&lt;/p&gt;
&lt;h1 id=&#34;六defer函数&#34;&gt;六、defer函数&lt;/h1&gt;
&lt;h2 id=&#34;61-延迟是什么&#34;&gt;6.1 延迟是什么?&lt;/h2&gt;
&lt;p&gt;即延迟（defer）语句，延迟语句被用于执行一个函数调用，在这个函数之前，延迟语句返回。&lt;/p&gt;
&lt;h2 id=&#34;62-延迟函数&#34;&gt;6.2 延迟函数&lt;/h2&gt;
&lt;p&gt;你可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有很多调用defer，那么defer是采用&lt;code&gt;后进先出&lt;/code&gt;模式&lt;/li&gt;
&lt;li&gt;在离开所在的方法时，执行（报错的时候也会执行）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ReadWrite() bool {
    file.Open(&amp;quot;file&amp;quot;)
    defer file.Close()
    if failureX {
          return false
    } i
    f failureY {
          return false
    } 
    return true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后才执行&lt;code&gt;file.Close()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	a := 1
	b := 2
	defer fmt.Println(b)
	fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;1
2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func finished() {  
    fmt.Println(&amp;quot;Finished finding largest&amp;quot;)
}

func largest(nums []int) {  
    defer finished()    
    fmt.Println(&amp;quot;Started finding largest&amp;quot;)
    max := nums[0]
    for _, v := range nums {
        if v &amp;gt; max {
            max = v
        }
    }
    fmt.Println(&amp;quot;Largest number in&amp;quot;, nums, &amp;quot;is&amp;quot;, max)
}

func main() {  
    nums := []int{78, 109, 2, 563, 300}
    largest(nums)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Started finding largest  
Largest number in [78 109 2 563 300] is 563  
Finished finding largest 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;63-延迟方法&#34;&gt;6.3 延迟方法&lt;/h2&gt;
&lt;p&gt;延迟并不仅仅局限于函数。延迟一个方法调用也是完全合法的。让我们编写一个小程序来测试这个。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)


type person struct {  
    firstName string
    lastName string
}

func (p person) fullName() {  
    fmt.Printf(&amp;quot;%s %s&amp;quot;,p.firstName,p.lastName)
}

func main() {  
    p := person {
        firstName: &amp;quot;John&amp;quot;,
        lastName: &amp;quot;Smith&amp;quot;,
    }
    defer p.fullName()
    fmt.Printf(&amp;quot;Welcome &amp;quot;)  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Welcome John Smith 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;64-延迟参数&#34;&gt;6.4 延迟参数&lt;/h2&gt;
&lt;p&gt;延迟函数的参数在执行延迟语句时被执行，而不是在执行实际的函数调用时执行。&lt;/p&gt;
&lt;p&gt;让我们通过一个例子来理解这个问题。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func printA(a int) {  
    fmt.Println(&amp;quot;value of a in deferred function&amp;quot;, a)
}
func main() {  
    a := 5
    defer printA(a)
    a = 10
    fmt.Println(&amp;quot;value of a before deferred function call&amp;quot;, a)

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;value of a before deferred function call 10  
value of a in deferred function 5 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;65-堆栈的推迟&#34;&gt;6.5 堆栈的推迟&lt;/h2&gt;
&lt;p&gt;当一个函数有多个延迟调用时，它们被添加到一个堆栈中，并在Last In First Out（LIFO）后进先出的顺序中执行。&lt;/p&gt;
&lt;p&gt;我们将编写一个小程序，它使用一堆defers打印一个字符串。示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    name := &amp;quot;Naveen&amp;quot;
    fmt.Printf(&amp;quot;Orignal String: %s\n&amp;quot;, string(name))
    fmt.Printf(&amp;quot;Reversed String: &amp;quot;)
    for _, v := range []rune(name) {
        defer fmt.Printf(&amp;quot;%c&amp;quot;, v)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Orignal String: Naveen  
Reversed String: neevaN 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;66-defer注意点&#34;&gt;6.6 defer注意点&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;defer函数：
当外围函数中的语句正常执行完毕时，只有其中所有的延迟函数都执行完毕，外围函数才会真正的结束执行。
当执行外围函数中的return语句时，只有其中所有的延迟函数都执行完毕后，外围函数才会真正返回。
当外围函数中的代码引发运行恐慌时，只有其中所有的延迟函数都执行完毕后，该运行时恐慌才会真正被扩展至调用函数。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>基本语法——变量</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day02_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day02_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;基本语法变量&#34;&gt;基本语法——变量&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一变量的使用&#34;&gt;一、变量的使用&lt;/h2&gt;
&lt;h3 id=&#34;11-什么是变量&#34;&gt;1.1 什么是变量&lt;/h3&gt;
&lt;p&gt;变量是为存储特定类型的值而提供给内存位置的名称。在go中声明变量有多种语法。&lt;/p&gt;
&lt;p&gt;所以变量的本质就是一小块内存，用于存储数据，在程序运行过程中数值可以改变&lt;/p&gt;
&lt;h3 id=&#34;12-声明变量&#34;&gt;1.2 声明变量&lt;/h3&gt;
&lt;p&gt;var名称类型是声明单个变量的语法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以字母或下划线开头，由一个或多个字母、数字、下划线组成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;声明一个变量&lt;/p&gt;
&lt;p&gt;第一种，指定变量类型，声明后若不赋值，使用默认值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var name type
name = value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种，根据值自行判定变量类型(类型推断Type inference)&lt;/p&gt;
&lt;p&gt;如果一个变量有一个初始值，Go将自动能够使用初始值来推断该变量的类型。因此，如果变量具有初始值，则可以省略变量声明中的类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var name = value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三种，省略var, 注意 :=左侧的变量不应该是已经声明过的(多个变量同时声明时，至少保证一个是新变量)，否则会导致编译错误(简短声明)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;name := value

// 例如
var a int = 10
var b = 10
c : = 10
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;这种方式它只能被用在函数体内，而不可以用于全局变量的声明与赋值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
var a = &amp;quot;Hello&amp;quot;
var b string = &amp;quot;World&amp;quot;
var c bool

func main(){
    println(a, b, c)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Hello World false
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;多变量声明&#34;&gt;多变量声明&lt;/h4&gt;
&lt;p&gt;第一种，以逗号分隔，声明与赋值分开，若不赋值，存在默认值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var name1, name2, name3 type
name1, name2, name3 = v1, v2, v3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种，直接赋值，下面的变量类型可以是不同的类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var name1, name2, name3 = v1, v2, v3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三种，集合类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
    name1 type1
    name2 type2
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-注意事项&#34;&gt;1.3 注意事项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;变量必须先定义才能使用&lt;/li&gt;
&lt;li&gt;go语言是静态语言，要求变量的类型和赋值的类型必须一致。&lt;/li&gt;
&lt;li&gt;变量名不能冲突。(同一个作用于域内不能冲突)&lt;/li&gt;
&lt;li&gt;简短定义方式，左边的变量名至少有一个是新的&lt;/li&gt;
&lt;li&gt;简短定义方式，不能定义全局变量。&lt;/li&gt;
&lt;li&gt;变量的零值。也叫默认值。&lt;/li&gt;
&lt;li&gt;变量定义了就要使用，否则无法通过编译。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。&lt;/p&gt;
&lt;p&gt;如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 a：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
   var a string = &amp;quot;abc&amp;quot;
   fmt.Println(&amp;quot;hello, world&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试编译这段代码将得到错误 a declared and not used&lt;/p&gt;
&lt;p&gt;此外，单纯地给 a 赋值也是不够的，这个值必须被使用，所以使用&lt;/p&gt;
&lt;p&gt;在同一个作用域中，已存在同名的变量，则之后的声明初始化，则退化为赋值操作。但这个前提是，最少要有一个新的变量被定义，且在同一作用域，例如，下面的y就是新定义的变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {
	x := 140
	fmt.Println(&amp;amp;x)
	x, y := 200, &amp;quot;abc&amp;quot;
	fmt.Println(&amp;amp;x, x)
	fmt.Print(y)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;0xc04200a2b0
0xc04200a2b0 200
abc
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;基本语法常量constant&#34;&gt;基本语法——常量constant&lt;/h1&gt;
&lt;h2 id=&#34;一常量的使用&#34;&gt;一、常量的使用&lt;/h2&gt;
&lt;h3 id=&#34;11-常量声明&#34;&gt;1.1 常量声明&lt;/h3&gt;
&lt;p&gt;常量是一个简单值的标识符，在程序运行时，不会被修改的量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const identifier [type] = value
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;显式类型定义： const b string = &amp;quot;abc&amp;quot;
隐式类型定义： const b = &amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   const LENGTH int = 10
   const WIDTH int = 5   
   var area int
   const a, b, c = 1, false, &amp;quot;str&amp;quot; //多重赋值

   area = LENGTH * WIDTH
   fmt.Printf(&amp;quot;面积为 : %d&amp;quot;, area)
   println()
   println(a, b, c)   
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;面积为 : 50
1 false str
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常量可以作为枚举，常量组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
    Unknown = 0
    Female = 1
    Male = 2
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常量组中如不指定类型和初始化值，则与上一行非空常量右值相同&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {
	const (
		x uint16 = 16
		y
		s = &amp;quot;abc&amp;quot;
		z
	)
	fmt.Printf(&amp;quot;%T,%v\n&amp;quot;, y, y)
	fmt.Printf(&amp;quot;%T,%v\n&amp;quot;, z, z)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;uint16,16
string,abc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常量的注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不曾使用的常量，在编译的时候，是不会报错的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显示指定类型的时候，必须确保常量左右值类型一致，需要时可做显示类型转换。这与变量就不一样了，变量是可以是不同的类型值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-iota&#34;&gt;1.2 iota&lt;/h3&gt;
&lt;p&gt;iota，特殊常量，可以认为是一个可以被编译器修改的常量&lt;/p&gt;
&lt;p&gt;iota 可以被用作枚举值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
    a = iota
    b = iota
    c = iota
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
    a = iota
    b
    c
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;iota 用法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    const (
            a = iota   //0
            b          //1
            c          //2
            d = &amp;quot;ha&amp;quot;   //独立值，iota += 1
            e          //&amp;quot;ha&amp;quot;   iota += 1
            f = 100    //iota +=1
            g          //100  iota +=1
            h = iota   //7,恢复计数
            i          //8
    )
    fmt.Println(a,b,c,d,e,f,g,h,i)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 1 2 ha ha 100 100 7 8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果中断iota自增，则必须显式恢复。且后续自增值按行序递增&lt;/p&gt;
&lt;p&gt;自增默认是int类型，可以自行进行显示指定类型&lt;/p&gt;
&lt;p&gt;数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>基本语法——数据类型</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day03_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day03_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;基本语法数据类型&#34;&gt;基本语法——数据类型&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一基本数据类型&#34;&gt;一、基本数据类型&lt;/h2&gt;
&lt;p&gt;以下是go中可用的基本数据类型&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/002shujuleixng.jpg&#34; alt=&#34;002shujuleixng&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;11-布尔型bool&#34;&gt;1.1 布尔型bool&lt;/h3&gt;
&lt;p&gt;布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true&lt;/p&gt;
&lt;h3 id=&#34;12-数值型&#34;&gt;1.2 数值型&lt;/h3&gt;
&lt;p&gt;1、整数型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;int8
有符号 8 位整型 (-128 到 127)
长度：8bit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int16
有符号 16 位整型 (-32768 到 32767)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int32
有符号 32 位整型 (-2147483648 到 2147483647)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int64
有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;uint8
无符号 8 位整型 (0 到 255)
8位都用于表示数值：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;uint16
无符号 16 位整型 (0 到 65535)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;uint32
无符号 32 位整型 (0 到 4294967295)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;uint64
无符号 64 位整型 (0 到 18446744073709551615)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;int和uint:根据底层平台，表示32或64位整数。除非需要使用特定大小的整数，否则通常应该使用int来表示整数。
大小:32位系统32位，64位系统64位。
范围:-2147483648到2147483647的32位系统和-9223372036854775808到9223372036854775807的64位系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、浮点型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;float32&lt;/p&gt;
&lt;p&gt;IEEE-754 32位浮点型数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;float64&lt;/p&gt;
&lt;p&gt;IEEE-754 64位浮点型数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;complex64&lt;/p&gt;
&lt;p&gt;32 位实数和虚数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;complex128&lt;/p&gt;
&lt;p&gt;64 位实数和虚数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3、其他&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;byte&lt;/p&gt;
&lt;p&gt;类似 uint8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rune&lt;/p&gt;
&lt;p&gt;类似 int32&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;uint&lt;/p&gt;
&lt;p&gt;32 或 64 位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int&lt;/p&gt;
&lt;p&gt;与 uint 一样大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;uintptr&lt;/p&gt;
&lt;p&gt;无符号整型，用于存放一个指针&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-字符串型&#34;&gt;1.3 字符串型&lt;/h3&gt;
&lt;p&gt;字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	var str string
	str = &amp;quot;Hello World&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14-数据类型转换type-convert&#34;&gt;1.4 数据类型转换：Type Convert&lt;/h3&gt;
&lt;p&gt;语法格式：Type(Value)&lt;/p&gt;
&lt;p&gt;常数：在有需要的时候，会自动转型&lt;/p&gt;
&lt;p&gt;变量：需要手动转型	T(V)&lt;/p&gt;
&lt;p&gt;注意点：兼容类型可以转换&lt;/p&gt;
&lt;h2 id=&#34;二-复合类型派生类型&#34;&gt;二、 复合类型(派生类型)&lt;/h2&gt;
&lt;p&gt;1、指针类型（Pointer）
2、数组类型
3、结构化类型(struct)
4、Channel 类型
5、函数类型
6、切片类型
7、接口类型（interface）
8、Map 类型&lt;/p&gt;
&lt;h1 id=&#34;运算符&#34;&gt;运算符&lt;/h1&gt;
&lt;p&gt;表达式：(a + b) * c&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a,b,c叫做操作数

+，*，叫做运算符
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;一运算符&#34;&gt;一、运算符&lt;/h2&gt;
&lt;h3 id=&#34;11--算术运算符&#34;&gt;1.1  算术运算符&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;+ - * / %(求余) ++ --
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-关系运算符&#34;&gt;1.2 关系运算符&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;== != &amp;gt; &amp;lt; &amp;gt;= &amp;lt;=
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-逻辑运算符&#34;&gt;1.3 逻辑运算符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td&gt;所谓逻辑与运算符。如果两个操作数都非零，则条件变为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;||&lt;/td&gt;
&lt;td&gt;所谓的逻辑或操作。如果任何两个操作数是非零，则条件变为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;所谓逻辑非运算符。使用反转操作数的逻辑状态。如果条件为真，那么逻辑非操后结果为假&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;14-位运算符&#34;&gt;1.4 位运算符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;th&gt;A&amp;amp;B&lt;/th&gt;
&lt;th&gt;A|B&lt;/th&gt;
&lt;th&gt;A^B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里最难理解的就是^了，只要认为AB两者都相同的时候，为0，其他都为1&lt;/p&gt;
&lt;p&gt;假设A为60，B为13&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;二进制与操作副本位的结果，如果它存在于两个操作数&lt;/td&gt;
&lt;td&gt;(A &amp;amp; B) = 12, 也就是 0000 1100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;二进制或操作副本，如果它存在一个操作数&lt;/td&gt;
&lt;td&gt;(A | B) = 61, 也就是 0011 1101&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;二进制异或操作副本，如果它被设置在一个操作数就是按位取非&lt;/td&gt;
&lt;td&gt;(A ^ B) = 49, 也就是 0011 0001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;^&lt;/td&gt;
&lt;td&gt;二进制位清空&amp;amp;^&lt;/td&gt;
&lt;td&gt;(A&amp;amp;^B)=48，也就是110000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;&amp;lt;&lt;/td&gt;
&lt;td&gt;二进制左移位运算符。左边的操作数的值向左移动由右操作数指定的位数&lt;/td&gt;
&lt;td&gt;A &amp;lt;&amp;lt; 2 =240 也就是 1111 0000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;二进制向右移位运算符。左边的操作数的值由右操作数指定的位数向右移动&lt;/td&gt;
&lt;td&gt;A &amp;gt;&amp;gt; 2 = 15 也就是 0000 1111&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;15-赋值运算符&#34;&gt;1.5 赋值运算符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;简单的赋值操作符，分配值从右边的操作数左侧的操作数&lt;/td&gt;
&lt;td&gt;C = A + B 将分配A + B的值到C&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+=&lt;/td&gt;
&lt;td&gt;相加并赋值运算符，它增加了右操作数左操作数和分配结果左操作数&lt;/td&gt;
&lt;td&gt;C += A 相当于 C = C + A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-=&lt;/td&gt;
&lt;td&gt;减和赋值运算符，它减去右操作数从左侧的操作数和分配结果左操作数&lt;/td&gt;
&lt;td&gt;C -= A 相当于 C = C - A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*=&lt;/td&gt;
&lt;td&gt;乘法和赋值运算符，它乘以右边的操作数与左操作数和分配结果左操作数&lt;/td&gt;
&lt;td&gt;C *= A 相当于 C = C * A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/=&lt;/td&gt;
&lt;td&gt;除法赋值运算符，它把左操作数与右操作数和分配结果左操作数&lt;/td&gt;
&lt;td&gt;C /= A 相当于 C = C / A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%=&lt;/td&gt;
&lt;td&gt;模量和赋值运算符，它需要使用两个操作数的模量和分配结果左操作数&lt;/td&gt;
&lt;td&gt;C %= A 相当于 C = C % A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;左移位并赋值运算符&lt;/td&gt;
&lt;td&gt;C &amp;lt;&amp;lt;= 2 相同于 C = C &amp;lt;&amp;lt; 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;向右移位并赋值运算符&lt;/td&gt;
&lt;td&gt;C &amp;gt;&amp;gt;= 2 相同于 C = C &amp;gt;&amp;gt; 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;=&lt;/td&gt;
&lt;td&gt;按位与赋值运算符&lt;/td&gt;
&lt;td&gt;C &amp;amp;= 2 相同于 C = C &amp;amp; 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^=&lt;/td&gt;
&lt;td&gt;按位异或并赋值运算符&lt;/td&gt;
&lt;td&gt;C ^= 2 相同于 C = C ^ 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;|=&lt;/td&gt;
&lt;td&gt;按位或并赋值运算符&lt;/td&gt;
&lt;td&gt;C |= 2 相同于 C = C | 2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;16优先级运算符优先级&#34;&gt;1.6优先级运算符优先级&lt;/h3&gt;
&lt;p&gt;有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;优先级&lt;/th&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;~ ! ++ --&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;* / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;amp; &amp;amp;^&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;+ -  ^&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;== != &amp;lt; &amp;lt;= &amp;gt;= &amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&amp;lt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;||&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;当然，你可以通过使用括号来临时提升某个表达式的整体运算优先级。&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>集合(Map)</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day08_map%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day08_map%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;一集合map&#34;&gt;一、集合(Map)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;11-什么是map&#34;&gt;1.1 什么是Map&lt;/h2&gt;
&lt;p&gt;map是Go中的内置类型，它将一个值与一个键关联起来。可以使用相应的键检索值。&lt;/p&gt;
&lt;p&gt;Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值
Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的，也是引用类型&lt;/p&gt;
&lt;p&gt;使用map过程中需要注意的几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取&lt;/li&gt;
&lt;li&gt;map的长度是不固定的，也就是和slice一样，也是一种引用类型&lt;/li&gt;
&lt;li&gt;内置的len函数同样适用于map，返回map拥有的key的数量&lt;/li&gt;
&lt;li&gt;map的key可以是所有可比较的类型，如布尔型、整数型、浮点型、复杂型、字符串型……也可以键。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12--map的使用&#34;&gt;1.2  Map的使用&lt;/h2&gt;
&lt;h3 id=&#34;121-使用make创建map&#34;&gt;1.2.1 使用make()创建map&lt;/h3&gt;
&lt;p&gt;可以使用内建函数 make 也可以使用 map 关键字来定义 Map:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/* 声明变量，默认 map 是 nil */
var map_variable map[key_data_type]value_data_type

/* 使用 make 函数 */
map_variable = make(map[key_data_type]value_data_type)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;rating := map[string]float32 {&amp;quot;C&amp;quot;:5, &amp;quot;Go&amp;quot;:4.5, &amp;quot;Python&amp;quot;:4.5, &amp;quot;C++&amp;quot;:2 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   var countryCapitalMap map[string]string
   /* 创建集合 */
   countryCapitalMap = make(map[string]string)
   
   /* map 插入 key-value 对，各个国家对应的首都 */
   countryCapitalMap[&amp;quot;France&amp;quot;] = &amp;quot;Paris&amp;quot;
   countryCapitalMap[&amp;quot;Italy&amp;quot;] = &amp;quot;Rome&amp;quot;
   countryCapitalMap[&amp;quot;Japan&amp;quot;] = &amp;quot;Tokyo&amp;quot;
   countryCapitalMap[&amp;quot;India&amp;quot;] = &amp;quot;New Delhi&amp;quot;
   
   /* 使用 key 输出 map 值 */
   for country := range countryCapitalMap {
      fmt.Println(&amp;quot;Capital of&amp;quot;,country,&amp;quot;is&amp;quot;,countryCapitalMap[country])
   }
   
   /* 查看元素在集合中是否存在 */
   captial, ok := countryCapitalMap[&amp;quot;United States&amp;quot;]
   /* 如果 ok 是 true, 则存在，否则不存在 */
   if(ok){
      fmt.Println(&amp;quot;Capital of United States is&amp;quot;, captial)  
   }else {
      fmt.Println(&amp;quot;Capital of United States is not present&amp;quot;) 
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Capital of France is Paris
Capital of Italy is Rome
Capital of Japan is Tokyo
Capital of India is New Delhi
Capital of United States is not present
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;122-delete-函数&#34;&gt;1.2.2 delete() 函数&lt;/h3&gt;
&lt;p&gt;delete(map, key) 函数用于删除集合的元素, 参数为 map 和其对应的 key。删除函数不返回任何值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {   
   /* 创建 map */
   countryCapitalMap := map[string] string {&amp;quot;France&amp;quot;:&amp;quot;Paris&amp;quot;,&amp;quot;Italy&amp;quot;:&amp;quot;Rome&amp;quot;,&amp;quot;Japan&amp;quot;:&amp;quot;Tokyo&amp;quot;,&amp;quot;India&amp;quot;:&amp;quot;New Delhi&amp;quot;}
   
   fmt.Println(&amp;quot;原始 map&amp;quot;)   
   
   /* 打印 map */
   for country := range countryCapitalMap {
      fmt.Println(&amp;quot;Capital of&amp;quot;,country,&amp;quot;is&amp;quot;,countryCapitalMap[country])
   }
   
   /* 删除元素 */
   delete(countryCapitalMap,&amp;quot;France&amp;quot;);
   fmt.Println(&amp;quot;Entry for France is deleted&amp;quot;)  
   
   fmt.Println(&amp;quot;删除元素后 map&amp;quot;)   
   
   /* 打印 map */
   for country := range countryCapitalMap {
      fmt.Println(&amp;quot;Capital of&amp;quot;,country,&amp;quot;is&amp;quot;,countryCapitalMap[country])
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;原始 map
Capital of France is Paris
Capital of Italy is Rome
Capital of Japan is Tokyo
Capital of India is New Delhi
Entry for France is deleted
删除元素后 map
Capital of Italy is Rome
Capital of Japan is Tokyo
Capital of India is New Delhi
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;123-ok-idiom&#34;&gt;1.2.3 ok-idiom&lt;/h3&gt;
&lt;p&gt;我们可以通过key获取map中对应的value值。语法为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;map[key] 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是当key如果不存在的时候，我们会得到该value值类型的默认值，比如string类型得到空字符串，int类型得到0。但是程序不会报错。&lt;/p&gt;
&lt;p&gt;所以我们可以使用ok-idiom获取值，可知道key/value是否存在&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;value, ok := map[key] 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {
	m := make(map[string]int)
	m[&amp;quot;a&amp;quot;] = 1
	x, ok := m[&amp;quot;b&amp;quot;]
	fmt.Println(x, ok)
	x, ok = m[&amp;quot;a&amp;quot;]
	fmt.Println(x, ok)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;0 false
1 true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;124-map的长度&#34;&gt;1.2.4 map的长度&lt;/h3&gt;
&lt;p&gt;使用len函数可以确定map的长度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;len(map)  // 可以得到map的长度
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;125-map是引用类型的&#34;&gt;1.2.5 map是引用类型的&lt;/h3&gt;
&lt;p&gt;与切片相似，映射是引用类型。当将映射分配给一个新变量时，它们都指向相同的内部数据结构。因此，一个的变化会反映另一个。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    personSalary := map[string]int{
        &amp;quot;steve&amp;quot;: 12000,
        &amp;quot;jamie&amp;quot;: 15000,
    }
    personSalary[&amp;quot;mike&amp;quot;] = 9000
    fmt.Println(&amp;quot;Original person salary&amp;quot;, personSalary)
    newPersonSalary := personSalary
    newPersonSalary[&amp;quot;mike&amp;quot;] = 18000
    fmt.Println(&amp;quot;Person salary changed&amp;quot;, personSalary)

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Original person salary map[steve:12000 jamie:15000 mike:9000]  
Person salary changed map[steve:12000 jamie:15000 mike:18000] 
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;map不能使用==操作符进行比较。==只能用来检查map是否为空。否则会报错：invalid operation: map1 == map2 (map can only be comparedto nil)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>键盘输入和打印输出</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day03_%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%92%8C%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day03_%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%92%8C%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;键盘输入和打印输出&#34;&gt;键盘输入和打印输出&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：韩茹&lt;/p&gt;
&lt;p&gt;出处：千锋教育&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一打印输出&#34;&gt;一、打印输出&lt;/h2&gt;
&lt;h3 id=&#34;11-fmt包&#34;&gt;1.1 fmt包&lt;/h3&gt;
&lt;p&gt;fmt包实现了类似C语言printf和scanf的格式化I/O。格式化verb（&#39;verb&#39;）源自C语言但更简单。&lt;/p&gt;
&lt;p&gt;详见官网fmt的API：https://golang.google.cn/pkg/fmt/&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/fmtpackage.png&#34; alt=&#34;fmtpackage&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;12-导入包&#34;&gt;1.2 导入包&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;fmt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-常用打印函数&#34;&gt;1.3 常用打印函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;打印：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://golang.google.cn/pkg/fmt/#Print&#34;&gt;func Print(a ...interface{}) (n int, err error)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;格式化打印：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://golang.google.cn/pkg/fmt/#Printf&#34;&gt;func Printf(format string, a ...interface{}) (n int, err error)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打印后换行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://golang.google.cn/pkg/fmt/#Println&#34;&gt;func Println(a ...interface{}) (n int, err error)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;格式化打印中的常用占位符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;格式化打印占位符：
			%v,原样输出
			%T，打印类型
			%t,bool类型
			%s，字符串
			%f，浮点
			%d，10进制的整数
			%b，2进制的整数
			%o，8进制
			%x，%X，16进制
				%x：0-9，a-f
				%X：0-9，A-F
			%c，打印字符
			%p，打印地址
			。。。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {
	a := 100           //int
	b := 3.14          //float64
	c := true          // bool
	d := &amp;quot;Hello World&amp;quot; //string
	e := `Ruby`        //string
	f := &#39;A&#39;
	fmt.Printf(&amp;quot;%T,%b\n&amp;quot;, a, a)
	fmt.Printf(&amp;quot;%T,%f\n&amp;quot;, b, b)
	fmt.Printf(&amp;quot;%T,%t\n&amp;quot;, c, c)
	fmt.Printf(&amp;quot;%T,%s\n&amp;quot;, d, d)
	fmt.Printf(&amp;quot;%T,%s\n&amp;quot;, e, e)
	fmt.Printf(&amp;quot;%T,%d,%c\n&amp;quot;, f, f, f)
	fmt.Println(&amp;quot;-----------------------&amp;quot;)
	fmt.Printf(&amp;quot;%v\n&amp;quot;, a)
	fmt.Printf(&amp;quot;%v\n&amp;quot;, b)
	fmt.Printf(&amp;quot;%v\n&amp;quot;, c)
	fmt.Printf(&amp;quot;%v\n&amp;quot;, d)
	fmt.Printf(&amp;quot;%v\n&amp;quot;, e)
	fmt.Printf(&amp;quot;%v\n&amp;quot;, f)

}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/yunxing1.png&#34; alt=&#34;yunxing1&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;二键盘输入&#34;&gt;二、键盘输入&lt;/h2&gt;
&lt;h3 id=&#34;21-fmt包读取键盘输入&#34;&gt;2.1 fmt包读取键盘输入&lt;/h3&gt;
&lt;p&gt;常用方法：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://golang.google.cn/pkg/fmt/#Scan&#34;&gt;func Scan(a ...interface{}) (n int, err error)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://golang.google.cn/pkg/fmt/#Scanf&#34;&gt;func Scanf(format string, a ...interface{}) (n int, err error)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://golang.google.cn/pkg/fmt/#Scanln&#34;&gt;func Scanln(a ...interface{}) (n int, err error)&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {
	var x int
	var y float64
	fmt.Println(&amp;quot;请输入一个整数，一个浮点类型：&amp;quot;)
	fmt.Scanln(&amp;amp;x,&amp;amp;y)//读取键盘的输入，通过操作地址，赋值给x和y   阻塞式
	fmt.Printf(&amp;quot;x的数值：%d，y的数值：%f\n&amp;quot;,x,y)

	fmt.Scanf(&amp;quot;%d,%f&amp;quot;,&amp;amp;x,&amp;amp;y)
	fmt.Printf(&amp;quot;x:%d,y:%f\n&amp;quot;,x,y)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/yunxing2.png&#34; alt=&#34;yunxing2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;22-bufio包读取&#34;&gt;2.2 bufio包读取&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://golang.google.cn/pkg/bufio/&#34;&gt;https://golang.google.cn/pkg/bufio/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;bufio包中都是IO操作的方法：&lt;/p&gt;
&lt;p&gt;先创建Reader对象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/bufio1.png&#34; alt=&#34;bufio1&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后就可以各种读取了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/bufio2.png&#34; alt=&#34;bufio2&#34;&gt;&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;bufio&amp;quot;
)

func main() {
	fmt.Println(&amp;quot;请输入一个字符串：&amp;quot;)
	reader := bufio.NewReader(os.Stdin)
	s1, _ := reader.ReadString(&#39;\n&#39;)
	fmt.Println(&amp;quot;读到的数据：&amp;quot;, s1)

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/yunxing3.png&#34; alt=&#34;yunxing3&#34;&gt;&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>接口</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day14_%E7%AC%AC2%E8%8A%82_%E6%8E%A5%E5%8F%A3/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day14_%E7%AC%AC2%E8%8A%82_%E6%8E%A5%E5%8F%A3/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;接口&#34;&gt;接口&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;11-什么是接口&#34;&gt;1.1 什么是接口?&lt;/h2&gt;
&lt;p&gt;面向对象世界中的接口的一般定义是“接口定义对象的行为”。它表示让指定对象应该做什么。实现这种行为的方法(实现细节)是针对对象的。&lt;/p&gt;
&lt;p&gt;在Go中，接口是一组方法签名。当类型为接口中的所有方法提供定义时，它被称为实现接口。它与OOP非常相似。接口指定了类型应该具有的方法，类型决定了如何实现这些方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口&lt;/p&gt;
&lt;p&gt;接口定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了该接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;12-接口的定义语法&#34;&gt;1.2 接口的定义语法&lt;/h2&gt;
&lt;p&gt;定义接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/* 定义接口 */
type interface_name interface {
   method_name1 [return_type]
   method_name2 [return_type]
   method_name3 [return_type]
   ...
   method_namen [return_type]
}

/* 定义结构体 */
type struct_name struct {
   /* variables */
}

/* 实现接口方法 */
func (struct_name_variable struct_name) method_name1() [return_type] {
   /* 方法实现 */
}
...
func (struct_name_variable struct_name) method_namen() [return_type] {
   /* 方法实现*/
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
)

type Phone interface {
    call()
}

type NokiaPhone struct {
}

func (nokiaPhone NokiaPhone) call() {
    fmt.Println(&amp;quot;I am Nokia, I can call you!&amp;quot;)
}

type IPhone struct {
}

func (iPhone IPhone) call() {
    fmt.Println(&amp;quot;I am iPhone, I can call you!&amp;quot;)
}

func main() {
    var phone Phone

    phone = new(NokiaPhone)
    phone.call()

    phone = new(IPhone)
    phone.call()

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;I am Nokia, I can call you!
I am iPhone, I can call you!
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;interface可以被任意的对象实现&lt;/li&gt;
&lt;li&gt;一个对象可以实现任意多个interface&lt;/li&gt;
&lt;li&gt;任意的类型都实现了空interface(我们这样定义：interface{})，也就是包含0个method的interface&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;13-interface值&#34;&gt;1.3 interface值&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Human struct {
	name  string
	age   int
	phone string
}
type Student struct {
	Human  //匿名字段
	school string
	loan   float32
}
type Employee struct {
	Human   //匿名字段
	company string
	money   float32
} //Human实现Sayhi方法
func (h Human) SayHi() {
	fmt.Printf(&amp;quot;Hi, I am %s you can call me on %s\n&amp;quot;, h.name, h.phone)
} //Human实现Sing方法
func (h Human) Sing(lyrics string) {
	fmt.Println(&amp;quot;La la la la...&amp;quot;, lyrics)
} //Employee重写Human的SayHi方法
func (e Employee) SayHi() {
	fmt.Printf(&amp;quot;Hi, I am %s, I work at %s. Call me on %s\n&amp;quot;, e.name,
		e.company, e.phone) //Yes you can split into 2 lines here.
}

// Interface Men被Human,Student和Employee实现
// 因为这三个类型都实现了这两个方法
type Men interface {
	SayHi()
	Sing(lyrics string)
}

func main() {
	mike := Student{Human{&amp;quot;Mike&amp;quot;, 25, &amp;quot;222-222-XXX&amp;quot;}, &amp;quot;MIT&amp;quot;, 0.00}
	paul := Student{Human{&amp;quot;Paul&amp;quot;, 26, &amp;quot;111-222-XXX&amp;quot;}, &amp;quot;Harvard&amp;quot;, 100}
	sam := Employee{Human{&amp;quot;Sam&amp;quot;, 36, &amp;quot;444-222-XXX&amp;quot;}, &amp;quot;Golang Inc.&amp;quot;, 1000}
	Tom := Employee{Human{&amp;quot;Sam&amp;quot;, 36, &amp;quot;444-222-XXX&amp;quot;}, &amp;quot;Things Ltd.&amp;quot;, 5000}
	//定义Men类型的变量i
	var i Men
	//i能存储Student
	i = mike
	fmt.Println(&amp;quot;This is Mike, a Student:&amp;quot;)
	i.SayHi()
	i.Sing(&amp;quot;November rain&amp;quot;)
	//i也能存储Employee
	i = Tom
	fmt.Println(&amp;quot;This is Tom, an Employee:&amp;quot;)
	i.SayHi()
	i.Sing(&amp;quot;Born to be wild&amp;quot;)
	//定义了slice Men
	fmt.Println(&amp;quot;Let&#39;s use a slice of Men and see what happens&amp;quot;)
	x := make([]Men, 3)
	//T这三个都是不同类型的元素，但是他们实现了interface同一个接口
	x[0], x[1], x[2] = paul, sam, mike
	for _, value := range x {
		value.SayHi()
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	This is Mike, a Student:
	Hi, I am Mike you can call me on 222-222-XXX
	La la la la... November rain
	This is Tom, an Employee:
	Hi, I am Sam, I work at Things Ltd.. Call me on 444-222-XXX
	La la la la... Born to be wild
	Let&#39;s use a slice of Men and see what happens
	Hi, I am Paul you can call me on 111-222-XXX
	Hi, I am Sam, I work at Golang Inc.. Call me on 444-222-XXX
	Hi, I am Mike you can call me on 222-222-XXX
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么interface里面到底能存什么值呢？如果我们定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，我们定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，使用指针的方式，也是可以的&lt;/p&gt;
&lt;p&gt;但是，接口对象不能调用实现对象的属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;interface函数参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;interface的变量可以持有任意实现该interface类型的对象，这给我们编写函数(包括method)提供了一些额外的思考，我们是不是可以通过定义interface参数，让函数接受各种类型的参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;嵌入interface&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Human interface {
	Len()
}
type Student interface {
	Human
}

type Test struct {
}

func (h *Test) Len() {
	fmt.Println(&amp;quot;成功&amp;quot;)
}
func main() {
	var s Student
	s = new(Test)
	s.Len()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package test

import (
	&amp;quot;fmt&amp;quot;
)

type Controller struct {
	M int32
}

type Something interface {
	Get()
	Post()
}

func (c *Controller) Get() {
	fmt.Print(&amp;quot;GET&amp;quot;)
}

func (c *Controller) Post() {
	fmt.Print(&amp;quot;POST&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;test&amp;quot;
)

type T struct {
	test.Controller
}

func (t *T) Get() {
	//new(test.Controller).Get()
	fmt.Print(&amp;quot;T&amp;quot;)
}
func (t *T) Post() {
	fmt.Print(&amp;quot;T&amp;quot;)
}
func main() {
	var something test.Something
	something = new(T)
	var t T
	t.M = 1
	//	t.Controller.M = 1
	something.Get()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Controller实现了所有的Something接口方法，当结构体T中调用Controller结构体的时候，T就相当于Java中的继承，T继承了Controller，因此，T可以不用重写所有的Something接口中的方法，因为父构造器已经实现了接口。&lt;/p&gt;
&lt;p&gt;如果Controller没有实现Something接口方法，则T要调用Something中方法，就要实现其所有方法。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;something = new(test.Controller)&lt;/code&gt;则调用的是Controller中的Get方法。&lt;/p&gt;
&lt;p&gt;T可以使用Controller结构体中定义的变量&lt;/p&gt;
&lt;h2 id=&#34;14-接口的类型&#34;&gt;1.4 接口的类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;接口与鸭子类型：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先直接来看维基百科里的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译过来就是：如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。&lt;/p&gt;
&lt;p&gt;Duck Typing，鸭子类型，是动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身。Go 语言作为一门静态语言，它通过通过接口的方式完美支持鸭子类型。&lt;/p&gt;
&lt;p&gt;而在静态语言如 Java, C++ 中，必须要显示地声明实现了某个接口，之后，才能用在任何需要这个接口的地方。如果你在程序中调用某个数，却传入了一个根本就没有实现另一个的类型，那在编译阶段就不会通过。这也是静态语言比动态语言更安全的原因。&lt;/p&gt;
&lt;p&gt;动态语言和静态语言的差别在此就有所体现。静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。当然，静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，写 python 的同学比较清楚。&lt;/p&gt;
&lt;p&gt;Go 语言作为一门现代静态语言，是有后发优势的。它引入了动态语言的便利，同时又会进行静态语言的类型检查，写起来是非常 Happy 的。Go 采用了折中的做法：不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。&lt;/p&gt;
&lt;p&gt;总结一下，鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它&amp;quot;当前方法和属性的集合&amp;quot;决定。Go 作为一种静态语言，通过接口实现了鸭子类型，实际上是 Go 的编译器在其中作了隐匿的转换工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Go语言的多态性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Go中的多态性是在接口的帮助下实现的。正如我们已经讨论过的，接口可以在Go中隐式地实现。如果类型为接口中声明的所有方法提供了定义，则实现一个接口。让我们看看在接口的帮助下如何实现多态。&lt;/p&gt;
&lt;p&gt;任何定义接口所有方法的类型都被称为隐式地实现该接口。&lt;/p&gt;
&lt;p&gt;类型接口的变量可以保存实现接口的任何值。接口的这个属性用于实现Go中的多态性。&lt;/p&gt;
&lt;h2 id=&#34;15-接口断言&#34;&gt;1.5 接口断言&lt;/h2&gt;
&lt;p&gt;前面说过，因为空接口 interface{}没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是interface{}，那么在函数中，需要对形参进行断言，从而得到它的真实类型。&lt;/p&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 安全类型断言

&amp;lt;目标类型的值&amp;gt;，&amp;lt;布尔参数&amp;gt; := &amp;lt;表达式&amp;gt;.( 目标类型 )

//非安全类型断言

&amp;lt;目标类型的值&amp;gt; := &amp;lt;表达式&amp;gt;.( 目标类型 )

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {

   var i1 interface{} = new (Student)
   s := i1.(Student) //不安全，如果断言失败，会直接panic

   fmt.Println(s)


	var i2 interface{} = new(Student)
	s, ok := i2.(Student) //安全，断言失败，也不会panic，只是ok的值为false
	if ok {
		fmt.Println(s)
	}
}

type Student struct {

}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;断言其实还有另一种形式，就是用在利用 switch语句判断接口的类型。每一个case会被顺序地考虑。当命中一个case 时，就会执行 case 中的语句，因此 case 语句的顺序是很重要的，因为很有可能会有多个 case匹配的情况。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;switch ins:=s.(type) {
	case Triangle:
		fmt.Println(&amp;quot;三角形。。。&amp;quot;,ins.a,ins.b,ins.c)
	case Circle:
		fmt.Println(&amp;quot;圆形。。。。&amp;quot;,ins.radius)
	case int:
		fmt.Println(&amp;quot;整型数据。。&amp;quot;)
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;p&gt;接口对象不能调用接口实现对象的属性&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>结构体</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day13-%E7%BB%93%E6%9E%84%E4%BD%93/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day13-%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;一结构体&#34;&gt;一、结构体&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;11-什么是结构体&#34;&gt;1.1 什么是结构体&lt;/h2&gt;
&lt;p&gt;Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。
结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。&lt;/p&gt;
&lt;h2 id=&#34;12-结构体的定义和初始化&#34;&gt;1.2 结构体的定义和初始化&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type struct_variable_type struct {
   member definition;
   member definition;
   ...
   member definition;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一旦定义了结构体类型，它就能用于变量的声明&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;variable_name := structure_variable_type {value1, value2...valuen}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;初始化结构体&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 1.按照顺序提供初始化值
P := person{&amp;quot;Tom&amp;quot;, 25}
// 2.通过field:value的方式初始化，这样可以任意顺序
P := person{age:24, name:&amp;quot;Tom&amp;quot;}
// 3.new方式,未设置初始值的，会赋予类型的默认初始值
p := new(person)
p.age=24
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13-结构体的访问&#34;&gt;1.3 结构体的访问&lt;/h2&gt;
&lt;p&gt;访问结构体成员(访问结构的各个字段)&lt;/p&gt;
&lt;p&gt;通过点.操作符用于访问结构的各个字段。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Books struct {
   title string
   author string
   subject string
   book_id int
}

func main() {
   var Book1 Books        /* 声明 Book1 为 Books 类型 */
   var Book2 Books        /* 声明 Book2 为 Books 类型 */

   /* book 1 描述 */
   Book1.title = &amp;quot;Go 语言&amp;quot;
   Book1.author = &amp;quot;www.runoob.com&amp;quot;
   Book1.subject = &amp;quot;Go 语言教程&amp;quot;
   Book1.book_id = 6495407

   /* book 2 描述 */
   Book2.title = &amp;quot;Python 教程&amp;quot;
   Book2.author = &amp;quot;www.runoob.com&amp;quot;
   Book2.subject = &amp;quot;Python 语言教程&amp;quot;
   Book2.book_id = 6495700

   /* 打印 Book1 信息 */
   fmt.Printf( &amp;quot;Book 1 title : %s\n&amp;quot;, Book1.title)
   fmt.Printf( &amp;quot;Book 1 author : %s\n&amp;quot;, Book1.author)
   fmt.Printf( &amp;quot;Book 1 subject : %s\n&amp;quot;, Book1.subject)
   fmt.Printf( &amp;quot;Book 1 book_id : %d\n&amp;quot;, Book1.book_id)

   /* 打印 Book2 信息 */
   fmt.Printf( &amp;quot;Book 2 title : %s\n&amp;quot;, Book2.title)
   fmt.Printf( &amp;quot;Book 2 author : %s\n&amp;quot;, Book2.author)
   fmt.Printf( &amp;quot;Book 2 subject : %s\n&amp;quot;, Book2.subject)
   fmt.Printf( &amp;quot;Book 2 book_id : %d\n&amp;quot;, Book2.book_id)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Book 1 title : Go 语言
Book 1 author : www.runoob.com
Book 1 subject : Go 语言教程
Book 1 book_id : 6495407
Book 2 title : Python 教程
Book 2 author : www.runoob.com
Book 2 subject : Python 语言教程
Book 2 book_id : 6495700
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;14-结构体指针&#34;&gt;1.4 结构体指针&lt;/h2&gt;
&lt;p&gt;指针指向一个结构体
也可以创建指向结构的指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构体指针&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var struct_pointer *Books
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp;amp; 符号放置于结构体变量前&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;struct_pointer = &amp;amp;Book1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用结构体指针访问结构体成员，使用 &amp;quot;.&amp;quot; 操作符&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;struct_pointer.title;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Books struct {
   title string
   author string
   subject string
   book_id int
}

func main() {
   var Book1 Books        /* Declare Book1 of type Book */
   var Book2 Books        /* Declare Book2 of type Book */

   /* book 1 描述 */
   Book1.title = &amp;quot;Go 语言&amp;quot;
   Book1.author = &amp;quot;www.runoob.com&amp;quot;
   Book1.subject = &amp;quot;Go 语言教程&amp;quot;
   Book1.book_id = 6495407

   /* book 2 描述 */
   Book2.title = &amp;quot;Python 教程&amp;quot;
   Book2.author = &amp;quot;www.runoob.com&amp;quot;
   Book2.subject = &amp;quot;Python 语言教程&amp;quot;
   Book2.book_id = 6495700

   /* 打印 Book1 信息 */
   printBook(&amp;amp;Book1)

   /* 打印 Book2 信息 */
   printBook(&amp;amp;Book2)
}
func printBook( book *Books ) {
   fmt.Printf( &amp;quot;Book title : %s\n&amp;quot;, book.title);
   fmt.Printf( &amp;quot;Book author : %s\n&amp;quot;, book.author);
   fmt.Printf( &amp;quot;Book subject : %s\n&amp;quot;, book.subject);
   fmt.Printf( &amp;quot;Book book_id : %d\n&amp;quot;, book.book_id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结构体实例化也可以是这样的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Books struct {
}

func (s Books) String() string {
	return &amp;quot;data&amp;quot;
}
func main() {
	fmt.Printf(&amp;quot;%v\n&amp;quot;, Books{})
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;15-结构体的匿名字段&#34;&gt;1.5 结构体的匿名字段&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;结构体的匿名字段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以用字段来创建结构，这些字段只包含一个没有字段名的类型。这些字段被称为匿名字段。&lt;/p&gt;
&lt;p&gt;在类型中，使用不写字段名的方式，使用另一个类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Human struct {
    name string
    age int
    weight int
} 
type Student struct {
    Human // 匿名字段，那么默认Student就包含了Human的所有字段
    speciality string
} 
func main() {
    // 我们初始化一个学生
    mark := Student{Human{&amp;quot;Mark&amp;quot;, 25, 120}, &amp;quot;Computer Science&amp;quot;}
    // 我们访问相应的字段
    fmt.Println(&amp;quot;His name is &amp;quot;, mark.name)
    fmt.Println(&amp;quot;His age is &amp;quot;, mark.age)
    fmt.Println(&amp;quot;His weight is &amp;quot;, mark.weight)
    fmt.Println(&amp;quot;His speciality is &amp;quot;, mark.speciality)
    // 修改对应的备注信息
    mark.speciality = &amp;quot;AI&amp;quot;
    fmt.Println(&amp;quot;Mark changed his speciality&amp;quot;)
    fmt.Println(&amp;quot;His speciality is &amp;quot;, mark.speciality)
    // 修改他的年龄信息
    fmt.Println(&amp;quot;Mark become old&amp;quot;)
    mark.age = 46
    fmt.Println(&amp;quot;His age is&amp;quot;, mark.age)
    // 修改他的体重信息
    fmt.Println(&amp;quot;Mark is not an athlet anymore&amp;quot;)
    mark.weight += 60
    fmt.Println(&amp;quot;His weight is&amp;quot;, mark.weight)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;可以使用&amp;quot;.&amp;quot;的方式进行调用匿名字段中的属性值&lt;/p&gt;
&lt;p&gt;实际就是字段的继承&lt;/p&gt;
&lt;p&gt;其中可以将匿名字段理解为字段名和字段类型都是同一个&lt;/p&gt;
&lt;p&gt;基于上面的理解，所以可以&lt;code&gt;mark.Human = Human{&amp;quot;Marcus&amp;quot;, 55, 220} &lt;/code&gt;和&lt;code&gt;mark.Human.age -= 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;若存在匿名字段中的字段与非匿名字段名字相同，则最外层的优先访问，就近原则&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过匿名访问和修改字段相当的有用，但是不仅仅是struct字段哦，所有的内置类型和自定义类型都是可以作为匿名字段的。&lt;/p&gt;
&lt;h2 id=&#34;16-结构体嵌套&#34;&gt;1.6 结构体嵌套&lt;/h2&gt;
&lt;p&gt;嵌套的结构体
一个结构体可能包含一个字段，而这个字段反过来就是一个结构体。这些结构被称为嵌套结构。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

type Address struct {  
    city, state string
}
type Person struct {  
    name string
    age int
    address Address
}

func main() {  
    var p Person
    p.name = &amp;quot;Naveen&amp;quot;
    p.age = 50
    p.address = Address {
        city: &amp;quot;Chicago&amp;quot;,
        state: &amp;quot;Illinois&amp;quot;,
    }
    fmt.Println(&amp;quot;Name:&amp;quot;, p.name)
    fmt.Println(&amp;quot;Age:&amp;quot;,p.age)
    fmt.Println(&amp;quot;City:&amp;quot;,p.address.city)
    fmt.Println(&amp;quot;State:&amp;quot;,p.address.state)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;17-提升字段&#34;&gt;1.7 提升字段&lt;/h2&gt;
&lt;p&gt;在结构体中属于匿名结构体的字段称为提升字段，因为它们可以被访问，就好像它们属于拥有匿名结构字段的结构一样。理解这个定义是相当复杂的。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

type Address struct {  
    city, state string
}
type Person struct {  
    name string
    age  int
    Address
}

func main() {  
    var p Person
    p.name = &amp;quot;Naveen&amp;quot;
    p.age = 50
    p.Address = Address{
        city:  &amp;quot;Chicago&amp;quot;,
        state: &amp;quot;Illinois&amp;quot;,
    }
    fmt.Println(&amp;quot;Name:&amp;quot;, p.name)
    fmt.Println(&amp;quot;Age:&amp;quot;, p.age)
    fmt.Println(&amp;quot;City:&amp;quot;, p.city) //city is promoted field
    fmt.Println(&amp;quot;State:&amp;quot;, p.state) //state is promoted field
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Name: Naveen  
Age: 50  
City: Chicago  
State: Illinois
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;18-导出结构体和字段&#34;&gt;1.8 导出结构体和字段&lt;/h2&gt;
&lt;p&gt;如果结构体类型以大写字母开头，那么它是一个导出类型，可以从其他包访问它。类似地，如果结构体的字段以大写开头，则可以从其他包访问它们。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;p&gt;1.在computer目录下，创建文件spec.go&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package computer

type Spec struct { //exported struct  
    Maker string //exported field
    model string //unexported field
    Price int //exported field
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.创建main.go 文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;structs/computer&amp;quot;  
import &amp;quot;fmt&amp;quot;

func main() {  
    var spec computer.Spec
    spec.Maker = &amp;quot;apple&amp;quot;
    spec.Price = 50000
    fmt.Println(&amp;quot;Spec:&amp;quot;, spec)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;目录结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;src  
	structs
		computer
			spec.go
		main.go
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;19-结构体比较&#34;&gt;1.9 结构体比较&lt;/h2&gt;
&lt;p&gt;结构体是值类型，如果每个字段具有可比性，则是可比较的。如果它们对应的字段相等，则认为两个结构体变量是相等的。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

type name struct {  
    firstName string
    lastName string
}


func main() {  
    name1 := name{&amp;quot;Steve&amp;quot;, &amp;quot;Jobs&amp;quot;}
    name2 := name{&amp;quot;Steve&amp;quot;, &amp;quot;Jobs&amp;quot;}
    if name1 == name2 {
        fmt.Println(&amp;quot;name1 and name2 are equal&amp;quot;)
    } else {
        fmt.Println(&amp;quot;name1 and name2 are not equal&amp;quot;)
    }

    name3 := name{firstName:&amp;quot;Steve&amp;quot;, lastName:&amp;quot;Jobs&amp;quot;}
    name4 := name{}
    name4.firstName = &amp;quot;Steve&amp;quot;
    if name3 == name4 {
        fmt.Println(&amp;quot;name3 and name4 are equal&amp;quot;)
    } else {
        fmt.Println(&amp;quot;name3 and name4 are not equal&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name1 and name2 are equal  
name3 and name4 are not equal  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如果结构变量包含的字段是不可比较的，那么结构变量是不可比较的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

type image struct {  
    data map[int]int
}

func main() {  
    image1 := image{data: map[int]int{
        0: 155,
    }}
    image2 := image{data: map[int]int{
        0: 155,
    }}
    if image1 == image2 {
        fmt.Println(&amp;quot;image1 and image2 are equal&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;20-结构体作为函数的参数&#34;&gt;2.0 结构体作为函数的参数&lt;/h2&gt;
&lt;p&gt;结构体作为函数参数使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ackage main

import &amp;quot;fmt&amp;quot;

type Books struct {
   title string
   author string
   subject string
   book_id int
}

func main() {
   var Book1 Books        /* 声明 Book1 为 Books 类型 */
   var Book2 Books        /* 声明 Book2 为 Books 类型 */

   /* book 1 描述 */
   Book1.title = &amp;quot;Go 语言&amp;quot;
   Book1.author = &amp;quot;www.runoob.com&amp;quot;
   Book1.subject = &amp;quot;Go 语言教程&amp;quot;
   Book1.book_id = 6495407

   /* book 2 描述 */
   Book2.title = &amp;quot;Python 教程&amp;quot;
   Book2.author = &amp;quot;www.runoob.com&amp;quot;
   Book2.subject = &amp;quot;Python 语言教程&amp;quot;
   Book2.book_id = 6495700

   /* 打印 Book1 信息 */
   printBook(Book1)

   /* 打印 Book2 信息 */
   printBook(Book2)
}

func printBook( book Books ) {
   fmt.Printf( &amp;quot;Book title : %s\n&amp;quot;, book.title);
   fmt.Printf( &amp;quot;Book author : %s\n&amp;quot;, book.author);
   fmt.Printf( &amp;quot;Book subject : %s\n&amp;quot;, book.subject);
   fmt.Printf( &amp;quot;Book book_id : %d\n&amp;quot;, book.book_id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;make、new操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配
内建函数new本质上说跟其它语言中的同名函数功能一样：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。有一点非常重要：new返回指针&lt;/p&gt;
&lt;p&gt;内建函数make(T, args)与new(T)有着不同的功能，make只能创建slice、map和channel，并且返回一个有初始值(非零)的T类型，而不是*T。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个slice，是一个包含指向数据（内部array）的指针、长度和容量的三项描述符；在这些项目被初始化之前，slice为nil。对于slice、map和channel来说，make初始化了内部的数据结构，填充适当的值。&lt;/p&gt;
&lt;p&gt;make返回初始化后的（非零）值。&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_advanced&#34;&gt;https://github.com/rubyhan1314/go_advanced&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>面向对象(OOP)</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day14_%E7%AC%AC3%E8%8A%82-oop%E7%BC%96%E7%A8%8B/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day14_%E7%AC%AC3%E8%8A%82-oop%E7%BC%96%E7%A8%8B/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;面向对象oop&#34;&gt;面向对象(OOP)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;go并不是一个纯面向对象的编程语言。在go中的面向对象，结构体替换了类。&lt;/p&gt;
&lt;p&gt;Go并没有提供类class，但是它提供了结构体struct，方法method，可以在结构体上添加。提供了捆绑数据和方法的行为，这些数据和方法与类类似。&lt;/p&gt;
&lt;h2 id=&#34;11-定义结构体和方法&#34;&gt;1.1 定义结构体和方法&lt;/h2&gt;
&lt;p&gt;通过以下代码来更好的理解，首先在src目录下创建一个package命名为oop，在oop目录下，再创建一个子目录命名为employee，在该目录下创建一个go文件命名为employee.go。&lt;/p&gt;
&lt;p&gt;目录结构：oop -&amp;gt; employee -&amp;gt; employee.go&lt;/p&gt;
&lt;p&gt;在employee.go文件中保存以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package employee

import (  
    &amp;quot;fmt&amp;quot;
)

type Employee struct {  
    FirstName   string
    LastName    string
    TotalLeaves int
    LeavesTaken int
}

func (e Employee) LeavesRemaining() {  
    fmt.Printf(&amp;quot;%s %s has %d leaves remaining&amp;quot;, e.FirstName, e.LastName, (e.TotalLeaves - e.LeavesTaken))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在oop目录下，创建文件并命名为main.go，并保存以下内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;oop/employee&amp;quot;

func main() {  
    e := employee.Employee {
        FirstName: &amp;quot;Sam&amp;quot;,
        LastName: &amp;quot;Adolf&amp;quot;,
        TotalLeaves: 30,
        LeavesTaken: 20,
    }
    e.LeavesRemaining()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Sam Adolf has 10 leaves remaining 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12-new函数替代了构造函数&#34;&gt;1.2 New()函数替代了构造函数&lt;/h2&gt;
&lt;p&gt;我们上面写的程序看起来不错，但是里面有一个微妙的问题。让我们看看当我们用0值定义employee struct时会发生什么。更改main的内容。转到下面的代码，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;oop/employee&amp;quot;

func main() {  
    var e employee.Employee
    e.LeavesRemaining()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;has 0 leaves remaining
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过运行结果可以知道，使用Employee的零值创建的变量是不可用的。它没有有效的名、姓，也没有有效的保留细节。在其他的OOP语言中，比如java，这个问题可以通过使用构造函数来解决。使用参数化构造函数可以创建一个有效的对象。&lt;/p&gt;
&lt;p&gt;go不支持构造函数。如果某个类型的零值不可用，则程序员的任务是不导出该类型以防止其他包的访问，并提供一个名为NewT(parameters)的函数，该函数初始化类型T和所需的值。在go中，它是一个命名一个函数的约定，它创建了一个T类型的值给NewT(parameters)。这就像一个构造函数。如果包只定义了一个类型，那么它的一个约定就是将这个函数命名为New(parameters)而不是NewT(parameters)。&lt;/p&gt;
&lt;p&gt;更改employee.go的代码：&lt;/p&gt;
&lt;p&gt;首先修改employee结构体为非导出，并创建一个函数New()，它将创建一个新Employee。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package employee

import (  
    &amp;quot;fmt&amp;quot;
)

type employee struct {  
    firstName   string
    lastName    string
    totalLeaves int
    leavesTaken int
}

func New(firstName string, lastName string, totalLeave int, leavesTaken int) employee {  
    e := employee {firstName, lastName, totalLeave, leavesTaken}
    return e
}

func (e employee) LeavesRemaining() {  
    fmt.Printf(&amp;quot;%s %s has %d leaves remaining&amp;quot;, e.firstName, e.lastName, (e.totalLeaves - e.leavesTaken))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在这里做了一些重要的改变。我们已经将Employee struct的起始字母e设置为小写，即我们已经将类型Employee struct更改为type Employee struct。通过这样做，我们成功地导出了employee结构并阻止了其他包的访问。将未导出的结构的所有字段都导出为未导出的方法是很好的做法，除非有特定的需要导出它们。由于我们不需要在包之外的任何地方使用employee struct的字段，所以我们也没有导出所有字段。&lt;/p&gt;
&lt;p&gt;由于employee是未导出的，所以不可能从其他包中创建类型employee的值。因此，我们提供了一个输出的新函数。将所需的参数作为输入并返回新创建的employee。&lt;/p&gt;
&lt;p&gt;这个程序还需要做一些修改，让它能够工作，但是让我们运行这个程序来了解到目前为止变化的效果。如果这个程序运行，它将会失败，有以下编译错误，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go/src/constructor/main.go:6: undefined: employee.Employee  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是因为我们有未导出的Employee，因此编译器抛出错误，该类型在main中没有定义。完美的。正是我们想要的。现在没有其他的包能够创建一个零值的员工。我们成功地防止了一个无法使用的员工结构价值被创建。现在创建员工的唯一方法是使用新功能。&lt;/p&gt;
&lt;p&gt;修改main.go代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main  

import &amp;quot;oop/employee&amp;quot;

func main() {  
    e := employee.New(&amp;quot;Sam&amp;quot;, &amp;quot;Adolf&amp;quot;, 30, 20)
    e.LeavesRemaining()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Sam Adolf has 10 leaves remaining 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，我们可以明白，虽然Go不支持类，但是结构体可以有效地使用，在使用构造函数的位置，使用New(parameters)的方法即可。&lt;/p&gt;
&lt;h2 id=&#34;13组成composition-替代了继承inheritance&#34;&gt;1.3组成(Composition )替代了继承(Inheritance)&lt;/h2&gt;
&lt;p&gt;Go不支持继承，但它支持组合。组合的一般定义是“放在一起”。构图的一个例子就是汽车。汽车是由轮子、发动机和其他各种部件组成的。&lt;/p&gt;
&lt;p&gt;博客文章就是一个完美的组合例子。每个博客都有标题、内容和作者信息。这可以用组合完美地表示出来。&lt;/p&gt;
&lt;h3 id=&#34;131-通过嵌入结构体实现组成&#34;&gt;1.3.1 通过嵌入结构体实现组成&lt;/h3&gt;
&lt;p&gt;可以通过将一个struct类型嵌入到另一个结构中实现。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

/*
我们创建了一个author struct，它包含字段名、lastName和bio。我们还添加了一个方法fullName()，将作者作为接收者类型，这将返回作者的全名。
*/
type author struct {  
    firstName string
    lastName  string
    bio       string
}

func (a author) fullName() string {  
    return fmt.Sprintf(&amp;quot;%s %s&amp;quot;, a.firstName, a.lastName)
}
/*
post struct有字段标题、内容。它还有一个嵌入式匿名字段作者。这个字段表示post struct是由author组成的。现在post struct可以访问作者结构的所有字段和方法。我们还在post struct中添加了details()方法，它打印出作者的标题、内容、全名和bio。
*/
type post struct {  
    title     string
    content   string
    author
}

func (p post) details() {  
    fmt.Println(&amp;quot;Title: &amp;quot;, p.title)
    fmt.Println(&amp;quot;Content: &amp;quot;, p.content)
    fmt.Println(&amp;quot;Author: &amp;quot;, p.author.fullName())
    fmt.Println(&amp;quot;Bio: &amp;quot;, p.author.bio)
}

func main() {  
    author1 := author{
        &amp;quot;Naveen&amp;quot;,
        &amp;quot;Ramanathan&amp;quot;,
        &amp;quot;Golang Enthusiast&amp;quot;,
    }
    post1 := post{
        &amp;quot;Inheritance in Go&amp;quot;,
        &amp;quot;Go supports composition instead of inheritance&amp;quot;,
        author1,
    }
    post1.details()
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Title:  Inheritance in Go  
Content:  Go supports composition instead of inheritance  
Author:  Naveen Ramanathan  
Bio:  Golang Enthusiast  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;嵌入结构体的切片&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在以上程序的main函数下增加以下代码，并运行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type website struct {  
        []post
}
func (w website) contents() {  
    fmt.Println(&amp;quot;Contents of Website\n&amp;quot;)
    for _, v := range w.posts {
        v.details()
        fmt.Println()
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main.go:31:9: syntax error: unexpected [, expecting field name or embedded type 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个错误指向structs []post的嵌入部分。原因是不可能匿名嵌入一片。需要一个字段名。我们来修正这个错误，让编译器通过。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type website struct {  
        posts []post
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在让我们修改的main函数,为我们的新的website创建几个posts。修改完完整代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

type author struct {  
    firstName string
    lastName  string
    bio       string
}

func (a author) fullName() string {  
    return fmt.Sprintf(&amp;quot;%s %s&amp;quot;, a.firstName, a.lastName)
}

type post struct {  
    title   string
    content string
    author
}
func (p post) details() {  
    fmt.Println(&amp;quot;Title: &amp;quot;, p.title)
    fmt.Println(&amp;quot;Content: &amp;quot;, p.content)
    fmt.Println(&amp;quot;Author: &amp;quot;, p.fullName())
    fmt.Println(&amp;quot;Bio: &amp;quot;, p.bio)
}

type website struct {  
 posts []post
}
func (w website) contents() {  
    fmt.Println(&amp;quot;Contents of Website\n&amp;quot;)
    for _, v := range w.posts {
        v.details()
        fmt.Println()
    }
}
func main() {  
    author1 := author{
        &amp;quot;Naveen&amp;quot;,
        &amp;quot;Ramanathan&amp;quot;,
        &amp;quot;Golang Enthusiast&amp;quot;,
    }
    post1 := post{
        &amp;quot;Inheritance in Go&amp;quot;,
        &amp;quot;Go supports composition instead of inheritance&amp;quot;,
        author1,
    }
    post2 := post{
        &amp;quot;Struct instead of Classes in Go&amp;quot;,
        &amp;quot;Go does not support classes but methods can be added to structs&amp;quot;,
        author1,
    }
    post3 := post{
        &amp;quot;Concurrency&amp;quot;,
        &amp;quot;Go is a concurrent language and not a parallel one&amp;quot;,
        author1,
    }
    w := website{
        posts: []post{post1, post2, post3},
    }
    w.contents()
}   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Contents of Website

Title:  Inheritance in Go  
Content:  Go supports composition instead of inheritance  
Author:  Naveen Ramanathan  
Bio:  Golang Enthusiast

Title:  Struct instead of Classes in Go  
Content:  Go does not support classes but methods can be added to structs  
Author:  Naveen Ramanathan  
Bio:  Golang Enthusiast

Title:  Concurrency  
Content:  Go is a concurrent language and not a parallel one  
Author:  Naveen Ramanathan  
Bio:  Golang Enthusiast  
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;14-多态性polymorphism&#34;&gt;1.4 多态性(Polymorphism)&lt;/h2&gt;
&lt;p&gt;Go中的多态性是在接口的帮助下实现的。正如我们已经讨论过的，接口可以在Go中隐式地实现。如果类型为接口中声明的所有方法提供了定义，则实现一个接口。让我们看看在接口的帮助下如何实现多态。&lt;/p&gt;
&lt;p&gt;任何定义接口所有方法的类型都被称为隐式地实现该接口。&lt;/p&gt;
&lt;p&gt;类型接口的变量可以保存实现接口的任何值。接口的这个属性用于实现Go中的多态性。&lt;/p&gt;
&lt;p&gt;举个例子，一个虚构的组织有两种项目的收入:固定的账单和时间和材料。组织的净收入是由这些项目的收入之和计算出来的。为了保持本教程的简单，我们假设货币是美元，我们不会处理美分。它将使用整数来表示。&lt;/p&gt;
&lt;p&gt;首先我们定义一个接口：Income&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Income interface {  
    calculate() int
    source() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，定义两个结构体：FixedBilling和TimeAndMaterial&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type FixedBilling struct {  
    projectName string
    biddedAmount int
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type TimeAndMaterial struct {  
    projectName string
    noOfHours  int
    hourlyRate int
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下一步是定义这些结构体类型的方法，计算并返回实际收入和收入来源。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (fb FixedBilling) calculate() int {  
    return fb.biddedAmount
}

func (fb FixedBilling) source() string {  
    return fb.projectName
}

func (tm TimeAndMaterial) calculate() int {  
    return tm.noOfHours * tm.hourlyRate
}

func (tm TimeAndMaterial) source() string {  
    return tm.projectName
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，我们来声明一下计算和打印总收入的calculateNetIncome函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func calculateNetIncome(ic []Income) {  
    var netincome int = 0
    for _, income := range ic {
        fmt.Printf(&amp;quot;Income From %s = $%d\n&amp;quot;, income.source(), income.calculate())
        netincome += income.calculate()
    }
    fmt.Printf(&amp;quot;Net income of organisation = $%d&amp;quot;, netincome)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的calculateNetIncome函数接受一部分Income接口作为参数。它通过遍历切片和调用calculate()方法来计算总收入。它还通过调用source()方法来显示收入来源。根据收入接口的具体类型，将调用不同的calculate()和source()方法。因此，我们在calculateNetIncome函数中实现了多态。&lt;/p&gt;
&lt;p&gt;在未来，如果组织增加了一种新的收入来源，这个函数仍然可以正确地计算总收入，而没有一行代码更改。&lt;/p&gt;
&lt;p&gt;最后我们写以下主函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {  
    project1 := FixedBilling{projectName: &amp;quot;Project 1&amp;quot;, biddedAmount: 5000}
    project2 := FixedBilling{projectName: &amp;quot;Project 2&amp;quot;, biddedAmount: 10000}
    project3 := TimeAndMaterial{projectName: &amp;quot;Project 3&amp;quot;, noOfHours: 160, hourlyRate: 25}
    incomeStreams := []Income{project1, project2, project3}
    calculateNetIncome(incomeStreams)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Income From Project 1 = $5000  
Income From Project 2 = $10000  
Income From Project 3 = $4000  
Net income of organisation = $19000  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设该组织通过广告找到了新的收入来源。让我们看看如何简单地添加新的收入方式和计算总收入，而不用对calculateNetIncome函数做任何更改。由于多态性，这样是可行的。&lt;/p&gt;
&lt;p&gt;首先让我们定义Advertisement类型和calculate()和source()方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Advertisement struct {  
    adName     string
    CPC        int
    noOfClicks int
}

func (a Advertisement) calculate() int {  
    return a.CPC * a.noOfClicks
}

func (a Advertisement) source() string {  
    return a.adName
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;广告类型有三个字段adName, CPC(cost per click)和noof点击数(cost per click)。广告的总收入是CPC和noOfClicks的产品。&lt;/p&gt;
&lt;p&gt;修改主函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {  
    project1 := FixedBilling{projectName: &amp;quot;Project 1&amp;quot;, biddedAmount: 5000}
    project2 := FixedBilling{projectName: &amp;quot;Project 2&amp;quot;, biddedAmount: 10000}
    project3 := TimeAndMaterial{projectName: &amp;quot;Project 3&amp;quot;, noOfHours: 160, hourlyRate: 25}
    bannerAd := Advertisement{adName: &amp;quot;Banner Ad&amp;quot;, CPC: 2, noOfClicks: 500}
    popupAd := Advertisement{adName: &amp;quot;Popup Ad&amp;quot;, CPC: 5, noOfClicks: 750}
    incomeStreams := []Income{project1, project2, project3, bannerAd, popupAd}
    calculateNetIncome(incomeStreams)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Income From Project 1 = $5000  
Income From Project 2 = $10000  
Income From Project 3 = $4000  
Income From Banner Ad = $1000  
Income From Popup Ad = $3750  
Net income of organisation = $23750 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;综上，我们没有对calculateNetIncome函数做任何更改，尽管我们添加了新的收入方式。它只是因为多态性而起作用。由于新的Advertisement类型也实现了Income接口，我们可以将它添加到incomeStreams切片中。calculateNetIncome函数也在没有任何更改的情况下工作，因为它可以调用Advertisement类型的calculate()和source()方法。&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>切片(Slice)</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day07_slice%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day07_slice%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;一切片slice&#34;&gt;一、切片(Slice)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;11-什么是切片&#34;&gt;1.1 什么是切片&lt;/h2&gt;
&lt;p&gt;Go 语言切片是对数组的抽象。
Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(&amp;quot;动态数组&amp;quot;),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大&lt;/p&gt;
&lt;p&gt;切片是一种方便、灵活且强大的包装器。切片本身没有任何数据。它们只是对现有数组的引用。&lt;/p&gt;
&lt;p&gt;切片与数组相比，不需要设定长度，在[]中不用设定值，相对来说比较自由&lt;/p&gt;
&lt;p&gt;从概念上面来说slice像一个结构体，这个结构体包含了三个元素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指针，指向数组中slice指定的开始位置&lt;/li&gt;
&lt;li&gt;长度，即slice的长度&lt;/li&gt;
&lt;li&gt;最大长度，也就是slice开始位置到数组的最后位置的长度&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;12-切片的语法&#34;&gt;1.2 切片的语法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义切片&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var identifier []type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;切片不需要说明长度。
或使用make()函数来创建切片:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var slice1 []type = make([]type, len)
也可以简写为
slice1 := make([]type, len)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;make([]T, length, capacity)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s[0] = 1
s[1] = 2
s[2] = 3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s :=[] int {1,2,3 } 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s := arr[startIndex:endIndex] 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片（&lt;strong&gt;前闭后开&lt;/strong&gt;），长度为endIndex-startIndex&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s := arr[startIndex:] 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缺省endIndex时将表示一直到arr的最后一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s := arr[:endIndex] 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缺省startIndex时将表示从arr的第一个元素开始&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    a := [5]int{76, 77, 78, 79, 80}
    var b []int = a[1:4] //creates a slice from a[1] to a[3]
    fmt.Println(b)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13-修改切片&#34;&gt;1.3 修改切片&lt;/h2&gt;
&lt;p&gt;slice没有自己的任何数据。它只是底层数组的一个表示。对slice所做的任何修改都将反映在底层数组中。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    darr := [...]int{57, 89, 90, 82, 100, 78, 67, 69, 59}
    dslice := darr[2:5]
    fmt.Println(&amp;quot;array before&amp;quot;,darr)
    for i := range dslice {
        dslice[i]++
    }
    fmt.Println(&amp;quot;array after&amp;quot;,darr) 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array before [57 89 90 82 100 78 67 69 59]  
array after [57 89 91 83 101 78 67 69 59]  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当多个片共享相同的底层数组时，每个元素所做的更改将在数组中反映出来。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    numa := [3]int{78, 79 ,80}
    nums1 := numa[:] //creates a slice which contains all elements of the array
    nums2 := numa[:]
    fmt.Println(&amp;quot;array before change 1&amp;quot;,numa)
    nums1[0] = 100
    fmt.Println(&amp;quot;array after modification to slice nums1&amp;quot;, numa)
    nums2[1] = 101
    fmt.Println(&amp;quot;array after modification to slice nums2&amp;quot;, numa)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array before change 1 [78 79 80]  
array after modification to slice nums1 [100 79 80]  
array after modification to slice nums2 [100 101 80]  
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;14-len-和-cap-函数&#34;&gt;1.4 len() 和 cap() 函数&lt;/h2&gt;
&lt;p&gt;切片的长度是切片中元素的数量。切片的容量是从创建切片的索引开始的底层数组中元素的数量。&lt;/p&gt;
&lt;p&gt;切片是可索引的，并且可以由 len() 方法获取长度
切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   var numbers = make([]int,3,5)

   printSlice(numbers)
}

func printSlice(x []int){
   fmt.Printf(&amp;quot;len=%d cap=%d slice=%v\n&amp;quot;,len(x),cap(x),x)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;len=3 cap=5 slice=[0 0 0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;空切片&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个切片在未初始化之前默认为 nil，长度为 0&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   var numbers []int

   printSlice(numbers)

   if(numbers == nil){
      fmt.Printf(&amp;quot;切片是空的&amp;quot;)
   }
}

func printSlice(x []int){
   fmt.Printf(&amp;quot;len=%d cap=%d slice=%v\n&amp;quot;,len(x),cap(x),x)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;len=0 cap=0 slice=[]
切片是空的
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   /* 创建切片 */
   numbers := []int{0,1,2,3,4,5,6,7,8}   
   printSlice(numbers)

   /* 打印原始切片 */
   fmt.Println(&amp;quot;numbers ==&amp;quot;, numbers)

   /* 打印子切片从索引1(包含) 到索引4(不包含)*/
   fmt.Println(&amp;quot;numbers[1:4] ==&amp;quot;, numbers[1:4])

   /* 默认下限为 0*/
   fmt.Println(&amp;quot;numbers[:3] ==&amp;quot;, numbers[:3])

   /* 默认上限为 len(s)*/
   fmt.Println(&amp;quot;numbers[4:] ==&amp;quot;, numbers[4:])

   numbers1 := make([]int,0,5)
   printSlice(numbers1)

   /* 打印子切片从索引  0(包含) 到索引 2(不包含) */
   number2 := numbers[:2]
   printSlice(number2)

   /* 打印子切片从索引 2(包含) 到索引 5(不包含) */
   number3 := numbers[2:5]
   printSlice(number3)

}

func printSlice(x []int){
   fmt.Printf(&amp;quot;len=%d cap=%d slice=%v\n&amp;quot;,len(x),cap(x),x)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]
numbers == [0 1 2 3 4 5 6 7 8]
numbers[1:4] == [1 2 3]
numbers[:3] == [0 1 2]
numbers[4:] == [4 5 6 7 8]
len=0 cap=5 slice=[]
len=2 cap=9 slice=[0 1]
len=3 cap=7 slice=[2 3 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;15-append-和-copy-函数&#34;&gt;1.5 append() 和 copy() 函数&lt;/h2&gt;
&lt;p&gt;append 向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice
copy 函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数&lt;/p&gt;
&lt;p&gt;append函数会改变slice所引用的数组的内容，从而影响到引用同一数组的其它slice。 但当slice中没有剩
余空间（即(cap-len) == 0）时，此时将动态分配新的数组空间。返回的slice数组指针将指向这个空间，而原
数组的内容将保持不变；其它引用此数组的slice则不受影响&lt;/p&gt;
&lt;p&gt;下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   var numbers []int
   printSlice(numbers)

   /* 允许追加空切片 */
   numbers = append(numbers, 0)
   printSlice(numbers)

   /* 向切片添加一个元素 */
   numbers = append(numbers, 1)
   printSlice(numbers)

   /* 同时添加多个元素 */
   numbers = append(numbers, 2,3,4)
   printSlice(numbers)

   /* 创建切片 numbers1 是之前切片的两倍容量*/
   numbers1 := make([]int, len(numbers), (cap(numbers))*2)

   /* 拷贝 numbers 的内容到 numbers1 */
   copy(numbers1,numbers)
   printSlice(numbers1)   
}

func printSlice(x []int){
   fmt.Printf(&amp;quot;len=%d cap=%d slice=%v\n&amp;quot;,len(x),cap(x),x)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;len=0 cap=0 slice=[]
len=1 cap=2 slice=[0]
len=2 cap=2 slice=[0 1]
len=5 cap=8 slice=[0 1 2 3 4]
len=5 cap=12 slice=[0 1 2 3 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;numbers1与numbers两者不存在联系，numbers发生变化时，numbers1是不会随着变化的。也就是说copy方法是不会建立两个切片的联系的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>首页功能扩展、图片上传和关于我功能开发</title>
                <link>http://www.songx.fun/blog/day38-41beego%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/day41_%E9%A6%96%E9%A1%B5%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%92%8C%E5%85%B3%E4%BA%8E%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day38-41beego%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/day41_%E9%A6%96%E9%A1%B5%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%92%8C%E5%85%B3%E4%BA%8E%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;首页功能扩展图片上传和关于我功能开发&#34;&gt;首页功能扩展、图片上传和关于我功能开发&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们最初只是让首页显示第一页的文章数据，如果在访问首页的时候，后面传入相应的参数，那么我们应该根据参数显示对应的内容。&lt;/p&gt;
&lt;p&gt;如果浏览器输入首页网址：&lt;a href=&#34;http://127.0.0.1:8080/&#34;&gt;http://127.0.0.1:8080/&lt;/a&gt;，那么我们显示第一页的文章数据&lt;/p&gt;
&lt;p&gt;如果浏览器输入网址是：&lt;a href=&#34;http://127.0.0.1:8080/?page=3&#34;&gt;http://127.0.0.1:8080/?page=3&lt;/a&gt;，那么我们直接显示第三页的文章数据&lt;/p&gt;
&lt;p&gt;如果浏览器输入网址是：&lt;a href=&#34;http://127.0.0.1:8080/?tag=go&#34;&gt;http://127.0.0.1:8080/?tag=go&lt;/a&gt;，那么我们应该显示所有标签为go的文章，同理如果tag=web，我们应该显示所有标签为web的文章。&lt;/p&gt;
&lt;p&gt;接下来我们就去改进首页的功能。&lt;/p&gt;
&lt;h2 id=&#34;一-首页功能扩展开发&#34;&gt;一 首页功能扩展开发&lt;/h2&gt;
&lt;h3 id=&#34;11-修改首页逻辑&#34;&gt;1.1 修改首页逻辑&lt;/h3&gt;
&lt;h4 id=&#34;111-修改控制器逻辑&#34;&gt;1.1.1 修改控制器逻辑&lt;/h4&gt;
&lt;p&gt;我们首先修改home_controller.go文件中的处理，修改代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package controllers
import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;myblogweb/models&amp;quot;
)
type HomeController struct {
	//beego.Controller
	BaseController
}

func (this *HomeController) Get() {
	tag := this.GetString(&amp;quot;tag&amp;quot;)
	fmt.Println(&amp;quot;tag:&amp;quot;, tag)
	page, _ := this.GetInt(&amp;quot;page&amp;quot;)
	var artList []models.Article
	if len(tag) &amp;gt; 0 {
		//按照指定的标签搜索
		artList, _ = models.QueryArticlesWithTag(tag)
		this.Data[&amp;quot;HasFooter&amp;quot;] = false
	} else {
		if page &amp;lt;= 0 {
			page = 1
		}
		artList, _ = models.FindArticleWithPage(page)
		this.Data[&amp;quot;PageCode&amp;quot;] = models.ConfigHomeFooterPageCode(page)
		this.Data[&amp;quot;HasFooter&amp;quot;] = true
	}
	fmt.Println(&amp;quot;IsLogin:&amp;quot;, this.IsLogin, this.Loginuser)
	this.Data[&amp;quot;Content&amp;quot;] = models.MakeHomeBlocks(artList, this.IsLogin)
	this.TplName = &amp;quot;home.html&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;112-功能扩展逻辑分析&#34;&gt;1.1.2 功能扩展逻辑分析&lt;/h4&gt;
&lt;p&gt;我们先接收tag的值和page的值：
那么有三种情况：
1. 如果tag有值，page就不会有值。比如：&lt;a href=&#34;http://127.0.0.1:8080/?pag=web&#34;&gt;http://127.0.0.1:8080/?pag=web&lt;/a&gt;
2. 如果page有值，那么tag就不会有值。比如：&lt;a href=&#34;http://127.0.0.1:8080/?page=3&#34;&gt;http://127.0.0.1:8080/?page=3&lt;/a&gt;
3. 就是用户直接访问首页，没有传入tag也没有传入page：&lt;a href=&#34;http://127.0.0.1:8080&#34;&gt;http://127.0.0.1:8080&lt;/a&gt;
如果是第一种情况，那么我们应该按照tag进行搜索。如果是第二种情况就按照页数查询。如果是第三种就默认按照分页查询，只是查询第一页。&lt;/p&gt;
&lt;h3 id=&#34;12-model层逻辑实现&#34;&gt;1.2 model层逻辑实现&lt;/h3&gt;
&lt;h4 id=&#34;121-逻辑分析&#34;&gt;1.2.1 逻辑分析&lt;/h4&gt;
&lt;p&gt;接下来我们去实现按照tag进行查询，这里有个复杂的地方，就是我们在写文章的手，标签可能有一个，也肯能有多个，如果是多个，我们是按照&amp;amp;连接的，比如：go&amp;amp;socket。那么在按照标签查询的时候，就要分为4种情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;通过标签查询首页的数据
有四种情况
   1.左右两边有&amp;amp;符和其他符号
   2.左边有&amp;amp;符号和其他符号，同时右边没有任何符号
   3.右边有&amp;amp;符号和其他符号，同时左边没有任何符号
   4.左右两边都没有符号
通过%去匹配任意多个字符，至少是一个
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;122-添加model方法&#34;&gt;1.2.2 添加model方法&lt;/h4&gt;
&lt;p&gt;我们在article_model.go文件中，添加一个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//--------------按照标签查询--------------
func QueryArticlesWithTag(tag string) ([]Article, error) {

	sql := &amp;quot; where tags like &#39;%&amp;amp;&amp;quot; + tag + &amp;quot;&amp;amp;%&#39;&amp;quot;
	sql += &amp;quot; or tags like &#39;%&amp;amp;&amp;quot; + tag + &amp;quot;&#39;&amp;quot;
	sql += &amp;quot; or tags like &#39;&amp;quot; + tag + &amp;quot;&amp;amp;%&#39;&amp;quot;
	sql += &amp;quot; or tags like &#39;&amp;quot; + tag + &amp;quot;&#39;&amp;quot;
	fmt.Println(sql)
	return QueryArticlesWithCon(sql)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-项目运行&#34;&gt;1.3 项目运行&lt;/h3&gt;
&lt;p&gt;前端页面不用修改，我们打开浏览器输入以下网址：&lt;a href=&#34;http://127.0.0.1:8080?tag=web&#34;&gt;http://127.0.0.1:8080?tag=web&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190524-103729@2x.png&#34; alt=&#34;功能扩展演示&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到查询出web标签的三篇文章，重新输入网址：&lt;a href=&#34;http://127.0.0.1:8080?tag=http&#34;&gt;http://127.0.0.1:8080?tag=http&lt;/a&gt;http标签下的三篇文章也被查询出来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190524-104605@2x.png&#34; alt=&#34;http标签查询结果&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面我们输入以下页码：&lt;a href=&#34;http://127.0.0.1:8080?page=3&#34;&gt;http://127.0.0.1:8080?page=3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190524-104754@2x.png&#34; alt=&#34;通过页码获取&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;二-文件上传和图片展示功能&#34;&gt;二 文件上传和图片展示功能&lt;/h2&gt;
&lt;p&gt;上节内容我们学习了首页扩功能，本节课我们继续开发实现新的功能--文件上传和图片展示功能。在实际案例中，提供有相册展示功能，相册功能展示的图片需要用到文件上传，我们来实际开发实现。&lt;/p&gt;
&lt;h3 id=&#34;21-创建数据表&#34;&gt;2.1 创建数据表&lt;/h3&gt;
&lt;p&gt;首先我们要在数据库中创建数据表，要想存储图片，我们需要图片的id，图片的路径位置，图片的名字等等。所在在utils工具包下的mysqlUtil.go文件中，添加创建数据表的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//--------图片--------
func CreateTableWithAlbum() {
	sql := `create table if not exists album(
		id int(4) primary key auto_increment not null,
		filepath varchar(255),
		filename varchar(64),
		status int(4),
		createtime int(10)
		);`
	ModifyDB(sql)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并且在初始化数据库的方法中进行调用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func InitMysql() {
	fmt.Println(&amp;quot;InitMysql....&amp;quot;)
	if db == nil {
		db, _ = sql.Open(&amp;quot;mysql&amp;quot;, &amp;quot;root:hanru1314@tcp(127.0.0.1:3306)/myblogweb&amp;quot;)
		CreateTableWithUser()
		CreateTableWithArticle()
		CreateTableWithAlbum()
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22-实现文件上传功能&#34;&gt;2.2 实现文件上传功能&lt;/h3&gt;
&lt;h4 id=&#34;221-新增albumcontroller控制器&#34;&gt;2.2.1 新增AlbumController控制器&lt;/h4&gt;
&lt;p&gt;然后我们创建一个新的go文件，album_controller.go&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package controllers
import (
	&amp;quot;myblog/models&amp;quot;
	&amp;quot;github.com/opentracing/opentracing-go/log&amp;quot;
)
type AlbumController struct {
	BaseController
}
func (this *AlbumController) Get() {
	this.TplName=&amp;quot;album.html&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;222-视图层实现&#34;&gt;2.2.2 视图层实现&lt;/h4&gt;
&lt;h5 id=&#34;2221-添加html文件&#34;&gt;2.2.2.1 添加html文件&lt;/h5&gt;
&lt;p&gt;接下来我们去写html页面，在views目录下创建一个新的html页面：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;相册&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/lib/jquery-3.3.1.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/lib/jquery.url.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/blog.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;link href=&amp;quot;../static/css/blogsheet.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
{{template &amp;quot;block/nav.html&amp;quot; .}}
&amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;
    &amp;lt;form method=&amp;quot;post&amp;quot;&amp;gt;
        &amp;lt;input type=&amp;quot;file&amp;quot; id=&amp;quot;album-upload-file&amp;quot; name=&amp;quot;upload&amp;quot;&amp;gt;
        &amp;lt;input type=&amp;quot;button&amp;quot; id=&amp;quot;album-upload-button&amp;quot; value=&amp;quot;提交文件&amp;quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2222-js实现文件上传逻辑&#34;&gt;2.2.2.2 js实现文件上传逻辑&lt;/h5&gt;
&lt;p&gt;然后我们需要编写点击按钮之后的脚本代码，在blog.js文件中继续添加脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//文件
    $(&amp;quot;#album-upload-button&amp;quot;).click(function () {
        var filedata = $(&amp;quot;#album-upload-file&amp;quot;).val();
        if (filedata.length &amp;lt;= 0) {
            alert(&amp;quot;请选择文件!&amp;quot;);
            return
        }
        //文件上传通过Formdata去储存文件的数据
        var data = new FormData()
        data.append(&amp;quot;upload&amp;quot;, $(&amp;quot;#album-upload-file&amp;quot;)[0].files[0]);
        alert(data)
        var urlStr = &amp;quot;/upload&amp;quot;
        $.ajax({
            url: urlStr,
            type: &amp;quot;post&amp;quot;,
            dataType: &amp;quot;json&amp;quot;,
            contentType: false,
            data: data,
            processData: false,
            success: function (data, status) {
                alert(&amp;quot;:data:&amp;quot; + data.message);
                if (data.code == 1) {
                    setTimeout(function () {
                        window.location.href = &amp;quot;/album&amp;quot;
                    }, 1000)
                }
            },
            error: function (data, status) {
                alert(&amp;quot;err:&amp;quot; + data.message + &amp;quot;:&amp;quot; + status)
            }
        })
    })
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;223-添加文件上传控制器&#34;&gt;2.2.3 添加文件上传控制器&lt;/h4&gt;
&lt;p&gt;此时我们需要新建一个文件上传的controller，upload_controller.go&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package controllers

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
	&amp;quot;path/filepath&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;myblog/models&amp;quot;
)
type UploadController struct {
	BaseController
}
func (this *UploadController) Post() {
	fmt.Println(&amp;quot;fileupload...&amp;quot;)
	fileData, fileHeader, err := this.GetFile(&amp;quot;upload&amp;quot;)
	if err != nil {
		this.responseErr(err)
		return
	}
	fmt.Println(&amp;quot;name:&amp;quot;, fileHeader.Filename, fileHeader.Size)
	fmt.Println(fileData)
	now := time.Now()
	fmt.Println(&amp;quot;ext:&amp;quot;, filepath.Ext(fileHeader.Filename))
	fileType := &amp;quot;other&amp;quot;
	//判断后缀为图片的文件，如果是图片我们才存入到数据库中
	fileExt := filepath.Ext(fileHeader.Filename)
	if fileExt == &amp;quot;.jpg&amp;quot; || fileExt == &amp;quot;.png&amp;quot; || fileExt == &amp;quot;.gif&amp;quot; || fileExt == &amp;quot;.jpeg&amp;quot; {
		fileType = &amp;quot;img&amp;quot;
	}
	//文件夹路径
	fileDir := fmt.Sprintf(&amp;quot;static/upload/%s/%d/%d/%d&amp;quot;, fileType, now.Year(), now.Month(), now.Day())
	//ModePerm是0777，这样拥有该文件夹路径的执行权限
	err = os.MkdirAll(fileDir, os.ModePerm)
	if err != nil {
		this.responseErr(err)
		return
	}
	//文件路径
	timeStamp := time.Now().Unix()
	fileName := fmt.Sprintf(&amp;quot;%d-%s&amp;quot;, timeStamp, fileHeader.Filename)
	filePathStr := filepath.Join(fileDir, fileName)
	desFile, err := os.Create(filePathStr)
	if err != nil {
		this.responseErr(err)
		return
	}
	//将浏览器客户端上传的文件拷贝到本地路径的文件里面
	_, err = io.Copy(desFile, fileData)
	if err != nil {
		this.responseErr(err)
		return
	}
	if fileType == &amp;quot;img&amp;quot; {
		album := models.Album{0, filePathStr, fileName, 0, timeStamp}
		models.InsertAlbum(album)
	}
	this.Data[&amp;quot;json&amp;quot;] = map[string]interface{}{&amp;quot;code&amp;quot;: 1, &amp;quot;message&amp;quot;: &amp;quot;上传成功&amp;quot;}
	this.ServeJSON()
}

func (this *UploadController) responseErr(err error) {
	this.Data[&amp;quot;json&amp;quot;] = map[string]interface{}{&amp;quot;code&amp;quot;: 0, &amp;quot;message&amp;quot;: err}
	this.ServeJSON()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;224-添加相册文件上传路由&#34;&gt;2.2.4 添加相册、文件上传路由&lt;/h4&gt;
&lt;p&gt;最后要注册路由：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//相册
beego.Router(&amp;quot;/album&amp;quot;, &amp;amp;controllers.AlbumController{})
//文件上传
beego.Router(&amp;quot;/upload&amp;quot;, &amp;amp;controllers.UploadController{})
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;225-添加相册model&#34;&gt;2.2.5 添加相册model&lt;/h4&gt;
&lt;h5 id=&#34;2251-相册结构体定义&#34;&gt;2.2.5.1 相册结构体定义&lt;/h5&gt;
&lt;p&gt;接下来我们创建一个新的model，album_model.go文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Album struct {
	Id         int
	Filepath   string
	Filename   string
	Status     int
	Createtime int64
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2252-添加方法&#34;&gt;2.2.5.2 添加方法&lt;/h5&gt;
&lt;p&gt;我们需要在album_model.go文件中，添加插入数据的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//-------插入图片---------------
func InsertAlbum(album Album) (int64, error) {
	return utils.ModifyDB(&amp;quot;insert into album(filepath,filename,status,createtime)values(?,?,?,?)&amp;quot;,
		album.Filepath, album.Filename, album.Status, album.Createtime)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;226-项目运行&#34;&gt;2.2.6 项目运行&lt;/h4&gt;
&lt;p&gt;重启项目后，点击图片按钮，然后选择一张图片：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190524-114125@2x.png&#34; alt=&#34;文件上传效果&#34;&gt;&lt;/p&gt;
&lt;p&gt;点击提交文件按钮后，可以上传图片了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190524-114242@2x.png&#34; alt=&#34;上传图片成功&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们可以查询一下数据库：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190524-114318@2x.png&#34; alt=&#34;数据库验证&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;23-查看图片&#34;&gt;2.3 查看图片&lt;/h3&gt;
&lt;p&gt;通过上面的操作已经能够上传文件了，那么如何显示文件呢？当点击图片标签的时候，除了有上传操作，还应该可以显示已经存储的图片。&lt;/p&gt;
&lt;h4 id=&#34;231-model层添加方法&#34;&gt;2.3.1 Model层添加方法&lt;/h4&gt;
&lt;p&gt;我们现在album_model.go文件中，添加查找图片数据的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//--------查询图片----------
func FindAllAlbums() ([]Album, error) {
	rows, err := utils.QueryDB(&amp;quot;select id,filepath,filename,status,createtime from album&amp;quot;)
	if err != nil {
		return nil, err
	}
	var albums []Album
	for rows.Next() {
		id := 0
		filepath := &amp;quot;&amp;quot;
		filename := &amp;quot;&amp;quot;
		status := 0
		var createtime int64
		createtime = 0
		rows.Scan(&amp;amp;id, &amp;amp;filepath, &amp;amp;filename, &amp;amp;status, &amp;amp;createtime)
		album := Album{id, filepath, filename, status, createtime}
		albums = append(albums, album)
	}
	return albums, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;232-修改控制器方法&#34;&gt;2.3.2 修改控制器方法&lt;/h4&gt;
&lt;p&gt;接下来，我们修改album_controller.go文件中的Get()方法，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (this *AlbumController) Get() {
	albums,err := models.FindAllAlbums()
	if err !=nil{
		log.Error(err)
	}
	this.Data[&amp;quot;Album&amp;quot;] = albums
	this.TplName=&amp;quot;album.html&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;233-修改视图层&#34;&gt;2.3.3 修改视图层&lt;/h4&gt;
&lt;p&gt;最后我们还要修改一下html页面，在album.html中，添加以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;album-box&amp;quot;&amp;gt;
    {{range .Album}}
        &amp;lt;div class=&amp;quot;album-item&amp;quot; style=&#39;background-image: url(&amp;quot;{{.Filepath}}&amp;quot;);&#39;&amp;gt;&amp;lt;/div&amp;gt;
    {{end}}
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;234-项目运行&#34;&gt;2.3.4 项目运行&lt;/h4&gt;
&lt;p&gt;我们上传几张图片后，刷新页面：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190524-114301@2x.png&#34; alt=&#34;图片查看&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;三-关于我功能开发及项目总结&#34;&gt;三 关于我功能开发及项目总结&lt;/h2&gt;
&lt;p&gt;本节课内容我们来开发完成本系列课程的最后一个功能--关于我页面的功能开发，同时对本系列课程内容做一个回顾与总结。&lt;/p&gt;
&lt;h3 id=&#34;31-关于我功能开发&#34;&gt;3.1 关于我功能开发&lt;/h3&gt;
&lt;h4 id=&#34;311-添加关于我控制器&#34;&gt;3.1.1 添加&amp;quot;关于我&amp;quot;控制器&lt;/h4&gt;
&lt;p&gt;首先创建一个新的go文件，aboutme_controller.go&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package controllers
type AboutMeController struct {
	BaseController
}
func (c *AboutMeController) Get() {
	c.Data[&amp;quot;wechat&amp;quot;] = &amp;quot;微信：13167582311&amp;quot;
	c.Data[&amp;quot;qq&amp;quot;] = &amp;quot;QQ：861574834&amp;quot;
	c.Data[&amp;quot;tel&amp;quot;] = &amp;quot;Tel：13167582311&amp;quot;
	c.TplName = &amp;quot;aboultme.html&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;312-注册关于我路由解析&#34;&gt;3.1.2 注册关于我路由解析&lt;/h4&gt;
&lt;p&gt;然后不要忘记注册路由：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//关于我
beego.Router(&amp;quot;/aboutme&amp;quot;, &amp;amp;controllers.AboutMeController{})
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;313-关于我视图层&#34;&gt;3.1.3 关于我视图层&lt;/h4&gt;
&lt;p&gt;然后我们要写一个html页面，aboultme.html：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;{{.Title}}&amp;lt;/title&amp;gt;
    &amp;lt;link href=&amp;quot;../static/css/blogsheet.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
    &amp;lt;link href=&amp;quot;../static/css/lib/highlight.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

{{template &amp;quot;block/nav.html&amp;quot; .}}

&amp;lt;div id=&amp;quot;aboutme&amp;quot;&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;img src=&amp;quot;http://7xtcwd.com1.z0.glb.clouddn.com/wechat_avator.png&amp;quot;&amp;gt;

        &amp;lt;div id=&amp;quot;myt&amp;quot;&amp;gt;
            &amp;lt;p class=&amp;quot;myp&amp;quot;&amp;gt;
                &amp;lt;a href=&amp;quot;http://{{.wechat}}&amp;quot;&amp;gt;{{.wechat}}&amp;lt;/a&amp;gt;
            &amp;lt;/p&amp;gt;
            &amp;lt;p class=&amp;quot;myp&amp;quot;&amp;gt;
                &amp;lt;a href=&amp;quot;http://{{.qq}}&amp;quot;&amp;gt;{{.qq}}&amp;lt;/a&amp;gt;
            &amp;lt;/p&amp;gt;
            &amp;lt;p class=&amp;quot;myp&amp;quot;&amp;gt;
                &amp;lt;a href=&amp;quot;http://{{.tel}}&amp;quot;&amp;gt;{{.tel}}&amp;lt;/a&amp;gt;
            &amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32-课程总结&#34;&gt;3.2 课程总结&lt;/h3&gt;
&lt;p&gt;经过了16节的课程内容，我们完成了使用Beego框架开发完成了一个博客系统。通过该项目，以期大家能够掌握Beego框架的使用方法。现在我们来回顾一下Beego框架开发一个web项目所需要掌握的一些重要知识点。&lt;/p&gt;
&lt;h4 id=&#34;321-beego框架组成&#34;&gt;3.2.1 beego框架组成&lt;/h4&gt;
&lt;p&gt;Beego框架的八大模块分别是&lt;strong&gt;cache，config，context，httplibs，logs，orm，session，toolbox&lt;/strong&gt;等模块组合而成。模块之间高度解耦，依赖性低。&lt;/p&gt;
&lt;h4 id=&#34;322-beego框架调试工具&#34;&gt;3.2.2 beego框架调试工具&lt;/h4&gt;
&lt;p&gt;Beego框架的项目管理工具Bee工具的使用，可以方便开发者管理、调试、打包项目，自动生成项目目录结构等。&lt;/p&gt;
&lt;h4 id=&#34;323-beego程序执行流程&#34;&gt;3.2.3 beego程序执行流程&lt;/h4&gt;
&lt;p&gt;**Beego框架执行流程：**Beego框架的程序执行流程如下图所示。
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190527-103955@2x.png&#34; alt=&#34;beego框架执行流程&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;324-数据库操作&#34;&gt;3.2.4 数据库操作&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;数据库连接：
&lt;ul&gt;
&lt;li&gt;驱动：beego中的orm支持MySQL，Sqlite3、PostgreSQL。&lt;/li&gt;
&lt;li&gt;用户名、密码、主机、端口号、数据库名称等的配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据库操作：
&lt;ul&gt;
&lt;li&gt;sql语句&lt;/li&gt;
&lt;li&gt;条件查询&lt;/li&gt;
&lt;li&gt;统计功能&lt;/li&gt;
&lt;li&gt;增加（insert）、删除（delete）、修改（update）、查询（select）&lt;/li&gt;
&lt;li&gt;模糊查询&lt;/li&gt;
&lt;li&gt;表关联&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;325-beego项目架构&#34;&gt;3.2.5 beego项目架构&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**mvc模式：**m（model）模型层，v（view）视图层，c（controller）控制器层。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;路由解析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认路由：beego模块自带Post、Put、Delete、Head、Options、Patch等网络请求类型的对应方法&lt;/li&gt;
&lt;li&gt;自动路由（自动映射到Get、Post、Put、Delete、Head、Options、Patch等方法。&lt;/li&gt;
&lt;li&gt;正则表达式路由（支持正则表达式及变量）&lt;/li&gt;
&lt;li&gt;自定义路由：开发者自己指定路由解析方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Session处理：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;两种管理方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置文件配置session相关配置项&lt;/li&gt;
&lt;li&gt;在程序中通过SessionConfig中进行配置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SetSession：设置session值&lt;/li&gt;
&lt;li&gt;GetSession：获取session值&lt;/li&gt;
&lt;li&gt;DelSession：删除session值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Views视图模板：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;views目录存放视图模板文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;controller.TplName 指定渲染的页面模板文件全称&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模板文件中通过**{{.param}}**实现变量的使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;controller.Data[&amp;quot;param&amp;quot;]为模板页面的变量赋值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E6%A1%86%E6%9E%B6/">框架</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>数据表的查询语句</title>
                <link>http://www.songx.fun/blog/day23-24mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/day24_%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day23-24mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/day24_%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;数据表的查询语句&#34;&gt;数据表的查询语句&lt;/h1&gt;
&lt;p&gt;用户对于数据表或视图等最常用的操作就是查询。也叫检索。通过select语句来实现
语法规则：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select {columns}
  from {table|view|other select}
  [where 查询条件]
  [group by 分组条件]
  [having 分组后再限定]
  [order by 排序]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sql的语句对于大小写不敏感。数值也不分。(Oracle中数值区分大小写)&lt;/li&gt;
&lt;li&gt;关键字不能被分行&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;一简单查询&#34;&gt;一、简单查询&lt;/h2&gt;
&lt;p&gt;select 的检索语句中，只有select ，以及from子句。也是一个select语句必须的。&lt;/p&gt;
&lt;h3 id=&#34;11-指定列名&#34;&gt;1.1 指定列名&lt;/h3&gt;
&lt;p&gt;查询指定的列：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt; select 列名,列名 from 表名
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;如果查询表中所有的字段，使用*。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-指定别名&#34;&gt;1.2 指定别名&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select 列名 as 别名,列名 别名 from 表名
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;as关键字：其实也可以省略。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;13-列运算&#34;&gt;1.3 列运算&lt;/h3&gt;
&lt;p&gt;可以使用算术表达式&lt;/p&gt;
&lt;p&gt;在select语句中，检索到字段类型如果是number，date可以使用算术表达式
加：+，减：-，乘：*，除:/,括号&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果某一列有null数值，那么计算后的结果也是null。通用函数:ifnull(a,b),a为null那么取b，如果a不为null那么取a的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;14-字符串类型可以做连续运算&#34;&gt;1.4 字符串类型可以做连续运算&lt;/h3&gt;
&lt;p&gt;concat(“我的名字是”, name,&#39;我今年。。&#39;);&lt;/p&gt;
&lt;p&gt;把搜索到的列和列进行拼接显示。&lt;/p&gt;
&lt;h3 id=&#34;15-去重重复distinct-字段名&#34;&gt;1.5 去重重复：distinct 字段名&lt;/h3&gt;
&lt;p&gt;distinct 列名，表示去除重复
distinct 列名1，列名2，一行的数据都相同，才会被认为是重复的数据，去除。&lt;/p&gt;
&lt;h2 id=&#34;二-条件查询&#34;&gt;二、 条件查询&lt;/h2&gt;
&lt;p&gt;在实际查询的过程中, 我们需要根据需要来过滤出我们想要的数据, 这种查询就叫条件查询。在检索数据信息的时候，使用限定条件。表示满足条件才会被检索到。&lt;/p&gt;
&lt;p&gt;使用where子句语法格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select 检索列 from 表名 where 筛选条件
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;条件查询使用&lt;code&gt;where&lt;/code&gt;子句对表中的数据进行筛选, 结果为&lt;code&gt;true&lt;/code&gt;的行会出现的结果集中.&lt;/p&gt;
&lt;p&gt;条件的表达式支持多种运算:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;21-比较运算符&#34;&gt;2.1 比较运算符&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;等于 &lt;code&gt;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;大于 &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;小于 &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;大于等于 &lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;小于等于 &lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不等于 &lt;code&gt;!=&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;查找年龄大于30岁的:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select * from stus where age&amp;gt;30;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询姓名不是&lt;code&gt;王二狗&lt;/code&gt;的:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select * from stus where name!=&#39;王二狗&#39;;
或者
select * from stus where name&amp;lt;&amp;gt;&#39;王二狗&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22-逻辑运算符&#34;&gt;2.2 逻辑运算符&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;and, &amp;amp;&amp;amp; (与)&lt;/li&gt;
&lt;li&gt;or, || (或)&lt;/li&gt;
&lt;li&gt;not, !(非)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;查询年龄大于30并且性别是女的:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select * from stus where age&amp;gt;30 and sex=&#39;女&#39;;
或
select * from stus where age&amp;gt;30 &amp;amp;&amp;amp; sex=&#39;女&#39;;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询年龄小于30或者性别是男的:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select * from stus where age&amp;lt;30 or sex=&#39;男&#39;;
或
select * from stus where age&amp;lt;30 || sex=&#39;男&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;23-模糊查询&#34;&gt;2.3 模糊查询&lt;/h3&gt;
&lt;p&gt;比如想查询姓名中含有&#39;张&#39;的这种需求, 就需要用到模糊查询.&lt;/p&gt;
&lt;p&gt;模糊查询用到关键字 &lt;code&gt;like&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select * from stus name like &#39;%张%&#39;;
李李张张
王张
张
张三
张三三
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;%&lt;/code&gt;表示任意多个字符（0-多个）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;_&lt;/code&gt;(下划线)表示任意一个字符&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;查询姓名是两个字符的:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select * from stus where name like &#39;张__&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;24-区间查询&#34;&gt;2.4 区间查询&lt;/h3&gt;
&lt;h4 id=&#34;241-in-&#34;&gt;2.4.1 in (...)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;in&lt;/code&gt; 表示在一个离散的非连续的范围中查找&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查找id的值等于1或3或4的:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select * from stus where id in (1, 3,4);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;242-betweenand&#34;&gt;2.4.2 between...and...&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;between...and...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;表示在一个连续的区间中查找.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查找id的值在3到7之间的:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select * from stus where id between 3 and 7;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;25-null判断&#34;&gt;2.5 NULL判断&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;is NULL&lt;/code&gt; 用来判断某列是否为空. 注意: &lt;code&gt;NULL&lt;/code&gt;用小写也是可以的.&lt;/p&gt;
&lt;h2 id=&#34;三排序&#34;&gt;三、排序&lt;/h2&gt;
&lt;p&gt;默认情况下, 我们查到的顺序是按照数据在数据库中的插入顺序排列的.
但是在实际情况下,我们需要根据不同的条件来排序, 比如按照更新日期排序, 或者按照价格从低到高排序, 或者按照人气从高到底排序等等.
&lt;strong&gt;mysql支持对查询的结果进行重新排序.&lt;/strong&gt;
使用order by 列子句可以完成排序的功能. 后面的列表示排序规则.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;order by 子句。语法上位于一条sql语句的末尾。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;31-升序asc&#34;&gt;3.1 升序(asc)&lt;/h3&gt;
&lt;p&gt;默认是升序排序
按照年龄从低到高排序.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select * from stus order by age;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;默认情况下是按照升序排序.asc&lt;/p&gt;
&lt;p&gt;也可以在列的后面添加asc(ascend 提升)表示升序.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用desc表示降序&lt;/p&gt;
&lt;p&gt;desc是单词 descend(下降)的缩写, 来表示降序排序.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;32-降序desc&#34;&gt;3.2 降序(desc)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select * from stus order by age asc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;33-多种排序规则&#34;&gt;3.3 多种排序规则&lt;/h3&gt;
&lt;p&gt;可以先按照一定规则来排序, 当碰到相同的情况下, 按照第二种规则来排序, ...
先按照年龄升序排序, 如果年龄相等再按照id的降序排序.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select * from stus order by age asc,id desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四聚合函数&#34;&gt;四、聚合函数&lt;/h2&gt;
&lt;p&gt;在查询中，统计,求和等是很常用的，通过聚合函数完成能十分省事.&lt;/p&gt;
&lt;p&gt;如果没有聚合函数，可能需要各种子查询，各种sql嵌套才能完成.&lt;/p&gt;
&lt;p&gt;但是有了&lt;strong&gt;聚合函数&lt;/strong&gt;，很多问题迎刃而解。&lt;/p&gt;
&lt;p&gt;mysql提供了5个常用的聚合函数:&lt;code&gt;sum(), max(), min(), avg(), count()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当然配合聚合函数使用的还有分组&lt;code&gt;group by 和 having子句&lt;/code&gt;, 下一节再细讲.&lt;/p&gt;
&lt;h3 id=&#34;41-sum列&#34;&gt;4.1 sum(列)&lt;/h3&gt;
&lt;p&gt;这个聚合函数用来对那些列不是&lt;code&gt;null&lt;/code&gt;的值进行求和.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对所有的age求和
​&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多所年龄小于100的age求和&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42-max列&#34;&gt;4.2 max(列)&lt;/h3&gt;
&lt;p&gt;这个聚合函数用来计算那些列不是&lt;code&gt;null&lt;/code&gt;的值最大值.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到最大的年龄&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;43-min列&#34;&gt;4.3 min(列)&lt;/h3&gt;
&lt;p&gt;这个聚合函数用来计算那些列不是&lt;code&gt;null&lt;/code&gt;的值最小值.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到最小的年龄&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;44-avg列&#34;&gt;4.4 avg(列)&lt;/h3&gt;
&lt;p&gt;这个聚合函数用来计算那些列不是&lt;code&gt;null&lt;/code&gt;的值平均值.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算&lt;code&gt;age&lt;/code&gt;的平均值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;45-count列&#34;&gt;4.5 count(列)&lt;/h3&gt;
&lt;p&gt;统计函数.&lt;/p&gt;
&lt;p&gt;count(*)---&amp;gt;统计所有行的数据,16&lt;/p&gt;
&lt;p&gt;count(主键列)--&amp;gt;16&lt;/p&gt;
&lt;p&gt;count(非主键列1),是否存在null数值。&lt;/p&gt;
&lt;p&gt;count(comm)--&amp;gt;6&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;统计一共有多少行数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统计性别不为&lt;code&gt;null&lt;/code&gt;的数据 行数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;五分组查询&#34;&gt;五、分组查询&lt;/h2&gt;
&lt;p&gt;分组(group by)
group by 列名, 按照指定的列进行分组, 值相同的会分在一组.
语法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select 列名 from 表名 group by 列名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;select后面跟的列名必须和group by后的列列名保持一致.&lt;/li&gt;
&lt;li&gt;当group by单独使用时, 只显示每组的第一条记录. 所以group by单独使用的意义不大.大多要配合聚合函数。&lt;/li&gt;
&lt;li&gt;group by后面也可以给多个列进行分组, 表示这些列都相同的时候在一组.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;51-按照某列分组&#34;&gt;5.1 按照某列分组&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select sex from  stus group by sex;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;52-按照多列分组&#34;&gt;5.2 按照多列分组&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select name, sex from stus group by name,sex; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;53-分组后使用聚合函数&#34;&gt;5.3 分组后使用聚合函数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select sex,count(*) from stus group by sex;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果没有分组，那么组函数(max,min,avg,count....)作用在整张表上。&lt;/li&gt;
&lt;li&gt;如果有分组，组函数作用在分组后的数据上。&lt;/li&gt;
&lt;li&gt;在写select 子句中列，如果没有在组函数里，那么就要在group by后边。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select a，b，count(c),sum(d) from 表 group by a,b;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;54-分组后限定查询having&#34;&gt;5.4 分组后限定查询：having&lt;/h3&gt;
&lt;p&gt;二次筛选：二次筛选是指分组后再对数据进行筛选.
需要使用having子句来完成.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select 列名 from  表名 group by 列名 having 条件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是说，分组后再限定，使用having子句&lt;/p&gt;
&lt;p&gt;having子句对于group by分组后的结果，进行再次筛选。最后输出的结果就满足having条件的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;having子句的和where子句的用法类似，都是用于限定条件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;对比：
1. where和having后面都是跟条件
2. where是对表中的数据的原始筛选
3. having是对group by的结果的二次筛选
4. having必须配合group by使用, 一般也会跟着聚合函数一起使用
5. 可以先有where, 后面跟着group by和having

区别和结论：
  1.语法上：在having中使用组函数(max,min,avg,count...),而where后不能用组函数。
  2.执行上：where是先过滤再分组。having是先分组再过滤。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：把sex不是null的过滤出来.&lt;/p&gt;
&lt;p&gt;例如：把男或女的个数超过6的过滤出来&lt;/p&gt;
&lt;h2 id=&#34;六分页查询&#34;&gt;六、分页查询&lt;/h2&gt;
&lt;p&gt;Limit子句(方言)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;方言的意思是limit是mysql特有的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Limit用于限定查询结果的起始行，以及总行数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select * from 表名 limit start,count;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如：查询起始行为第5行，一共查询3行&lt;/p&gt;
&lt;p&gt;select * from stus limit 4, 3;&lt;/p&gt;
&lt;p&gt;​	其中4表示从第5行开始，其中2表是查询3行。即5,6,7行记录。&lt;/p&gt;
&lt;h2 id=&#34;七内置函数扩展&#34;&gt;七、内置函数[扩展]&lt;/h2&gt;
&lt;h3 id=&#34;71-字符串函数&#34;&gt;7.1 字符串函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;查看字符的ascii码值ascii(str)，str是空串时返回0&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select ascii(&#39;a&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看ascii码值对应的字符char(数字)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select char(97);

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;拼接字符串concat(str1,str2...)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select concat(12,34,&#39;ab&#39;);

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;包含字符个数length(str)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select length(&#39;abc&#39;);

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;截取字符串
&lt;ul&gt;
&lt;li&gt;left(str,len)返回字符串str的左端len个字符&lt;/li&gt;
&lt;li&gt;right(str,len)返回字符串str的右端len个字符&lt;/li&gt;
&lt;li&gt;substring(str,pos,len)返回字符串str的位置pos起len个字符，从1开始&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select substring(&#39;abc123&#39;,2,3);

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;去除空格
&lt;ul&gt;
&lt;li&gt;ltrim(str)返回删除了左空格的字符串str&lt;/li&gt;
&lt;li&gt;rtrim(str)返回删除了右空格的字符串str&lt;/li&gt;
&lt;li&gt;trim([方向 remstr from str)返回从某侧删除remstr后的字符串str，方向词包括both、leading、trailing，表示两侧、左、右&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select trim(&#39;  bar   &#39;);
select trim(leading &#39;x&#39; FROM &#39;xxxbarxxx&#39;);
select trim(both &#39;x&#39; FROM &#39;xxxbarxxx&#39;);
select trim(trailing &#39;x&#39; FROM &#39;xxxbarxxx&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;返回由n个空格字符组成的一个字符串space(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select space(10);

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;替换字符串replace(str,from_str,to_str)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select replace(&#39;abc123&#39;,&#39;123&#39;,&#39;def&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;大小写转换，函数如下
&lt;ul&gt;
&lt;li&gt;lower(str)&lt;/li&gt;
&lt;li&gt;upper(str)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select lower(&#39;aBcD&#39;);

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;72-数学函数&#34;&gt;7.2 数学函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;求绝对值abs(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select abs(-32);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;求m除以n的余数mod(m,n)，同运算符%&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select mod(10,3);
select 10%3;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;地板floor(n)，表示不大于n的最大整数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select floor(2.3);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;天花板ceiling(n)，表示不小于n的最大整数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select ceiling(2.3);

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;求四舍五入值round(n,d)，n表示原数，d表示小数位置，默认为0&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select round(1.6);

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;求x的y次幂pow(x,y)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select pow(2,3);

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;获取圆周率PI()&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select PI();
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;随机数rand()，值为0-1.0的浮点数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select rand();
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;还有其它很多三角函数，使用时可以查询文档&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;73-日期时间函数&#34;&gt;7.3 日期时间函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;获取子值，语法如下
&lt;ul&gt;
&lt;li&gt;year(date)返回date的年份(范围在1000到9999)&lt;/li&gt;
&lt;li&gt;month(date)返回date中的月份数值&lt;/li&gt;
&lt;li&gt;day(date)返回date中的日期数值&lt;/li&gt;
&lt;li&gt;hour(time)返回time的小时数(范围是0到23)&lt;/li&gt;
&lt;li&gt;minute(time)返回time的分钟数(范围是0到59)&lt;/li&gt;
&lt;li&gt;second(time)返回time的秒数(范围是0到59)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select year(&#39;2016-12-21&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;日期计算，使用+-运算符，数字后面的关键字为year、month、day、hour、minute、second&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select &#39;2016-12-21&#39;+interval 1 day;
select &#39;2017-12-12&#39; + interval 3 month;
select date_add(&#39;2017-12-12&#39;, interval 1 day);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;日期格式化date_format(date,format)，format参数可用的值如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;获取年%Y，返回4位的整数&lt;/p&gt;
&lt;p&gt;*　获取年%y，返回2位的整数&lt;/p&gt;
&lt;p&gt;*　获取月%m，值为1-12的整数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取日%d，返回整数&lt;/p&gt;
&lt;p&gt;*　获取时%H，值为0-23的整数&lt;/p&gt;
&lt;p&gt;*　获取时%h，值为1-12的整数&lt;/p&gt;
&lt;p&gt;*　获取分%i，值为0-59的整数&lt;/p&gt;
&lt;p&gt;*　获取秒%s，值为0-59的整数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select date_format(&#39;2016-12-21&#39;,&#39;%Y %m %d&#39;);
select str_to_date(&#39;12/12/2017&#39;,&#39;%d/%m/%Y&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;当前日期current_date()&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select current_date();

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;当前时间current_time()&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select current_time();

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;当前日期时间now()&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select now();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;七多表查询&#34;&gt;七、多表查询&lt;/h2&gt;
&lt;p&gt;连接查询：当需要对有关系的多张表进行查询时，需要使用连接join&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;合并结果集&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要求被合并的表中，列的类型和列数相同&lt;/li&gt;
&lt;li&gt;UNION,去除重复行&lt;/li&gt;
&lt;li&gt;UNION ALL， 不去除重复行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;分类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 内连接
2. 外连接
	 A：左外连接
	 B：右外连接
	 C：全外连接(Mysql不支持)
3. 自连接(术语一种简化方式)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;71-笛卡尔积&#34;&gt;7.1 笛卡尔积&lt;/h3&gt;
&lt;p&gt;如果两张表在连接查询时，如果没有连接条件，那么就会产生笛卡尔积。(冗余数据)。&lt;/p&gt;
&lt;h3 id=&#34;71-内连接&#34;&gt;7.1 内连接&lt;/h3&gt;
&lt;p&gt;内连接查询出的所有的记录都满足条件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;方言：select * from 表1 别名1, 表2 别名2 where 别名1.xx=别名2.xx
	也叫等值链接
标准：select * from 表1 别名1 inner join 表2 别名2 on 别名1.xx=别名2.xx
自然：select * from 表1 别名1 natural join 表2 别名2

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;72-外连接&#34;&gt;7.2 外连接&lt;/h3&gt;
&lt;p&gt;内连接所检索出来的结果，都是满足连接条件的。外链接是扩展内连接检索出来的结果集。外链接返回的结果，除了包含满足链接条件的记录，还包括不满足连接条件。&lt;/p&gt;
&lt;h4 id=&#34;721-左外连接&#34;&gt;7.2.1 左外连接&lt;/h4&gt;
&lt;p&gt;左表记录无论是否满足条件都会查询出来，而右表只有满足条件才能查询出来。左表中不满足条件的记录，右表部分都为NULL&lt;/p&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;左外：
	select * from 表1 别名1 left outer join 表2 别名2 on 别名1.xx=别名2.xx
	
左外自然：
	select * from 表1 别名1 natural left outer join 表2 别名2 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;722-右外连接&#34;&gt;7.2.2 右外连接&lt;/h4&gt;
&lt;p&gt;右表记录无论是否满足条件都会查询出来，而左表只有满足条件才能查询出来。右表中不满足条件的记录，左表部分都为NULL&lt;/p&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;
右外：
	select * from 表1 别名1 right outer join 表2 别名2 on 别名1.xx=别名2.xx
	

右外自然：
	select * from 表1 别名1 natural right outer join 表2 别名2 

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;723-全外连接&#34;&gt;7.2.3 全外连接&lt;/h4&gt;
&lt;p&gt;Mysql不支持全外连接(full outer join)，但是可以使用union来合并左外连接以及右外连接的结果，达到全外连接的效果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;左外连接
SELECT e.ename,e.sal, d.dname,e.deptno,d.deptno
FROM emp e LEFT OUTER JOIN dept d
ON e.deptno=d.deptno
UNION
右外连接
SELECT e.ename,e.sal, d.dname,e.deptno,d.deptno
FROM emp e RIGHT OUTER JOIN dept d
ON e.deptno=d.deptno
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;73-自连接&#34;&gt;7.3 自连接&lt;/h3&gt;
&lt;p&gt;自连接(术语一种简化方式)。其实就是一张表连接字节。&lt;/p&gt;
&lt;p&gt;查询员工的上级名称&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;SELECT e.empno,e.ename,e.mgr,m.empno,m.ename
FROM emp e LEFT OUTER JOIN emp m
ON e.mgr=m.empno
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;八子查询&#34;&gt;八、子查询&lt;/h2&gt;
&lt;p&gt;子查询是指sql语句中包含另一个select语句。内查询或者内select语句&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一条sql语句中，包含多个select关键字&lt;/p&gt;
&lt;p&gt;外查询，内查询&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;子查询可以出现的位置：&lt;/p&gt;
&lt;p&gt;​	from后，作为表&lt;/p&gt;
&lt;p&gt;​	where后，作为条件&lt;/p&gt;
&lt;p&gt;注意事项：
1.子查询必须在()里
2.在子查询中不能使用order by子句。
3.子查询可以再嵌套子查询，最多不能超过255层。&lt;/p&gt;
&lt;p&gt;子查询细分为：单行子查询，多行子查询，关联子查询。&lt;/p&gt;
&lt;p&gt;1.单行子查询
子查询的结果是单行数据。
在where条件后需要配合单行运算符：&amp;gt;,&amp;lt;,&amp;gt;=,&amp;lt;=,!=,=
2.多行子查询
子查询的结果是多行数据。
在where条件后需要配合：in，any，all运算符
in：
any：匹配上子查询的结果集中任意一个即可。
all：匹配上子查询的所有的结果。&lt;/p&gt;
&lt;p&gt;3.关联子查询
对于单行子查询和多行子查询，外查询和内查询是分开执行的。
如果外查询使用到内查询的结果，就使用关联子查询。
关联子查询，是指在内查询中需要借助于外查询，而外查询离不开内查询的执行。就叫关联子查询。&lt;/p&gt;
&lt;h2 id=&#34;九总结&#34;&gt;九、总结&lt;/h2&gt;
&lt;p&gt;完整的select语句书写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select distinct *
from 表名
where ....
group by ... having ...
order by ...
limit start,count
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行顺序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;from 表名
where ...
group by ...
having ...
select distinct*..
order by ...
limit start,count
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际使用中，只是使用语句中某些部分的组合，而不是全部。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/mysql/">mysql</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/db/">db</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/mysql/">mysql</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>数据库</title>
                <link>http://www.songx.fun/blog/day23-24mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/day23_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day23-24mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/day23_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;day23-学习笔记&#34;&gt;day23 学习笔记&lt;/h1&gt;
&lt;h2 id=&#34;一数据库&#34;&gt;一、数据库&lt;/h2&gt;
&lt;h3 id=&#34;11-数据库-基本知识&#34;&gt;1.1 数据库 基本知识&lt;/h3&gt;
&lt;p&gt;DB：&lt;/p&gt;
&lt;p&gt;DBMS：&lt;/p&gt;
&lt;p&gt;数据库，数据表，表的结构。。&lt;/p&gt;
&lt;p&gt;DB：是指datebase（数据库）
数据库是存储数据的一个集合，数据库中通常使用数据表等组成，而数据表是由数据的字段和数据的值等信息组成。
DBMS:是指datebase mangement systerm（数据库管理系统）
它是操作数据库和管理数据库的一个系统，比如mysql、sqlserver等都是属于数据库管理软件，人们通过这些系统或者工具来管理数据库内的数据。
DBS:是指datebase systerm (数据库系统）
数据库系统又数据库和数据库管理软件等组成，数据库是一个逻辑上的存储数据的概念，而对应的是实体是数据库管理软件存储存储在硬盘上的数据库，所以数据库系统包含数据库和数据库管理软件。&lt;/p&gt;
&lt;h3 id=&#34;12-mysql的安装和卸载&#34;&gt;1.2 Mysql的安装和卸载&lt;/h3&gt;
&lt;h3 id=&#34;13-登录&#34;&gt;1.3 登录&lt;/h3&gt;
&lt;p&gt;方式一：DOS窗口：输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\ruby&amp;gt;mysql -u root -p
回车后输入密码即可
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190725-112248.png&#34; alt=&#34;WX20190725-112248&#34;&gt;&lt;/p&gt;
&lt;p&gt;方式二：通过Mysql的Command Line来登录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;直接输入密码即可
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190725-112402.png&#34; alt=&#34;WX20190725-112402&#34;&gt;&lt;/p&gt;
&lt;p&gt;方式三：通过其他的可视化工具软件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190725-112650.png&#34; alt=&#34;WX20190725-112650&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;14-创建数据库&#34;&gt;1.4 创建数据库：&lt;/h3&gt;
&lt;p&gt;1.创建数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;//create database [if not exists]数据库名 [default charset utf8 collate utf8_general_ci];
mysql&amp;gt; create database my1905 character set utf8;
Query OK, 1 row affected (0.00 sec)


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.显示有哪些数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; show databases;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190725-120339.png&#34; alt=&#34;WX20190725-120339&#34;&gt;&lt;/p&gt;
&lt;p&gt;3.切换到数据库：以后的操作都是针对该数据库的，比如建表。。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; use my1905;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.查看当前数据库有哪些数据表：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; show tables;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190725-120545.png&#34; alt=&#34;WX20190725-120545&#34;&gt;&lt;/p&gt;
&lt;p&gt;5.删除数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; drop database if exists my1905;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;15-数据类型&#34;&gt;1.5 数据类型&lt;/h3&gt;
&lt;p&gt;char(10)--&amp;gt;定长的字符串&lt;/p&gt;
&lt;p&gt;​	&amp;quot;wangergou &amp;quot;&lt;/p&gt;
&lt;p&gt;​	&amp;quot;abc               &amp;quot;&lt;/p&gt;
&lt;p&gt;varchar(10)--&amp;gt;变长&lt;/p&gt;
&lt;p&gt;​	&amp;quot;wangergou&amp;quot;&lt;/p&gt;
&lt;p&gt;​	“abc”&lt;/p&gt;
&lt;h3 id=&#34;16-数据表的操作&#34;&gt;1.6 数据表的操作&lt;/h3&gt;
&lt;p&gt;1.创建数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; create database if not exists my1905 default charset utf8 collate utf8_ge
neral_ci;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.创建数据表：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; create table users(
    -&amp;gt; id int(4) primary key auto_increment,
    -&amp;gt; username varchar(20),
    -&amp;gt; pwd varchar(30));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.查看表结构：desc--&amp;gt;describe&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; desc users;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190725-143324.png&#34; alt=&#34;WX20190725-143324&#34;&gt;&lt;/p&gt;
&lt;p&gt;4.显示检表语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; show create table users;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190725-143609.png&#34; alt=&#34;WX20190725-143609&#34;&gt;&lt;/p&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;p&gt;1.先创建数据库&lt;/p&gt;
&lt;p&gt;mysql：&lt;/p&gt;
&lt;p&gt;​	database1--&amp;gt;oa&lt;/p&gt;
&lt;p&gt;​	database2--&amp;gt;bluebird&lt;/p&gt;
&lt;p&gt;​	。。。。&lt;/p&gt;
&lt;p&gt;2.切换数据库&lt;/p&gt;
&lt;p&gt;​	use 数据库名&lt;/p&gt;
&lt;p&gt;3.创建数据表&lt;/p&gt;
&lt;p&gt;mysql&amp;gt;create table test1(&lt;/p&gt;
&lt;p&gt;​	-&amp;gt;id int(4) auto_increment primary key,&lt;/p&gt;
&lt;p&gt;​	-&amp;gt;......);&lt;/p&gt;
&lt;p&gt;5.插入一条数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; insert into users(id,username,pwd) values(1,&#39;admin&#39;,&#39;123456&#39;);
Query OK, 1 row affected (0.02 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.查询数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; select * from users;
+----+----------+--------+
| id | username | pwd    |
+----+----------+--------+
|  1 | admin    | 123456 |
+----+----------+--------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;17-修改表结构&#34;&gt;1.7 修改表结构&lt;/h3&gt;
&lt;p&gt;alter table 表名 xxx。。。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;添加字段:add&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; alter table users add(
    -&amp;gt; age int(4),
    -&amp;gt; birthday date);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190725-152709.png&#34; alt=&#34;WX20190725-152709&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改已有字段的数据类型：modify&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; alter table users modify age float(4,1);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190725-153114.png&#34; alt=&#34;WX20190725-153114&#34;&gt;&lt;/p&gt;
&lt;p&gt;注意点：并不能随意的更改已有列的数据类型。尤其是表中已经有数据了&lt;/p&gt;
&lt;p&gt;​	A：兼容类型：长度可以从小到大，不能已有的数据越界。&lt;/p&gt;
&lt;p&gt;​	B：不兼容类型：varchar--&amp;gt;int，更改失败。&lt;/p&gt;
&lt;p&gt;3.更改列的名字：change&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; alter table users change pwd password varchar(30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190725-153525.png&#34; alt=&#34;WX20190725-153525&#34;&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;删除某列：drop&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; alter table users drop birthday;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190725-153854.png&#34; alt=&#34;WX20190725-153854&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果该列存在数据，那么数据也会被删掉。&lt;/p&gt;
&lt;p&gt;5.表重命名：rename to&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; alter table users rename to user2;
mysql&amp;gt; rename table user2 to user3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190725-154455.png&#34; alt=&#34;WX20190725-154455&#34;&gt;&lt;/p&gt;
&lt;p&gt;6.删除表：drop table&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; drop table user3;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;18-插入数据&#34;&gt;1.8 插入数据&lt;/h3&gt;
&lt;p&gt;1.插入数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;insert into 表名(列1，列2，列3.。。) values(值1,值2,值3.。。)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全列插入：如果有所有列都要插入数据，那么可以省略列的名字&lt;/p&gt;
&lt;p&gt;缺省插入：如果有某一个或一些字段没有数值，那么就要写清楚列名和值。&lt;/p&gt;
&lt;p&gt;同时插入多行：&lt;/p&gt;
&lt;h3 id=&#34;19-修改数据&#34;&gt;1.9 修改数据&lt;/h3&gt;
&lt;p&gt;语法结构：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;update 表名 set 列1=值1,列2=值2...[where 条件];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where后是修改条件：为true，才会修改数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;运算符：
	=，数值相等
	!=，&amp;lt;&amp;gt;，数值不等
	between ... and，区间
	&amp;gt;
	&amp;lt;
	&amp;gt;=
	&amp;lt;=
	or
	and
	in(值1，值2，值3.。)



&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.修改学号为1006的同学姓名为陈聪&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; update student set name=&#39;陈聪&#39; where no=1006;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&amp;gt; select * from student;
+------+--------+------+------+------------+
| no   | name   | age  | sex  | birthday   |
+------+--------+------+------+------------+
| 1001 | 王二狗 |   18 | 男   | 2007-10-10 |
| 1002 | rose   |   19 | 女   | 2006-09-09 |
| 1003 | jack   |   20 | 男   | 2005-08-06 |
| 1004 | 张三   |   18 | 女   | 1990-12-12 |
| 1005 | 李四   |   21 | 男   | 1991-06-08 |
| 1006 | 陈聪   |   22 | 男   | 1992-10-10 |
+------+--------+------+------+------------+
6 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.年龄小于19岁的同学，性别改为女&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; update student set sex=&#39;女&#39; where age &amp;lt; 19;
Query OK, 1 row affected (0.01 sec)
Rows matched: 2  Changed: 1  Warnings: 0

mysql&amp;gt; select * from student;
+------+--------+------+------+------------+
| no   | name   | age  | sex  | birthday   |
+------+--------+------+------+------------+
| 1001 | 王二狗 |   18 | 女   | 2007-10-10 |
| 1002 | rose   |   19 | 女   | 2006-09-09 |
| 1003 | jack   |   20 | 男   | 2005-08-06 |
| 1004 | 张三   |   18 | 女   | 1990-12-12 |
| 1005 | 李四   |   21 | 男   | 1991-06-08 |
| 1006 | 陈聪   |   22 | 男   | 1992-10-10 |
+------+--------+------+------+------------+
6 rows in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.年龄大于等于18岁，并且小于等于19岁的同学姓名改为马冬梅&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; update student set name=&#39;马冬梅&#39; where age &amp;gt;= 18 and age &amp;lt;= 19;
Query OK, 3 rows affected (0.01 sec)
Rows matched: 3  Changed: 3  Warnings: 0

mysql&amp;gt; select *from student;
+------+--------+------+------+------------+
| no   | name   | age  | sex  | birthday   |
+------+--------+------+------+------------+
| 1001 | 马冬梅 |   18 | 女   | 2007-10-10 |
| 1002 | 马冬梅 |   19 | 女   | 2006-09-09 |
| 1003 | jack   |   20 | 男   | 2005-08-06 |
| 1004 | 马冬梅 |   18 | 女   | 1990-12-12 |
| 1005 | 李四   |   21 | 男   | 1991-06-08 |
| 1006 | 陈聪   |   22 | 男   | 1992-10-10 |
+------+--------+------+------+------------+
6 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.修改年龄19到20岁之间的同学姓名为马春梅：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; update student set name=&#39;马春梅&#39; where age between 19 and 20;
Query OK, 2 rows affected (0.01 sec)
Rows matched: 2  Changed: 2  Warnings: 0

mysql&amp;gt; select * from student;
+------+--------+------+------+------------+
| no   | name   | age  | sex  | birthday   |
+------+--------+------+------+------------+
| 1001 | 马冬梅 |   18 | 女   | 2007-10-10 |
| 1002 | 马春梅 |   19 | 女   | 2006-09-09 |
| 1003 | 马春梅 |   20 | 男   | 2005-08-06 |
| 1004 | 马冬梅 |   18 | 女   | 1990-12-12 |
| 1005 | 李四   |   21 | 男   | 1991-06-08 |
| 1006 | 陈聪   |   22 | 男   | 1992-10-10 |
+------+--------+------+------+------------+
6 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二sql&#34;&gt;二、SQL&lt;/h2&gt;
&lt;p&gt;结构化查询语言(Structured Query Language)。操作数据库的。&lt;/p&gt;
&lt;p&gt;DDL语言：数据定义语言(用于定义数据的表结构)Data Definition Language&lt;/p&gt;
&lt;p&gt;​	创建数据表：create table 表名&lt;/p&gt;
&lt;p&gt;​	修改数据表：alter table 表名&lt;/p&gt;
&lt;p&gt;​	删除数据表：drop table 表名&lt;/p&gt;
&lt;p&gt;DML语言：数据操纵语言(用于操作数据表中的数据)DML - Data Mainpulation Language&lt;/p&gt;
&lt;p&gt;​	添加数据：insert&lt;/p&gt;
&lt;p&gt;​	修改数据：update&lt;/p&gt;
&lt;p&gt;​	删除数据：delete&lt;/p&gt;
&lt;p&gt;DQL语言：数据查询语言(专门用于数据的查询)DQL - Data Query Language&lt;/p&gt;
&lt;p&gt;​	查询数据：select&lt;/p&gt;
&lt;p&gt;DCL语言：&lt;/p&gt;
&lt;h2 id=&#34;三总结&#34;&gt;三、总结&lt;/h2&gt;
&lt;p&gt;数据库：&lt;/p&gt;
&lt;p&gt;​	安装和卸载(看文档)&lt;/p&gt;
&lt;p&gt;​	数据库的登录：&lt;/p&gt;
&lt;p&gt;​		1.dos窗口：mysql命令---&amp;gt;配置环境变量&lt;/p&gt;
&lt;p&gt;​				-u 用户名&lt;/p&gt;
&lt;p&gt;​				-p 密码&lt;/p&gt;
&lt;p&gt;​		2.mysql的命令行：直接输入密码即可&lt;/p&gt;
&lt;p&gt;​		3.通过一些可视化工具：比如navicat&lt;/p&gt;
&lt;p&gt;1.show databases;&lt;/p&gt;
&lt;p&gt;2.create database if not exists my1905	character set utf8;&lt;/p&gt;
&lt;p&gt;​									default charset utf8 collate utf8_general_ci;&lt;/p&gt;
&lt;p&gt;3.use my1905;&lt;/p&gt;
&lt;p&gt;4.create table student(id int(4) primary key auto_increment，name varchar(30),sex varchar(2))；&lt;/p&gt;
&lt;p&gt;5.alter table 表名&lt;/p&gt;
&lt;p&gt;​	add 列名 数据类型&lt;/p&gt;
&lt;p&gt;​	modify 列名 数据类型&lt;/p&gt;
&lt;p&gt;​	change 原列名  新列名 数据类型&lt;/p&gt;
&lt;p&gt;​	drop 删除列&lt;/p&gt;
&lt;p&gt;6.drop table 表名;&lt;/p&gt;
&lt;p&gt;7.insert into 表名(列1，列2，列3.。。) values(值1，值2，值3.。。。)&lt;/p&gt;
&lt;p&gt;​	全列插入：&lt;/p&gt;
&lt;p&gt;​	同时插入多条：&lt;/p&gt;
&lt;p&gt;8.update 表名 set 列1=新值，列2=新值 [where 修改条件];&lt;/p&gt;
&lt;p&gt;​	where 后 的是表达式是boolean&lt;/p&gt;
&lt;p&gt;​	=,!=,&amp;lt;&amp;gt;,&amp;gt;,&amp;lt;,&amp;gt;=,&amp;lt;=,between and, and , or ,not ....&lt;/p&gt;
&lt;p&gt;​	null---&amp;gt; is null ,is not null&lt;/p&gt;
&lt;p&gt;9.delete from 表名 where 删除条件&lt;/p&gt;
&lt;p&gt;约束：主键，外键&lt;/p&gt;
&lt;p&gt;查询：简单查询，复杂，多表&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/mysql/">mysql</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/db/">db</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/mysql/">mysql</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>数据库基础知识</title>
                <link>http://www.songx.fun/blog/day23-24mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/day23_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day23-24mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/day23_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;数据库基础知识&#34;&gt;数据库基础知识&lt;/h1&gt;
&lt;h2 id=&#34;一数据库简介&#34;&gt;一、数据库简介&lt;/h2&gt;
&lt;h3 id=&#34;11为什么需要数据库&#34;&gt;1.1、为什么需要数据库&lt;/h3&gt;
&lt;p&gt;人类时刻有记录一些资料的需求, 最初的结绳记事&lt;/p&gt;
&lt;p&gt;随着人类的发展, 发明了文字, 数字等符号, 这些符号可以更好的记录生活中发生的各种事件.但是如何使记录更好的保存是个问题.&lt;/p&gt;
&lt;p&gt;从最初的龟壳到后来的纸张, 都用来记录这些信息. 慢慢到更现代化的各种磁盘等,随着信息的增长, 对数据存储的要求越来越高.  如何更加有效和快捷的处理这些信息成为了一个
难题.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/mysql1.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/mysql3.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/mysql4.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库的出现, 很好的解决了数据的存储效率和读取效率.&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;12什么是数据库&#34;&gt;1.2、什么是数据库&lt;/h3&gt;
&lt;p&gt;数据库(database)就是存储数据的仓库。为了方便数据的存储和管理，将数据按照特定的规律存储在磁盘上。通过数据库管理系统，有效地组织和管理存储在数据库中的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库database&lt;/strong&gt;是按照数据结构来组织、存储和管理数据的仓库(通常是一个文件或一组文件)。&lt;/p&gt;
&lt;p&gt;理解数据库的一种最简单的办法就是将其想象为一个文件柜，此文件柜是一个存放数据的物理位置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：有些人通常使用&lt;strong&gt;数据库&lt;/strong&gt;这个术语来代表他们使用的&lt;strong&gt;数据库软件&lt;/strong&gt;，这是不正确的。确切的说，数据库软件应称为&lt;strong&gt;DBMS(数据库管理系统)&lt;/strong&gt;。&lt;strong&gt;数据库&lt;/strong&gt;是通过&lt;strong&gt;DBMS&lt;/strong&gt;创建和操纵的容器。&lt;strong&gt;数据库&lt;/strong&gt;可以是保存在硬件设备上的文件，但也可以不是。对我们来说&lt;strong&gt;数据库&lt;/strong&gt;究竟是文件还是其他什么东西并不重要，因为我们并不直接访问&lt;strong&gt;数据库&lt;/strong&gt;，我们使用的是&lt;strong&gt;DBMS&lt;/strong&gt;，它替我们访问数据库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/mysql6.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;13什么是数据库系统&#34;&gt;1.3、什么是数据库系统&lt;/h3&gt;
&lt;p&gt;数据库系统和数据库不是一个概念，数据库系统(DBS),比数据库大很多，由数据库、 数据库管理系统、应用开发工具构成。&lt;/p&gt;
&lt;h3 id=&#34;14目前数据库分类&#34;&gt;1.4、目前数据库分类&lt;/h3&gt;
&lt;p&gt;而在当今的互联网中，最常见的数据库模型主要是两种，即&lt;strong&gt;关系型数据库&lt;/strong&gt;和&lt;strong&gt;非关系型数据库。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/%E6%95%B0%E6%8D%AE%E5%BA%93.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其他数据库：&lt;/p&gt;
&lt;p&gt;​	层次结构模型&lt;/p&gt;
&lt;p&gt;​	网状结构模型&lt;/p&gt;
&lt;p&gt;​	关系型数据库(以行和列的结构形式，将数据展示，以二维表的形式存储数据)&lt;/p&gt;
&lt;p&gt;​	面向对象数据库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;二关系型数据库&#34;&gt;二、关系型数据库&lt;/h2&gt;
&lt;h3 id=&#34;21关系型数据库的介绍&#34;&gt;2.1、关系型数据库的介绍&lt;/h3&gt;
&lt;p&gt;关系型数据库模型是把复杂的数据结构归结为简单的二元关系(即二维表格形式)。&lt;/p&gt;
&lt;p&gt;在关系型数据库中，对数据的操作几乎全部建立在一个或多个关系表格上，通过对这些关联的表格分类、合并、连接或选取等运算来实现数据库的管理。&lt;/p&gt;
&lt;p&gt;关系型数据库诞生40多年了，从理论产生发展到现实产品，例如：Oracle和MySQL，Oracle在数据库领域上升到霸主地位，形成每年高达数百亿美元的庞大产业市场。MySql数据库在中小企业和免费市场具有绝对地位.&lt;/p&gt;
&lt;h4 id=&#34;211-表&#34;&gt;2.1.1 表&lt;/h4&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;**表(table)**是数据库中存储数据的基本单位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/emp_table.jpeg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;212-列&#34;&gt;2.1.2 列&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;**列(column)**表中的一个字段。所有的表都是由一个或多个列组成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;213-数据类型&#34;&gt;2.1.3 数据类型&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;**数据类型(datatype)**每个列都有相应的数据类型，用来限制该列存储的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;214-行&#34;&gt;2.1.4 行&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;行(row)表中的一个(行)记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;表中的数据是按行存储的，所保存的每个记录存储在自己的行内，如果将表想象为网格，网格中垂直的列为表列，水平行为表行。&lt;/p&gt;
&lt;h4 id=&#34;215-主键&#34;&gt;2.1.5 主键&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;主键(primary key)一列(或一组列)，其值能够唯一区分表中的每一行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;表中每一行都应该有可以唯一标识自己的一列(或一组列)。一个顾客表中可以使用顾客编码列，而订单表可以使用订单ID等。一个表中没有主键的话，更新或删除表中特定行很困难，因为没有安全的方法保证只涉及相关的行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主键的规则&lt;/strong&gt;表中的任何列都可以作为主键，只要它满足一下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;任何两行都不具有相同的主键值(每一行的主键值是唯一的)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个行都必须具有一个主键值(主键不允许null值)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主键的好习惯&lt;/strong&gt;除了强制的规则外，应该坚持的几个普遍认可的好习惯：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不更新主键列中的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不重用主键列的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不在主键列中使用可能会更改的值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三安装和卸载mysql&#34;&gt;三、安装和卸载MySQL&lt;/h2&gt;
&lt;h3 id=&#34;31安装&#34;&gt;3.1安装&lt;/h3&gt;
&lt;p&gt;详见安装文档&lt;/p&gt;
&lt;h3 id=&#34;32卸载&#34;&gt;3.2卸载&lt;/h3&gt;
&lt;p&gt;详见卸载文档&lt;/p&gt;
&lt;p&gt;​	关闭服务：&lt;/p&gt;
&lt;h3 id=&#34;33-配置环境变量&#34;&gt;3.3 配置环境变量&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/01%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png&#34; alt=&#34;01配置环境变量&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;34-登陆&#34;&gt;3.4 登陆&lt;/h3&gt;
&lt;p&gt;A：因为配置了环境变量，可以直接使用命令行终端，输入以下内容：&lt;/p&gt;
&lt;p&gt;mysql -u root -p&lt;/p&gt;
&lt;p&gt;输入密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/02%E7%99%BB%E9%99%86.jpg&#34; alt=&#34;02登陆&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-u：后面跟随用户名&lt;/p&gt;
&lt;p&gt;-p：后面跟随密码&lt;/p&gt;
&lt;p&gt;-h：后面跟随IP&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;B：也可以直接使用mysql命令行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/03%E7%99%BB%E9%99%86.jpg&#34; alt=&#34;03登陆&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;35-启动和停止mysql服务&#34;&gt;3.5 启动和停止mysql服务&lt;/h3&gt;
&lt;p&gt;dos命令行：(需要以管理员的方式运行cmd.exe)&lt;/p&gt;
&lt;p&gt;​	输入：net stop mysql&lt;/p&gt;
&lt;p&gt;​	输入：net start mysql&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/05%E5%81%9C%E6%AD%A2%E5%92%8C%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1.jpg&#34; alt=&#34; 05停止和启动服务&#34;&gt;&lt;/p&gt;
&lt;p&gt;或者通过操作界面：我的电脑-管理-服务-开启和停止mysql服务。&lt;/p&gt;
&lt;h2 id=&#34;四安装navicat&#34;&gt;四、安装Navicat&lt;/h2&gt;
&lt;h3 id=&#34;41-安装并注册&#34;&gt;4.1 安装并注册&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/05%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7.jpg&#34; alt=&#34;05管理工具&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;42-创建连接&#34;&gt;4.2 创建连接&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/04%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7.jpg&#34; alt=&#34;04管理工具&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/06%E4%BD%BF%E7%94%A8navicat.jpg&#34; alt=&#34;06使用navicat&#34;&gt;&lt;/p&gt;
&lt;p&gt;[扩展]数据库的几个名词&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DB：是指datebase(数据库)
	数据库是存储数据的一个集合，数据库中通常使用数据表等组成，而数据表是由数据的字段和数据的值等信息组成。
DBMS:是指datebase mangement systerm(数据库管理系统)
	它是操作数据库和管理数据库的一个系统，比如mysql、sqlserver等都是属于数据库管理软件，人们通过这些系统或者工具来管理数据库内的数据。
DBS:是指datebase systerm (数据库系统)
	数据库系统又数据库和数据库管理软件等组成，数据库是一个逻辑上的存储数据的概念，而对应的是实体是数据库管理软件存储存储在硬盘上的数据库，所以数据库系统包含数据库和数据库管理软件。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;理解数据库：&lt;/p&gt;
&lt;p&gt;我们现在所说的数据库泛指关系型数据库管理系统(RDBMS-Relatitonal database management system)，即数据库服务器。&lt;/p&gt;
&lt;p&gt;当我们安装了数据库服务器后，就可以在数据库服务器中创建数据库，每个数据库中还可以包含多张表。&lt;/p&gt;
&lt;p&gt;数据库表就是一个多行多列的表格。在创建表时，需要制定表的列数，以及列名称，烈性等信息。而不用制定表格的行数，行数是没有上限的。&lt;/p&gt;
&lt;h1 id=&#34;数据库的操作&#34;&gt;数据库的操作&lt;/h1&gt;
&lt;h2 id=&#34;一sql语言&#34;&gt;一、SQL语言&lt;/h2&gt;
&lt;h3 id=&#34;11-什么是sql&#34;&gt;1.1 什么是SQL&lt;/h3&gt;
&lt;p&gt;SQL是结构化查询语言(Structured Query Language)&lt;/p&gt;
&lt;h3 id=&#34;12-sql的作用&#34;&gt;1.2 SQL的作用&lt;/h3&gt;
&lt;p&gt;客户端使用SQL来操作服务器&lt;/p&gt;
&lt;p&gt;​	启动mysql，会连接到服务器后，就可以使用sql来操作服务器了&lt;/p&gt;
&lt;p&gt;​	将来会使用python程序(也可以是其他程序，比如java)链接服务器，然后使用sql来操作服务器&lt;/p&gt;
&lt;h3 id=&#34;13-sql标准&#34;&gt;1.3 SQL标准&lt;/h3&gt;
&lt;p&gt;由国际标准组织(ISO)制定的，对DBMS的统一操作方式(例如相同的语句可以操作：mysql，oracle等)。&lt;/p&gt;
&lt;p&gt;例如SQL99，即1999年制定的标准&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SQL99&lt;/p&gt;
&lt;p&gt;(1)是操作所有关系型数据库的规则
(2)是第四代语言
(3)是一种结构化查询语言
(4)只需发出合法合理的命令，就有对应的结果显示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意，某种DBMS不只会支持SQL标准，而且还会有一些自己独有的语法，比如limit语句只在MySQL中可以使用&lt;/p&gt;
&lt;h3 id=&#34;14-sql的语法&#34;&gt;1.4 SQL的语法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;SQL语句可以在单行或多行书写，以分号结尾&lt;/p&gt;
&lt;p&gt;​	有些时候可以不以分号结尾，比如代码中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以使用空格和缩进来增强语句的可读性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL不区分大小写，建议使用大写&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;15-sql99标准的四大分类-&#34;&gt;1.5 SQL99标准的四大分类 ：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;DDL数据定义语言(data definition language)&lt;/p&gt;
&lt;p&gt;​	create table,alter table，drop table，truncate table 。。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DML数据操作语言(Data Manipulation Language)&lt;/p&gt;
&lt;p&gt;​	insert,update,delete&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DQL数据查询语言(data query language)&lt;/p&gt;
&lt;p&gt;select&lt;/p&gt;
&lt;p&gt;其实DQL也从DML中分离出来的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DCL数据控制语言(Data Control Language)&lt;/p&gt;
&lt;p&gt;​	grant 权限 to scott，revoke 权限 from scott 。。。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DCL(事务控制语言)：commit，rollback，rollback to savepoint 。。。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二-数据库的基本操作&#34;&gt;二、 数据库的基本操作&lt;/h2&gt;
&lt;h3 id=&#34;21-在终端连接mysql数据库&#34;&gt;2.1 在终端连接&lt;code&gt;mysql&lt;/code&gt;数据库&lt;/h3&gt;
&lt;p&gt;在终端输入如下命令:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回车后输入密码.&lt;/p&gt;
&lt;h3 id=&#34;22-查看数据库版本&#34;&gt;2.2 查看数据库版本&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select version();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意:输入命令的时候不要忘记后面的分号&lt;/p&gt;
&lt;h3 id=&#34;23-查看当前时间&#34;&gt;2.3 查看当前时间&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select now();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;24-退出mysql数据库的连接&#34;&gt;2.4 退出&lt;code&gt;mysql&lt;/code&gt;数据库的连接&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;exit&lt;/code&gt;或&lt;code&gt;quit&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;以下操作都是在连接数据库之后才能做的操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意命令结束的时候一定要带分号.&lt;/p&gt;
&lt;h3 id=&#34;25-显示所有的数据库&#34;&gt;2.5 显示所有的数据库&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;show databases;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意: &lt;code&gt;databases&lt;/code&gt;后面有个&lt;code&gt;s&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;26-创建数据库&#34;&gt;2.6 创建数据库&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;create database [if not exists]数据库名 [default charset utf8 collate utf8_general_ci];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以简写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;create database 数据库名 character set utf-8;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库名不要使用中文&lt;/li&gt;
&lt;li&gt;由于数据库中将来会存储一些&lt;code&gt;非ascii&lt;/code&gt;字符, 所以务必指定字符编码, 一般都是指定&lt;code&gt;utf-8&lt;/code&gt;编码&lt;/li&gt;
&lt;li&gt;CHARSET 选择 utf8
COLLATION 选择 utf8_general_ci&lt;/li&gt;
&lt;li&gt;mysql中字符集是utf8，不是utf-8。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;27-切换到要操作的数据库&#34;&gt;2.7 切换到要操作的数据库&lt;/h3&gt;
&lt;p&gt;若要操作数据库中的内容, 需要先切换到要操作的数据库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;use 数据库名;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;28-查看当前选择的数据库&#34;&gt;2.8 查看当前选择的数据库&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select database();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;29-删除数据库&#34;&gt;2.9 删除数据库&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;drop database [if exists]数据库名;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;210-扩展mysql添加用户删除用户与授权&#34;&gt;2.10 [扩展]MySQL添加用户、删除用户与授权&lt;/h3&gt;
&lt;p&gt;DCL数据控制语言(Data Control Language)(了解)&lt;/p&gt;
&lt;p&gt;通常一个项目创建一个用户。一个项目对应的数据库只有一个，这个用户只能对这个数据库有权限，无法对其他数据库进行操作。&lt;/p&gt;
&lt;p&gt;MySql中添加用户,新建数据库,用户授权,删除用户,修改密码(注意每行后边都跟个;表示一个命令语句结束):&lt;/p&gt;
&lt;h4 id=&#34;1创建用户&#34;&gt;1.创建用户&lt;/h4&gt;
&lt;p&gt;A：先使用root账户进行登录&lt;/p&gt;
&lt;p&gt;登录MYSQL：&lt;/p&gt;
&lt;p&gt;@&amp;gt;mysql -u root -p&lt;/p&gt;
&lt;p&gt;@&amp;gt;密码:hanru1314&lt;/p&gt;
&lt;p&gt;B：创建用户：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;CREATE USER &#39;username&#39;@&#39;IP地址&#39; [IDENTIFIED BY &#39;PASSWORD&#39;] 其中密码是可选项；
	用户只能在指定的IP地址上登录
CREATE USER &#39;username&#39;@&#39;%&#39; [IDENTIFIED BY &#39;PASSWORD&#39;] 其中密码是可选项；
	用户可以在任意IP地址上登录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;create user &amp;quot;test&amp;quot;@&amp;quot;localhost&amp;quot; identified by &amp;quot;1234&amp;quot;;&lt;/p&gt;
&lt;p&gt;CREATE USER &#39;john&#39;@&#39;192.168.189.71&#39; IDENTIFIED BY &amp;quot;123&amp;quot;;&lt;/p&gt;
&lt;p&gt;C：然后登录一下：&lt;/p&gt;
&lt;p&gt;mysql&amp;gt;exit;&lt;/p&gt;
&lt;p&gt;@&amp;gt;mysql -u ruby -p&lt;/p&gt;
&lt;p&gt;@&amp;gt;输入密码&lt;/p&gt;
&lt;p&gt;mysql&amp;gt;登录成功&lt;/p&gt;
&lt;h4 id=&#34;2为用户授权&#34;&gt;2.为用户授权&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;授权格式：grant 权限 on 数据库.* to 用户名@登录主机 identified by &amp;quot;密码&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.1 登录MYSQL(有ROOT权限)，这里以ROOT身份登录：&lt;/p&gt;
&lt;p&gt;@&amp;gt;mysql -u root -p&lt;/p&gt;
&lt;p&gt;@&amp;gt;密码&lt;/p&gt;
&lt;p&gt;2.2 首先为用户创建一个数据库(testDB)：&lt;/p&gt;
&lt;p&gt;mysql&amp;gt;CREATE DATABASE&lt;code&gt;testDB&lt;/code&gt;DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;&lt;/p&gt;
&lt;p&gt;2.3 授权test用户拥有testDB数据库的所有权限(某个数据库的所有权限)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;格式：grant 权限 on 数据库.* to 用户名@登录主机 identified by &amp;quot;密码&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;grant all privileges on &lt;em&gt;.&lt;/em&gt; to &#39;root&#39;@&#39;%&#39; identified by &#39;123456&#39;;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt;grant all privileges on testDB.* to test@localhost identified by &#39;1234&#39;;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt;flush privileges;//刷新系统权限表&lt;/p&gt;
&lt;p&gt;2.4 如果想指定部分权限给一用户，可以这样来写:&lt;/p&gt;
&lt;p&gt;mysql&amp;gt;grant select,update on testDB.* to test@localhost identified by &#39;1234&#39;;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt;flush privileges; //刷新系统权限表&lt;/p&gt;
&lt;p&gt;2.5 授权test用户拥有所有数据库的某些权限：&lt;/p&gt;
&lt;p&gt;mysql&amp;gt;grant select,delete,update,create,drop on_._to test@&amp;quot;%&amp;quot; identified by &amp;quot;1234&amp;quot;;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt; //test用户对所有数据库都有select,delete,update,create,drop 权限。

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;//@&amp;quot;%&amp;quot; 表示对所有非本地主机授权，不包括localhost。(localhost地址设为127.0.0.1，如果设为真实的本地地址，不知道是否可以，没有验证。)&lt;/p&gt;
&lt;p&gt;//对localhost授权：加上一句grant all privileges on testDB.* to test@localhost identified by &#39;1234&#39;;即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.撤销权限&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;revoke 权限1，权限2.。。。on 数据库.* from 用户名@IP地址;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;撤销指定用户在指定数据库上的执行权限。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 查看权限&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;show grants for 用户名@IP地址;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5. 删除用户&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@&amp;gt;mysql -u root -p&lt;/p&gt;
&lt;p&gt;@&amp;gt;密码&lt;/p&gt;
&lt;p&gt;删除账户及权限：&amp;gt;drop user 用户名@&#39;%&#39;;&lt;/p&gt;
&lt;p&gt;&amp;gt;drop user 用户名@ localhost;&lt;/p&gt;
&lt;h2 id=&#34;三mysql-数据类型&#34;&gt;三、MySQL 数据类型&lt;/h2&gt;
&lt;p&gt;MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。&lt;/p&gt;
&lt;h3 id=&#34;31-数值类型&#34;&gt;3.1 数值类型&lt;/h3&gt;
&lt;p&gt;MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在上面表中的类型中, 最常用的是2中类型: int(整数)和decimal(浮点数).&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;32-日期和时间类型&#34;&gt;3.2 日期和时间类型&lt;/h3&gt;
&lt;p&gt;表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个&amp;quot;零&amp;quot;值，当指定不合法的MySQL不能表示的值时使用&amp;quot;零&amp;quot;值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最常用: datatime类型.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;33-字符串类型&#34;&gt;3.3 字符串类型&lt;/h3&gt;
&lt;p&gt;字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY和VARBINARY类类似于CHAR和VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB是一个二进制大对象，可以容纳可变数量的数据。有4种BLOB类型：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。它们只是可容纳值的最大长度不同。 有4种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。这些对应4种BLOB类型，有相同的最大长度和存储需求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/%E5%AD%97%E7%AC%A6%E4%B8%B2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最常用的: char, varchar和text类型.&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总结常用的类型：&lt;/p&gt;
&lt;p&gt;int：整型&lt;/p&gt;
&lt;p&gt;double：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值：999.99&lt;/p&gt;
&lt;p&gt;decimal：浮点型，不会出现精度缺失问题，比如金钱。&lt;/p&gt;
&lt;p&gt;char：固定长度字符串类型：最大长度：char(255)&lt;/p&gt;
&lt;p&gt;varchar：可变长度字符串类型：最大长度：varchar(65535)&lt;/p&gt;
&lt;p&gt;text(clob)：字符串类型，存储超大文本。&lt;/p&gt;
&lt;p&gt;blob：字节类型，最大4G&lt;/p&gt;
&lt;p&gt;date：日期类型，格式为：yyyy-MM-dd&lt;/p&gt;
&lt;p&gt;time：时间类型：格式为：hh:mm:ss&lt;/p&gt;
&lt;p&gt;timestamp：时间戳&lt;/p&gt;
&lt;p&gt;datatime&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;四表的基本操作&#34;&gt;四、表的基本操作&lt;/h2&gt;
&lt;p&gt;MySQL不仅用于表数据操纵，而且还可以用来执行数据库和表的所有操作，包括表本身的创建和处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库中存储的是表(table), 表中存储的是一行行的数据.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;41-查看当前数据库中的所有表&#34;&gt;4.1 查看当前数据库中的所有表&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;show tables;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意: &lt;code&gt;tables&lt;/code&gt;后面有个&lt;code&gt;s&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;42-创建表&#34;&gt;4.2 创建表&lt;/h3&gt;
&lt;p&gt;通用语法：**CREATE TABLE table_**&lt;strong&gt;name (column_name column_type);&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;
CREATE TABLE [IF NOT EXISTS] 表名(
	列名 列类型(长度) 约束 默认值,
  	列名 列类型(长度) 约束 默认值,
  	...
); 

例如:
create table student(id int auto_increament primary key, name varchar(16) not null, age int, sex char(1));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里，一些数据项需要解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字段使用NOT NULL，是因为我们不希望这个字段的值为NULL。 因此，如果用户将尝试创建具有NULL值的记录，那么MySQL会产生错误。&lt;/li&gt;
&lt;li&gt;字段的AUTO_INCREMENT属性告诉MySQL自动增加id字段下一个可用编号。&lt;/li&gt;
&lt;li&gt;DEFAULT 设置默认值。&lt;/li&gt;
&lt;li&gt;关键字PRIMARY KEY用于定义此列作为主键。可以使用逗号分隔多个列来定义主键。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;练习：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;create table test_table( test_id INT NOT NULL AUTO_INCREMENT, test_title VARCHAR(100) NOT NULL, test_author VARCHAR(40) NOT NULL DEFAULT &#39;larry&#39;, test_date DATE, PRIMARY KEY ( test_id ) );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/07%E5%BB%BA%E8%A1%A8.jpg&#34; alt=&#34;07建表&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;43-查看表结构&#34;&gt;4.3 查看表结构&lt;/h3&gt;
&lt;p&gt;通用语法：&lt;strong&gt;desc 表名;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;describe tableName&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;desc 表名;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;44-查看表的创建语句&#34;&gt;4.4 查看表的创建语句&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;show create table 表名;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;45-修改表&#34;&gt;4.5 修改表&lt;/h3&gt;
&lt;p&gt;通用语法：&lt;strong&gt;ALTER TALBE 表名....&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.添加字段&lt;/strong&gt; :add&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table 表名 add(
	列名 列类型,
  	列名 列类型,
  	...
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;修改表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.修改列类型&lt;/strong&gt;:modify&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table 表名 modify 
	列名 列类型;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：如果被修改的列已经存在数据，那么新的类型可能会影响到已存在的数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.修改列名&lt;/strong&gt;:change&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table 表名 change 
	原列名 新列名 列类型;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.删除列&lt;/strong&gt;:drop&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table 表名 drop 
	列名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.更改表的名称&lt;/strong&gt;:rename to&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;rename table 原表名 to 新表名;
alter table 原表名 rename to 新表名;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;46-删除表&#34;&gt;4.6 删除表&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;drop table [if exists] 表名;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;47-扩展复制表中的数据仅复制数据不复制表的结构&#34;&gt;4.7 [扩展]复制表中的数据(仅复制数据不复制表的结构)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;create table 表名2 as select * from 表名1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;五操纵表中的数据&#34;&gt;五、操纵表中的数据&lt;/h2&gt;
&lt;p&gt;对于数据表进行增伤改查(也叫CRUD)。&lt;/p&gt;
&lt;p&gt;DML语言：增删改&lt;/p&gt;
&lt;p&gt;DQL语言：查&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;crud是指在做计算处理时的增加(Create)、读取查询(Retrieve)、更新(Update)和删除(Delete)几个单词的首字母简写。crud主要被用在描述软件系统中数据库或者持久层的基本操作功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;51-查询数据&#34;&gt;5.1 查询数据&lt;/h3&gt;
&lt;p&gt;查询数据的操作是最复杂, 后面专门细讲.
今天只使用最简单的.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select * from 表名;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;52-添加数据&#34;&gt;5.2 添加数据&lt;/h3&gt;
&lt;p&gt;增加数据的方式有多种:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：在数据库中所有的字符串类型，必须使用单引，不能使用双引。日期类型也要使用单引。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;521-全列插入&#34;&gt;5.2.1 全列插入&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;insert into 表名 values(值1, 值2,...);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全列插入的时候需要每一列的数据都要添加上去.&lt;/li&gt;
&lt;li&gt;对自动增长的数据, 在全列插入的时候需要占位处理, 一般使用0来占位.但是最终的值以实际为准.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;522-缺省插入&#34;&gt;5.2.2 缺省插入&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;insert into 表名(列1, 列2, ...) values(值1, 值2, ...);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入的时候,&lt;code&gt;not null&lt;/code&gt;和&lt;code&gt;primary key&lt;/code&gt;的列必须赋值, 其他的列根据情况来赋值.如果没有赋值则会使用默认值.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;523-同时插入多条数据&#34;&gt;5.2.3 同时插入多条数据&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;insert into 表名 values(值1, 值2,...), (值1, 值2,...),...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;insert into 表名(列1, 列2, ...) values(值1, 值2, ...), (值1, 值2, ...), ...;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;53-修改数据更新数据&#34;&gt;5.3 修改数据(更新数据)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;update 表名 set 列1=值1,列2=值2,... [where 条件]
例如: 
update stus set sex=&#39;男&#39;,age=100 where sex is null;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;条件(条件是可选的)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;条件必须是boolean类型的值或者表达式&lt;/li&gt;
&lt;li&gt;运算符：=,!=,&amp;lt;&amp;gt;,&amp;gt;,&amp;lt;,&amp;gt;=,&amp;lt;=,between..and, in(...),or ,and ,not, is null，is not null&lt;/li&gt;
&lt;li&gt;is null 不是 = null(永远是false)&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;54-删除数据&#34;&gt;5.4 删除数据&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;delete from 表名 [where 条件]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;六约束constraint&#34;&gt;六、约束(constraint)&lt;/h2&gt;
&lt;p&gt;当创建数据表的时候，为某一个字段设置约束，表示限定该列的数值内容。也可以通过修改表结构添加约束&lt;/p&gt;
&lt;h3 id=&#34;61-默认值default&#34;&gt;6.1 默认值：default&lt;/h3&gt;
&lt;h3 id=&#34;62-非空约束not-null&#34;&gt;6.2 非空约束：not null&lt;/h3&gt;
&lt;p&gt;如果某个字段添加了非空约束，那么该字段的数值不能为null，对于mysql而言，表示什么都没有，未知的。不是0，也不是空&amp;quot;&amp;quot;，更不是&amp;quot;NULL&amp;quot;。&lt;/p&gt;
&lt;p&gt;NUll&lt;/p&gt;
&lt;p&gt;​	0,&amp;quot;&amp;quot;,&amp;quot;NULL&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;create table stu (
	sid int ,  
	sname varchar(20) not null, # 定义sname字段值不能为空
	age int,
	gender varchar(10)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除非空约束：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table stu modify sname varchar(20);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加非空约束：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table stu modify sname  varchar(20) not null;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;该列已有的数据不能有null数值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;63-唯一性约束unique&#34;&gt;6.3 唯一性约束：unique&lt;/h3&gt;
&lt;p&gt;唯一性约束强调所在的字段所有的数值都是唯一的。不允许重复。允许空值(多个)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;create table stu (
	sid int primary key auto_increment,  
	sname varchar(20) unique, # 定义sname字段值必须唯一
	age int,
	gender varchar(10)
);
或者,使用constraint 约束名 unique 字段。
create table stu (
	sid int auto_increment,
	sname varchar(20),
	age int,
	gender varchar(10),
  	[constraint ] unique (sname)  # 指明name字段唯一
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除唯一约束：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table stu modify sname varchar(20);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加唯一约束：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table stu modify sname  varchar(20) not null;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;该列已有的数据不能有null数值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为已有的字段设置约束
alter table 表名 modify 字段 约束&lt;/p&gt;
&lt;p&gt;添加新的字段，带约束&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table 表名 add 字段 数据类型 约束
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先将已有的字段删除，重新添加带约束的。
alter table 表名 drop column 列名
alter table 表名 add 列名 数据类型 约束&lt;/p&gt;
&lt;h3 id=&#34;64-主键约束primary-key&#34;&gt;6.4 主键约束：primary key。&lt;/h3&gt;
&lt;p&gt;主键约束：要求该字段数值不允许空，而且数值唯一。(not null+unique)&lt;/p&gt;
&lt;p&gt;主键约束用于唯一的标识表中的每一个行记录的。一个表中最多只能有一个主键约束。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;create table stu (
  sid int primary key auto_increment,  # 定义sid作为stu表的主键
  sname varchar(20),
  age int,
  gender varchar(10)
);
或者,使用constraint 约束名 primary key 字段。
create table stu (
  sid int auto_increment,
  sname varchar(20),
  age int,
  gender varchar(10),
	[constraint [sid_pk]] primary key (sid)  # 指明sid作为stu表的主键
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除主键：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table stu drop primary key;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加主键：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table teachers add primary key(id);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;主键自增：&lt;/strong&gt; auto_increment&lt;/p&gt;
&lt;p&gt;要求该字段数值不允许空，而且数值唯一。所以我们通常会指定主键类型为整型，然后设置其自动增长，这样可以保证在插入数据时主键列的唯一和非空特性。&lt;/p&gt;
&lt;p&gt;修改表时设置主键自动增长：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table stu modify sid  int auto_increment;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改表时删除主键自动增长：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table stu modify sid  int;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;65-外键约束foreign-key&#34;&gt;6.5 外键约束：foreign key，&lt;/h3&gt;
&lt;h4 id=&#34;651外键&#34;&gt;6.5.1外键&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;思考：怎么保证关系列数据的有效性呢？任何整数都可以吗？比如一个班级表中有班级编号，班级名称，班级位置。还有一个学生表，有学生编号，学生姓名，学生 性别，以及班级编号等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;答：必须是学生表中班级编号列存在的数据，可以通过外键约束进行数据的有效性验证&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;外键作用数据完整性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;班级表可以叫做父表(主表)：class，字段classno，该表的主键&lt;/p&gt;
&lt;p&gt;学生表可以叫做子表(从表)：student，字段sid是该表的主键，classno是该表的外键&lt;/p&gt;
&lt;p&gt;父表：department，字段deptno，该表的主键
子表：employee，字段empno，该表的主键，deptno，该表的外键&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子表的外键是父表的主键。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当对于子表插入数据，外键字段的数值不能随便插入，而取决于父表的主键数值。&lt;/li&gt;
&lt;li&gt;对于父表的删除操作，要看子表中是否有记录引用该数值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;652-外键的设置&#34;&gt;6.5.2 外键的设置&lt;/h4&gt;
&lt;p&gt;方法一：在创建子表的时候，直接标明外键。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;设置外键语法：
  references 父表(主键);
  constraint classno_FK  foreign key (classno) references class(classno);

创建数据表
create table scores(
	sid int(4) primary key auto_increment,
	sname varchar(20),
	sage int(3),
	classno int(4),
	constraint stu_classno foreign key(classno) references class(classno) on delete cascade,
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法二：使用alter语句今天添加外键&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mymysql&#34;&gt;alter table student add constraint stu_classno foreign key(classno) references class(classno);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table student add constraint stu_classno foreign key(classno) references class(classno) on delete cascade;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;此时插入或者修改数据时，如果classno的值在student表中不存在则会报错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;删除外键：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;alter table student drop foreign key stu_classno;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;653外键的级联操作&#34;&gt;6.5.3外键的级联操作&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在删除class表的数据时，如果这个classno值在student中已经存在，则会抛异常&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推荐使用逻辑删除，还可以解决这个问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以创建表时指定级联操作，也可以在创建表后再修改外键的级联操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;  语法：

  on delete cascade,删除父表的时候，子表的数据直接删除，级联删除

  on delete set null，删除父表的时候，子表的数据置null。
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;级联操作的类型包括：
&lt;ul&gt;
&lt;li&gt;restrict(限制)：默认值，抛异常&lt;/li&gt;
&lt;li&gt;cascade(级联)：如果主表的记录删掉，则从表中相关联的记录都将被删除&lt;/li&gt;
&lt;li&gt;set null：将外键设置为空&lt;/li&gt;
&lt;li&gt;no action：什么都不做&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/mysql/">mysql</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/db/">db</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/mysql/">mysql</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>数组(Array)</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day06_%E6%95%B0%E7%BB%84/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day06_%E6%95%B0%E7%BB%84/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;一数组array&#34;&gt;一、数组(Array)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;11-什么是数组&#34;&gt;1.1 什么是数组&lt;/h2&gt;
&lt;p&gt;Go 语言提供了数组类型的数据结构。
数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。&lt;/p&gt;
&lt;p&gt;数组元素可以通过索引（位置）来读取（或者修改），索引从0开始，第一个元素索引为 0，第二个索引为 1，以此类推。数组的下标取值范围是从0开始，到长度减1。&lt;/p&gt;
&lt;p&gt;数组一旦定义后，大小不能更改。&lt;/p&gt;
&lt;h2 id=&#34;12-数组的语法&#34;&gt;1.2 数组的语法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;声明和初始化数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要指明数组的大小和存储的数据类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var variable_name [SIZE] variable_type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var balance [10] float32
var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初始化数组中 {} 中的元素个数不能大于 [] 中的数字。
如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var balance = []float32{1000.0, 2.0, 3.4, 7.0, 50.0}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;balance[4] = 50.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组的其他创建方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  var a [4] float32 // 等价于：var arr2 = [4]float32{}
  fmt.Println(a) // [0 0 0 0]
  var b = [5] string{&amp;quot;ruby&amp;quot;, &amp;quot;王二狗&amp;quot;, &amp;quot;rose&amp;quot;}
  fmt.Println(b) // [ruby 王二狗 rose  ]
  var c = [5] int{&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;} // byte
  fmt.Println(c) // [65 66 67 68 69]
  d := [...] int{1,2,3,4,5}// 根据元素的个数，设置数组的大小
  fmt.Println(d)//[1 2 3 4 5]
  e := [5] int{4: 100} // [0 0 0 0 100]
  fmt.Println(e)
  f := [...] int{0: 1, 4: 1, 9: 1} // [1 0 0 0 1 0 0 0 0 1]
  fmt.Println(f)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;访问数组元素&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;float32 salary = balance[9]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   var n [10]int /* n 是一个长度为 10 的数组 */
   var i,j int

   /* 为数组 n 初始化元素 */         
   for i = 0; i &amp;lt; 10; i++ {
      n[i] = i + 100 /* 设置元素为 i + 100 */
   }

   /* 输出每个数组元素的值 */
   for j = 0; j &amp;lt; 10; j++ {
      fmt.Printf(&amp;quot;Element[%d] = %d\n&amp;quot;, j, n[j] )
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Element[0] = 100
Element[1] = 101
Element[2] = 102
Element[3] = 103
Element[4] = 104
Element[5] = 105
Element[6] = 106
Element[7] = 107
Element[8] = 108
Element[9] = 109
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;数组的长度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过将数组作为参数传递给len函数，可以获得数组的长度。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    a := [...]float64{67.7, 89.8, 21, 78}
    fmt.Println(&amp;quot;length of a is&amp;quot;,len(a))

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;length of a is 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;您甚至可以忽略声明中数组的长度并将其替换为…让编译器为你找到长度。这是在下面的程序中完成的。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    a := [...]int{12, 78, 50} // ... makes the compiler determine the length
    fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历数组：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    a := [...]float64{67.7, 89.8, 21, 78}
    for i := 0; i &amp;lt; len(a); i++ { //looping from 0 to the length of the array
        fmt.Printf(&amp;quot;%d th element of a is %.2f\n&amp;quot;, i, a[i])
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用range遍历数组：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    a := [...]float64{67.7, 89.8, 21, 78}
    sum := float64(0)
    for i, v := range a {//range returns both the index and value
        fmt.Printf(&amp;quot;%d the element of a is %.2f\n&amp;quot;, i, v)
        sum += v
    }
    fmt.Println(&amp;quot;\nsum of all elements of a&amp;quot;,sum)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果您只需要值并希望忽略索引，那么可以通过使用_ blank标识符替换索引来实现这一点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for _, v := range a { //ignores index  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13-多维数组&#34;&gt;1.3 多维数组&lt;/h2&gt;
&lt;p&gt;Go 语言支持多维数组，以下为常用的多维数组声明语法方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var threedim [5][10][4]int
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三维数组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = [3][4]int{  
 {0, 1, 2, 3} ,   /*  第一行索引为 0 */
 {4, 5, 6, 7} ,   /*  第二行索引为 1 */
 {8, 9, 10, 11}   /*  第三行索引为 2 */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;14-数组是值类型&#34;&gt;1.4 数组是值类型&lt;/h2&gt;
&lt;p&gt;数组是值类型
Go中的数组是值类型，而不是引用类型。这意味着当它们被分配给一个新变量时，将把原始数组的副本分配给新变量。如果对新变量进行了更改，则不会在原始数组中反映。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    a := [...]string{&amp;quot;USA&amp;quot;, &amp;quot;China&amp;quot;, &amp;quot;India&amp;quot;, &amp;quot;Germany&amp;quot;, &amp;quot;France&amp;quot;}
    b := a // a copy of a is assigned to b
    b[0] = &amp;quot;Singapore&amp;quot;
    fmt.Println(&amp;quot;a is &amp;quot;, a)
    fmt.Println(&amp;quot;b is &amp;quot;, b) 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a is [USA China India Germany France]  
b is [Singapore China India Germany France] 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组的大小是类型的一部分。因此[5]int和[25]int是不同的类型。因此，数组不能被调整大小。不要担心这个限制，因为切片的存在是为了解决这个问题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

func main() {  
    a := [3]int{5, 78, 8}
    var b [5]int
    b = a //not possible since [3]int and [5]int are distinct types
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>微服务管理（上）</title>
                <link>http://www.songx.fun/blog/day78-79%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/day78_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B8%8A/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day78-79%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/day78_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B8%8A/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;微服务管理上&#34;&gt;微服务管理（上）&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一微服务管理--服务发现&#34;&gt;一、微服务管理--服务发现&lt;/h2&gt;
&lt;p&gt;在微服务简介篇，我们已经介绍过微服务架构中要解决的四个基本的问题。从本节课开始我们来学习如何实现服务的管理。&lt;/p&gt;
&lt;h3 id=&#34;11为什么要使用服务发现&#34;&gt;1.1、为什么要使用服务发现&lt;/h3&gt;
&lt;p&gt;设想下，我们写了一些通过REST API或者Thrift API调用某个服务的代码，为了发起这个请求，代码需要知道服务实例的网络地址(IP 地址和端口号）。在传统运行在物理机器上的应用中，某个服务实例的网络地址一般是静态的，比如，代码可以从只会偶尔更新的配置文件中读取网络地址。&lt;/p&gt;
&lt;p&gt;然而在现在流行的基于云平台的微服务应用中， 有更多如下图所示的困难问题需要去解决：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190609-150311@2x.png&#34; alt=&#34;微服务架构部署模式&#34;&gt;&lt;/p&gt;
&lt;p&gt;服务实例需要动态分配网络地址，而且，一组服务实例可能会因为自动扩展、失败或者升级发生动态变化，因此客户端代码应该使用更加精细的服务发现机制。&lt;/p&gt;
&lt;p&gt;在生产实践中，主要有两种服务发现机制：&lt;strong&gt;客户端发现&lt;/strong&gt;和&lt;strong&gt;服务端发现&lt;/strong&gt;。我们分别来介绍这两种机制：&lt;/p&gt;
&lt;h3 id=&#34;12客户端发现模式&#34;&gt;1.2、客户端发现模式&lt;/h3&gt;
&lt;p&gt;当我们使用客户端发现的时候，客户端负责决定可用服务实例的网络地址并且在集群中对请求负载均衡, 客户端访问&lt;strong&gt;服务登记表&lt;/strong&gt;，也就是一个可用服务的数据库，然后客户端使用一种负载均衡算法选择一个可用的服务实例然后发起请求。该模式如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190609-150816@2x.png&#34; alt=&#34;客户端发现模式&#34;&gt;&lt;/p&gt;
&lt;p&gt;该模式和我们之前在微服务简介章节介绍的服务发现机制中的客户端机制是一样的，如图所示：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190530-173138@2x.png&#34; alt=&#34;基于客户端的服务注册与发现&#34;&gt;&lt;/p&gt;
&lt;p&gt;服务实例的网络地址在服务启动的时候被登记到服务注册表中 ，当实例终止服务时从服务注册表中移除。服务实例的注册一般是通过&lt;strong&gt;心跳机制&lt;/strong&gt;阶段性的进行刷新。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;客户端发现机制的优势：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该模式中只增加了服务注册表，整体架构也相对简单；&lt;/li&gt;
&lt;li&gt;客户端可以使用更加智能的，特定于应用的负载均衡机制，如一致性哈希。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;客户端发现机制的缺点：&lt;/strong&gt; 客户端发发现机制中，客户端与服务注册表紧密耦合在一起，开发者必须为每一种消费服务的客户端对应的编程语言和框架版本都实现服务发现逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**客户端发现模式的应用：**往往大公司会采用客户端发现机制来实现服务的发现与注册的模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13服务端发现模式&#34;&gt;1.3、服务端发现模式&lt;/h3&gt;
&lt;p&gt;与客户端发现模式对应的，另外一种服务发现模式称之为服务端发现模式，整体架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190609-153629@2x.png&#34; alt=&#34;服务端发现模式&#34;&gt;&lt;/p&gt;
&lt;p&gt;在该种模式下，客户端通过一个负载均衡器向服务发送请求，负载均衡器查询服务注册表并把请求路由到一台可用的服务实例上。和客户端发现一样，服务实例通过服务注册表进行服务的注册和注销。&lt;/p&gt;
&lt;p&gt;同样的，服务端发下模式也有优势和缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;服务端发现模式的优点：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;服务发现的细节对客户端来说是抽象的，客户端仅需向负载均衡器发送请求即可。&lt;/li&gt;
&lt;li&gt;这种方式减少了为消费服务的不同编程语言与框架实现服务发现逻辑的麻烦。很多部署环境已经提供了该功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务端发现模式的缺点：&lt;/strong&gt; 除非部署环境已经提供了负载均衡器，否则这又是一个需要额外设置和管理的可高可用的系统组件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14服务注册表&#34;&gt;1.4、服务注册表&lt;/h3&gt;
&lt;p&gt;服务注册表是服务发现的关键部分，它是一个包含服务实例网络地址的的数据库。一个服务注册表需要高可用和实时更新，客户端可以缓存从服务注册表获取的网络地址。然而，这样的话缓存的信息最终会过期，客户端不能再根据该信息发现服务实例。因此，服务注册表对集群中的服务实例使用复制协议来维护一致性。&lt;/p&gt;
&lt;p&gt;举个例子：Netflix Eureka是典型的服务注册表的案例实现，它为服务实例的注册与查询提供了REST API：&lt;strong&gt;一个服务实例可以使用POST来注册自己的网络地址，它必须每30秒通过PUT去刷新，服务实例可以直接或者在服务实例注册超时的时候使用DELETE删除注册表中的信息，另外客户端可以使用HTTP GET获取注册实例的信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，除了Netflix Eureka以外，还有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**etcd：**一个高可用、分布式、一致性、key-value方式的存储，被用在分享配置和服务发现中。两个著名的项目使用了它：Kubernetes和Cloud Foundry。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**consul：**一个发现和配置服务的工具，为客户端注册和发现服务提供了API，Consul还可以通过执行健康检查决定服务的可用性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**Apache Zookeeper：**Zookeeper是一个广泛使用、高性能的针对分布式应用的协调服务。 Apache Zookeeper本来是Hadoop的子工程，现在已经是顶级工程了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;15服务注册方式&#34;&gt;1.5、服务注册方式&lt;/h3&gt;
&lt;p&gt;服务实例必须使用服务注册表来进行服务的注册和注销，在实践过程中有不同的方式来实现服务的注册和注销：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**self-registration模式：**这种模式下，服务实例自己负责通过服务注册表对自己进行注册和注销，另外如何有必要的话，服务实例可以通过发送心跳包请求防止注册过期。该种模式的架构实现如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190609-163437@2x.png&#34; alt=&#34;服务注册方式&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;self-registration&lt;/strong&gt;模式有一些优势也有一些劣势：优势之一是它相对简单，而且不强制使用其他的系统组件。然而，一个很大的劣势是 它使得服务实例和服务注册表强耦合 ，你必须在每一个使用服务的客户端编程语言和架构代码中实现注册逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**third-party registration模式：**当使用third-party registration模式的时候，服务实例本身并不负责通过服务注册表注册自己，相反的，通过另一个被称作service registrar系统组件来处理注册。service registrar通过轮询或者订阅事件来检测一些运行实例的变化，当它检测到一个新的可用服务实例时就把该实例注册到服务注册表中去，service registrar还负责注销已经被终止的服务实例，下图展示了该模式的架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190609-163819@2x.png&#34; alt=&#34;third-party registration&#34;&gt;&lt;/p&gt;
&lt;p&gt;third-party registration模式也有一些优势和劣势：主要优势是使得服务从服务注册表中被解耦，你不必为开发者使用的每种开发语言和框架实现服务注册的逻辑，相反，服务实例的注册被一个专有服务以集中式的方式处理。该模式的劣势是，除非它被内置在部署环境中，不然这又是一个需要被设置和管理的高可用系统组件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;16总结&#34;&gt;1.6、总结&lt;/h3&gt;
&lt;p&gt;在一个微服务应用中，一组运行的服务实例是动态变化的，实例有动态分配的网络地址，因此，为了使得客户端能够向服务发起请求，必须要要有服务发现机制。&lt;/p&gt;
&lt;p&gt;服务发现的关键是服务注册表，服务注册表是可用服务实例的数据库，它提供了管理和查询使用的API。服务实例使用这些管理API进行服务的注册和注销，系统组件使用查询API来发现可用的服务实例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发现的案例：Eureka、ZooKeeper&lt;/li&gt;
&lt;li&gt;服务端发现的案例：consul+nigix&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们选择Consul来进行学习。&lt;/p&gt;
&lt;h3 id=&#34;17consul&#34;&gt;1.7、Consul&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Consul概述&lt;/strong&gt;
consul是google开源的一个使用go语言开发的服务发现、配置管理中心服务，consul属于微服务架构的基础设置中用于发现和配置服务的一个工具。Consul提供如下的几个核心功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**服务发现：**Consul的某些客户端可以提供一个服务，其他客户端可以使用Consul去发现这个服务的提供者。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**健康检查：**Consul客户端可以提供一些健康检查，这些健康检查可以关联到一个指定的服务，比如心跳包的检测。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**键值存储：**应用实例可以使用Consul提供的分层键值存储，比如动态配置，特征标记，协作等。通过HTTP API的方式进行获取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**多数据中心：**Consul对多数据中心有非常好的支持。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;官方网站：&lt;/strong&gt;
可以访问&lt;a href=&#34;https://www.consul.io/&#34;&gt;https://www.consul.io/&lt;/a&gt;查看Consul的相关介绍，获取相关资料。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安装：&lt;/strong&gt;
在官方文档中，点击Download按钮，进入下载软件界面&lt;a href=&#34;https://www.consul.io/downloads.html&#34;&gt;https://www.consul.io/downloads.html&lt;/a&gt;，选择自己本机系统的类型，如下图所示：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190610-100150@2x.png&#34; alt=&#34;下载Consul&#34;&gt;&lt;/p&gt;
&lt;p&gt;Consul最新版本是v1.5.1版本。&lt;/p&gt;
&lt;h2 id=&#34;二微服务管理--分布式与单点故障&#34;&gt;二、微服务管理--分布式与单点故障&lt;/h2&gt;
&lt;p&gt;上节课我们提到了服务的注册于发现机制，可以引入一个服务注册发现组件来实现对服务的管理，完成服务注册，信息查询，存储配置等功能。虽然引入了服务注册发现组件解决了就问题，但是会引入新问题。&lt;/p&gt;
&lt;h3 id=&#34;21consul环境配置&#34;&gt;2.1、Consul环境配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、将下载的consul_1.5.1_darwin_amd64.zip进行解压，解压后得到可执行文件consul。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、将consul可执行文件拷贝到电脑本地的环境变量中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unix系统中：可以拷贝到**~/bin&lt;strong&gt;或&lt;/strong&gt;/usr/local/bin**目录下，这两个目录是常见的安装目录。&lt;/li&gt;
&lt;li&gt;Windows系统：可以将consul安装到**%PATH%**所对应的目录路径中。
以macOS系统为例，属于unix系统，将consul拷贝到/usr/local/bin目录下，如图所示：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190611-114040@2x.png&#34; alt=&#34;Consul环境配置&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、测试配置成功
完成consul的环境配置后，即表示已经将consul完成了安装。可以通过在命令行中运行consul指令验证是否安装成功。打开命令行工具，输入如下指令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;consul
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190611-114521@2x.png&#34; alt=&#34;consul指令&#34;&gt;
在终端中输入&lt;strong&gt;consul&lt;/strong&gt;指令，出现如上指令用法及参数提示，即表示consul安装成功。
如果得到的是**-bash: consul: command not found&lt;strong&gt;的错误，则表示&lt;/strong&gt;path**没有正确设置，需要重新检查consul可执行文件所在路径是否添加到了环境变量PATH中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22主从模式分布式系统&#34;&gt;2.2、主从模式分布式系统&lt;/h3&gt;
&lt;p&gt;分布式系统中，一遍采用主从模式进行部署，如下图所示：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190613-142516@2x.png&#34; alt=&#34;主从模式分布式系统&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;23单点故障&#34;&gt;2.3、单点故障&lt;/h3&gt;
&lt;p&gt;通常分布式系统采用主从模式，就是一个主控机连接多个处理节点。主节点负责分发任务，从节点负责处理任务，当我们的主节点发生故障时，整个系统就瘫痪了。这就是单点故障。&lt;/p&gt;
&lt;p&gt;单点故障（single point of failure），从英文字面上可以看到是单个点发生的故障，通常应用于计算机系统及网络。实际指的是单个点发生故障的时候会波及到整个系统或者网络，从而导致整个系统或者网络的瘫痪。这也是在设计IT基础设施时应避免的。&lt;/p&gt;
&lt;p&gt;对应到上文，我们所说的服务注册与发现组件，如果我们引入的服务注册与发现组件出现了问题，则会导致系统乃至整个链路瘫痪，这是不可容忍的。需要采用新的方案解决此问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190613-145130@2x.png&#34; alt=&#34;单点故障&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;24传统解决方案&#34;&gt;2.4、传统解决方案&lt;/h3&gt;
&lt;p&gt;传统的解决方案是采用一个备用节点，这个备用节点定期给当前主节点发送ping包，主节点收到ping包以后向备用节点发送回复ACK,当备用节点收到回复时就会认为当前主节点还活着，让他继续提供服务。
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190613-144656@2x.png&#34; alt=&#34;备用主节点&#34;&gt;&lt;/p&gt;
&lt;p&gt;当主节点停止服务以后，这个时候备用节点收不到回复了，备用主节点认为主节点就宕机了，备用节点会代替主节点成为主节点，如下图：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190613-151156@2x.png&#34; alt=&#34;备用节点成为主节点&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是这种方案有个问题，如果仅仅是网络故障引起的ACK返回延时，这种方案就会面临着同时存在两个主节点的问题。&lt;/p&gt;
&lt;h3 id=&#34;25consul中的raft&#34;&gt;2.5、Consul中的Raft&lt;/h3&gt;
&lt;p&gt;Raft是一种基于Paxos的一致性算法。和Paxos相比，Raft的状态更少，算法更简单易懂。&lt;/p&gt;
&lt;p&gt;Raft中的节点总是处于以下三种状态之一: follower、candidate或leader。所有的节点最初都是follower。在这种状态下，节点可以接受来自leader的日志条目并进行投票。如果在一段时间内没有收到条目，节点将自动提升到候选状态。在候选状态中，节点请求同级的选票。如果一个候选人获得了法定人数的选票，那么他就被提升为领袖。领导者必须接受新的日志条目，并将其复制给所有其他的追随者。此外，如果不能接受过时的读取，则还必须对leader执行所有查询。&lt;/p&gt;
&lt;h3 id=&#34;26consul内部原理&#34;&gt;2.6、Consul内部原理&lt;/h3&gt;
&lt;p&gt;我们可以通过如下的原理图来理解Consul的原理：
&lt;img src=&#34;http://www.songx.fun/img/png/consul.png&#34; alt=&#34;consul的构造原理图&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先Consul支持多数据中心，在上图中有两个DataCenter，他们通过Internet互联，同时请注意为了提高通信效率，只有Server节点才加入跨数据中心的通信。&lt;/p&gt;
&lt;p&gt;在单个数据中心中，Consul分为Client和Server两种节点（所有的节点也被称为Agent），Server节点保存数据，Client负责健康检查及转发数据请求到Server。&lt;/p&gt;
&lt;p&gt;Server节点有一个Leader和多个Follower，Leader节点会将数据同步到Follower，Server的数量推荐是3个或者 5个，在Leader挂掉的时候会启动选举机制产生一个新的 Leader。&lt;/p&gt;
&lt;p&gt;集群内的Consul节点通过gossip协议（流言协议）维护成员关系，也就是说某个节点了解集群内现在还有哪些节点，这些节点是Client还是Server。&lt;/p&gt;
&lt;p&gt;单个数据中心的流言协议同时使用TCP和UDP通信，并且都使用8301端口。跨数据中心的流言协议也同时使用TCP和UDP 通信，端口使用8302。&lt;/p&gt;
&lt;p&gt;集群内数据的读写请求既可以直接发到Server，也可以通过Client使用RPC转发到Server，请求最终会到达Leader节点。&lt;/p&gt;
&lt;p&gt;在允许数据轻微陈旧的情况下，读请求也可以在普通的Server节点完成，集群内数据的读写和复制都是通过TCP的8300端口完成。&lt;/p&gt;
&lt;h2 id=&#34;三微服务管理--consul服务发现原理&#34;&gt;三、微服务管理--Consul服务发现原理&lt;/h2&gt;
&lt;h3 id=&#34;31consul服务发现原理&#34;&gt;3.1、Consul服务发现原理&lt;/h3&gt;
&lt;p&gt;使用以下案例进行Consul服务发现原理的讲解，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190613-173518@2x.png&#34; alt=&#34;Consul服务发现原理&#34;&gt;&lt;/p&gt;
&lt;p&gt;1、**部署集群。**首先需要有一个正常的Consul集群，有Server，有Leader。这里在服务器Server1、Server2、Server3上分别部署了Consul Server。&lt;/p&gt;
&lt;p&gt;2、**选举Leader节点。**假设他们选举了Server2上的 Consul Server 节点为Leader。这些服务器上最好只部署Consul程序，以尽量维护Consul Server的稳定。&lt;/p&gt;
&lt;p&gt;3、**注册服务。**然后在服务器Server4和Server5上通过Consul Client分别注册Service A、B、C，这里每个Service 分别部署在了两个服务器上，这样可以避免Service的单点问题。服务注册到Consul可以通过 HTTP API（8500 端口）的方式，也可以通过 Consul 配置文件的方式。&lt;/p&gt;
&lt;p&gt;4、**Consul client转发注册消息。**Consul Client 可以认为是无状态的，它将注册信息通过RPC转发到Consul Server，服务信息保存在Server的各个节点中，并且通过Raft实现了强一致性。&lt;/p&gt;
&lt;p&gt;5、**服务发起通信请求。**最后在服务器Server6中Program D需要访问Service B，这时候Program D首先访问本机Consul Client提供的HTTP API，本机Client会将请求转发到 Consul Server。&lt;/p&gt;
&lt;p&gt;6、Consul Server查询到Service B当前的信息返回，最终Program D拿到了Service B的所有部署的IP和端口，然后就可以选择Service B的其中一个部署并向其发起请求了。&lt;/p&gt;
&lt;h2 id=&#34;四微服务管理--consul启动&#34;&gt;四、微服务管理--Consul启动&lt;/h2&gt;
&lt;h3 id=&#34;41启动consul&#34;&gt;4.1、启动Consul&lt;/h3&gt;
&lt;p&gt;安装配置好Consul以后，我们可以通过简单的命令启动consul。先来看最简单的启动方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;consul agent -dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在新终端中，执行如上操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/consul_starting.jpg&#34; alt=&#34;consul启动&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hongweiyu@localhost:~$ consul agent -dev
==&amp;gt; Starting Consul agent...
==&amp;gt; Consul agent running!
           Version: &#39;v1.5.1&#39;
           Node ID: &#39;808644da-c526-efa2-4f37-fff96168dcd1&#39;
         Node name: &#39;localhost&#39;
        Datacenter: &#39;dc1&#39; (Segment: &#39;&amp;lt;all&amp;gt;&#39;)
            Server: true (Bootstrap: false)
       Client Addr: [127.0.0.1] (HTTP: 8500, HTTPS: -1, gRPC: 8502, DNS: 8600)
      Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302)
           Encrypt: Gossip: false, TLS-Outgoing: false, TLS-Incoming: false

==&amp;gt; Log data will now stream in as it occurs:

    2019/06/17 15:36:18 [DEBUG] agent: Using random ID &amp;quot;808644da-c526-efa2-4f37-fff96168dcd1&amp;quot; as node ID
    2019/06/17 15:36:18 [DEBUG] tlsutil: Update with version 1
    2019/06/17 15:36:18 [DEBUG] tlsutil: OutgoingRPCWrapper with version 1
    2019/06/17 15:36:18 [DEBUG] tlsutil: IncomingRPCConfig with version 1
    2019/06/17 15:36:18 [DEBUG] tlsutil: OutgoingRPCWrapper with version 1
    2019/06/17 15:36:18 [INFO] raft: Initial configuration (index=1): [{Suffrage:Voter ID:808644da-c526-efa2-4f37-fff96168dcd1 Address:127.0.0.1:8300}]
    2019/06/17 15:36:18 [INFO] raft: Node at 127.0.0.1:8300 [Follower] entering Follower state (Leader: &amp;quot;&amp;quot;)
    2019/06/17 15:36:18 [INFO] serf: EventMemberJoin: localhost.dc1 127.0.0.1
    2019/06/17 15:36:18 [INFO] serf: EventMemberJoin: localhost 127.0.0.1
    2019/06/17 15:36:18 [INFO] consul: Handled member-join event for server &amp;quot;localhost.dc1&amp;quot; in area &amp;quot;wan&amp;quot;
    2019/06/17 15:36:18 [INFO] consul: Adding LAN server localhost (Addr: tcp/127.0.0.1:8300) (DC: dc1)
    2019/06/17 15:36:18 [DEBUG] agent/proxy: managed Connect proxy manager started
    2019/06/17 15:36:18 [INFO] agent: Started DNS server 127.0.0.1:8600 (tcp)
    2019/06/17 15:36:18 [INFO] agent: Started DNS server 127.0.0.1:8600 (udp)
    2019/06/17 15:36:18 [INFO] agent: Started HTTP server on 127.0.0.1:8500 (tcp)
    2019/06/17 15:36:18 [INFO] agent: started state syncer
    2019/06/17 15:36:18 [INFO] agent: Started gRPC server on 127.0.0.1:8502 (tcp)
    2019/06/17 15:36:18 [WARN] raft: Heartbeat timeout from &amp;quot;&amp;quot; reached, starting election
    2019/06/17 15:36:18 [INFO] raft: Node at 127.0.0.1:8300 [Candidate] entering Candidate state in term 2
    2019/06/17 15:36:18 [DEBUG] raft: Votes needed: 1
    2019/06/17 15:36:18 [DEBUG] raft: Vote granted from 808644da-c526-efa2-4f37-fff96168dcd1 in term 2. Tally: 1
    2019/06/17 15:36:18 [INFO] raft: Election won. Tally: 1
    2019/06/17 15:36:18 [INFO] raft: Node at 127.0.0.1:8300 [Leader] entering Leader state
    2019/06/17 15:36:18 [INFO] consul: cluster leadership acquired
    2019/06/17 15:36:18 [INFO] consul: New leader elected: localhost
    2019/06/17 15:36:18 [INFO] connect: initialized primary datacenter CA with provider &amp;quot;consul&amp;quot;
    2019/06/17 15:36:18 [DEBUG] consul: Skipping self join check for &amp;quot;localhost&amp;quot; since the cluster is too small
    2019/06/17 15:36:18 [INFO] consul: member &#39;localhost&#39; joined, marking health alive
    2019/06/17 15:36:18 [DEBUG] agent: Skipping remote check &amp;quot;serfHealth&amp;quot; since it is managed automatically
    2019/06/17 15:36:18 [INFO] agent: Synced node info
    2019/06/17 15:36:18 [DEBUG] agent: Node info in sync
    2019/06/17 15:36:18 [DEBUG] agent: Skipping remote check &amp;quot;serfHealth&amp;quot; since it is managed automatically
    2019/06/17 15:36:18 [DEBUG] agent: Node info in sync
    2019/06/17 15:37:18 [DEBUG] consul: Skipping self join check for &amp;quot;localhost&amp;quot; since the cluster is too small
    2019/06/17 15:37:49 [DEBUG] agent: Skipping remote check &amp;quot;serfHealth&amp;quot; since it is managed automatically
    2019/06/17 15:37:49 [DEBUG] agent: Node info in sync
    2019/06/17 15:38:18 [DEBUG] manager: Rebalanced 1 servers, next active server is localhost.dc1 (Addr: tcp/127.0.0.1:8300) (DC: dc1)
    2019/06/17 15:38:18 [DEBUG] consul: Skipping self join check for &amp;quot;localhost&amp;quot; since the cluster is too small
    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面贴出了Consul启动的输出日志，对日志做如下分析和说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-dev：dev是consul多种启动模式的一种，dev是development的缩写，代表的是开发模式，该种启动模式仅仅是为了快速便捷的启动单节点consul，比如当前环境。&lt;/li&gt;
&lt;li&gt;Consul agent running!：表示该consul节点正常运行起来。&lt;/li&gt;
&lt;li&gt;Datacenter:&#39;dc1&#39; 表示当前节点所属的数据中心的名称为dc1。&lt;/li&gt;
&lt;li&gt;Server：true（bootstrap：false） 表示该节点属于Server角色。Consul节点统称为agent，有两类：Client、Server。&lt;/li&gt;
&lt;li&gt;raft: Heartbeat timeout from &amp;quot;&amp;quot; reached, starting election Raft算法开始进行Leader节点选举。&lt;/li&gt;
&lt;li&gt;consul: cluster leadership acquired、consul: New leader elected: localhost Leader节点选举结束，本地唯一的节点被选举为leader节点。&lt;/li&gt;
&lt;li&gt;consul: member &#39;localhost&#39; joined, marking health alive 目前localhost节点是一个健康正常的节点&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42查看consul节点信息&#34;&gt;4.2、查看consul节点信息&lt;/h3&gt;
&lt;p&gt;在consul启动后，可以通过命令查看节点的信息。在原有已经启动consul的终端窗口之外，重新开启新的终端窗口，执行如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;consul members
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/consul_members.jpg&#34; alt=&#34;consul的members信息&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Node       Address         Status  Type    Build  Protocol  DC   Segment
localhost  127.0.0.1:8301  alive   server  1.5.1  2         dc1  &amp;lt;all&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出日志说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Address：节点地址&lt;/li&gt;
&lt;li&gt;Status：alive表示节点健康运行&lt;/li&gt;
&lt;li&gt;Type：节点的类型，有两种：server、client&lt;/li&gt;
&lt;li&gt;DC：Datacenter的缩写，dc1表示该节点属于Datacenter1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;43ui界面访问&#34;&gt;4.3、UI界面访问&lt;/h3&gt;
&lt;p&gt;终端命令行下启动consul的dev模式后，通过members命令查看节点信息，除此以外，还可以使用Http的浏览器访问的模式，查看节点信息。
consul启动，正常运行后，打开浏览器，在地址栏中键入：http://localhost:8500。可以查看节点信息，如下图：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190617-163040@2x.png&#34; alt=&#34;ui查看consul服务信息&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190617-163306@2x.png&#34; alt=&#34;ui查看consul节点信息&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;44停止服务&#34;&gt;4.4、停止服务&lt;/h3&gt;
&lt;p&gt;在节点运行终端中执行：ctrl + c，表示退出节点运行。
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190617-162215@2x.png&#34; alt=&#34;consul停止节点服务&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2019/06/17 16:21:43 [INFO] agent: Caught signal:  interrupt
2019/06/17 16:21:43 [INFO] agent: Graceful shutdown disabled. Exiting
2019/06/17 16:21:43 [INFO] agent: Requesting shutdown
2019/06/17 16:21:43 [WARN] agent: dev mode disabled persistence, killing all proxies since we can&#39;t recover them
2019/06/17 16:21:43 [DEBUG] agent/proxy: Stopping managed Connect proxy manager
2019/06/17 16:21:43 [INFO] consul: shutting down server
2019/06/17 16:21:43 [WARN] serf: Shutdown without a Leave
2019/06/17 16:21:43 [WARN] serf: Shutdown without a Leave
2019/06/17 16:21:43 [INFO] manager: shutting down
2019/06/17 16:21:43 [INFO] agent: consul server down
2019/06/17 16:21:43 [INFO] agent: shutdown complete
2019/06/17 16:21:43 [INFO] agent: Stopping DNS server 127.0.0.1:8600 (tcp)
2019/06/17 16:21:43 [INFO] agent: Stopping DNS server 127.0.0.1:8600 (udp)
2019/06/17 16:21:43 [INFO] agent: Stopping HTTP server 127.0.0.1:8500 (tcp)
2019/06/17 16:21:43 [INFO] agent: Waiting for endpoints to shut down
2019/06/17 16:21:43 [INFO] agent: Endpoints down
2019/06/17 16:21:43 [INFO] agent: Exit code: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;退出节点运行。&lt;/p&gt;
&lt;h3 id=&#34;45consul-dev模式示意图&#34;&gt;4.5、consul dev模式示意图&lt;/h3&gt;
&lt;p&gt;上诉consul agent -dev模式下的启动与运行consul节点。集群中只包含一个节点，唯一的节点被选举成为Leader节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190617-164506@2x.png&#34; alt=&#34;单节点dev模式示意图&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>微服务管理（下）</title>
                <link>http://www.songx.fun/blog/day78-79%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/day79_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B8%8B/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day78-79%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/day79_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B8%8B/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;微服务管理下&#34;&gt;微服务管理（下）&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一微服务管理--服务注册与查询&#34;&gt;一、微服务管理--服务注册与查询&lt;/h2&gt;
&lt;h3 id=&#34;11定义一个服务&#34;&gt;1.1、定义一个服务&lt;/h3&gt;
&lt;p&gt;服务的定义通过一个.json的json文件来进行定义，该文件中使用json格式定义所要注册服务的相关内容，以下为服务的json格式示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;service&amp;quot;: {
    &amp;quot;id&amp;quot;: &amp;quot;firstservice&amp;quot;,
    &amp;quot;name&amp;quot;: &amp;quot;firstservice&amp;quot;,
    &amp;quot;tags&amp;quot;: [&amp;quot;dev&amp;quot;],
    &amp;quot;port&amp;quot;: 80,
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12服务注册&#34;&gt;1.2、服务注册&lt;/h3&gt;
&lt;h4 id=&#34;121创建服务文件所存放的文件夹&#34;&gt;1.2.1、创建服务文件所存放的文件夹&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;sudo mkdir /etc/consul.d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：.d做后缀，表示一系列配置文件的存放目录&lt;/p&gt;
&lt;h4 id=&#34;122编写如章节一中的服务内容并保存为文件&#34;&gt;1.2.2、编写如章节一中的服务内容，并保存为文件&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;vim firstservice.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内容是章节一部分的json中的内容。&lt;/p&gt;
&lt;p&gt;说明：每一个服务都是以json文件格式的形式被单独声明在一个文件中，然后集中放到一个目录下。供consul启动时读取。&lt;/p&gt;
&lt;h4 id=&#34;123保存firstservicejson文件到指定目录&#34;&gt;1.2.3、保存firstservice.json文件到指定目录&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;mv firstservice.json /etc/consul.d/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过如上命令将自定义的firstservice.json服务文件移动至集中存放consul集群启动时要启动的服务目录中，即/etc/consul.d&lt;/p&gt;
&lt;h3 id=&#34;13服务查询&#34;&gt;1.3、服务查询&lt;/h3&gt;
&lt;h4 id=&#34;131启动consul&#34;&gt;1.3.1、启动consul&lt;/h4&gt;
&lt;p&gt;由于我们添加了服务，启动的服务是以配置文件的形式进行配置的，因此，在启动时有必要指定服务配置文件所对应的目录，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;consul agent -dev -config-dir /etc/consul.d/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上的命令表示：根据-config-dir指定的服务注册的目录中的文件来启动服务。&lt;/p&gt;
&lt;h4 id=&#34;132服务查询&#34;&gt;1.3.2、服务查询&lt;/h4&gt;
&lt;p&gt;服务的查询支持两种方式的查询，分别为：&lt;strong&gt;DNS&lt;/strong&gt;和&lt;strong&gt;HTTP&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;a、第一种：DNS&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;dig @127.0.0.1 -p 8600 dev.firstservice.service.consul
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190619-145024@2x.png&#34; alt=&#34;dns服务查询&#34;&gt;&lt;/p&gt;
&lt;p&gt;【说明：】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、dev.firstservice.service.consul是固定的格式组合，具体格式为:&lt;strong&gt;tag.servicename.service.consul&lt;/strong&gt;，即&lt;strong&gt;tag&lt;/strong&gt;和&lt;strong&gt;servicename&lt;/strong&gt;为服务创建时自定义配置内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、DNS访问的端口是8600&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;b、第二种：HTTP&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;curl http://localhost:8500/v1/catalog/service/firstservice
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190619-144852@2x.png&#34; alt=&#34;http模式查询&#34;&gt;&lt;/p&gt;
&lt;p&gt;【说明:】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、HTTP访问路径：host:port/版本号/service/服务名。&lt;/li&gt;
&lt;li&gt;2、Address：用于指定一个特定的Service的IP地址，默认情况下，使用的是该service使用的agent。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14注册多个服务&#34;&gt;1.4、注册多个服务&lt;/h3&gt;
&lt;h4 id=&#34;141每一个服务分别写一个json文件&#34;&gt;1.4.1、每一个服务分别写一个json文件&lt;/h4&gt;
&lt;p&gt;例如，新建第二个服务sendservice，将新建secondservice.json文件，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;service&amp;quot;: {
    &amp;quot;id&amp;quot;: &amp;quot;secondservice&amp;quot;,
    &amp;quot;name&amp;quot;: &amp;quot;secondservice&amp;quot;,
    &amp;quot;tags&amp;quot;: [&amp;quot;dev&amp;quot;],
    &amp;quot;port&amp;quot;: 80,
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用http格式访问：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl http://localhost:8500/v1/catalog/service/secondservice
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;142将多个服务写到一个json文件中&#34;&gt;1.4.2、将多个服务写到一个json文件中&lt;/h4&gt;
&lt;p&gt;除了将每一个服务单独定义为一个json配置文件外，consul还允许将多个服务组合定义在一个json文件中，具体的方式是对json文件的格式稍作修改，将原来的service修改为sevices，将原来service对应的对象类型，修改为数组类型。举例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;services&amp;quot;: [
  {
    &amp;quot;id&amp;quot;: &amp;quot;firstservice&amp;quot;,
    &amp;quot;name&amp;quot;: &amp;quot;firstservice&amp;quot;,
    &amp;quot;tags&amp;quot;: [&amp;quot;dev&amp;quot;],
    &amp;quot;port&amp;quot;: 80
  },
  {
    &amp;quot;id&amp;quot;: &amp;quot;secondservice&amp;quot;,
    &amp;quot;name&amp;quot;: &amp;quot;secondservice&amp;quot;,
    &amp;quot;tags&amp;quot;: [&amp;quot;dev&amp;quot;],
    &amp;quot;port&amp;quot;: 80
  }
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、放在多个services中而不是原来的service&lt;/li&gt;
&lt;li&gt;2、多个服务放在一个数组中，起名为services&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际的开发过程中，微服务数量众多。如果每个文件都放在一个文件里，文件会非常多；而如果所有服务都放在一个文件里，文件太大，也不合适。因此，在实践中，往往二者结合使用。例如，假设有100个微服务，则，放在10json文件中，每个文件中放10个微服务。&lt;/p&gt;
&lt;h2 id=&#34;二微服务管理--docker安装及运行consul节点&#34;&gt;二、微服务管理--Docker安装及运行consul节点&lt;/h2&gt;
&lt;h3 id=&#34;21搭建集群&#34;&gt;2.1、搭建集群&lt;/h3&gt;
&lt;p&gt;在真实的生产环境中，需要真实的部署consul集群。在一台机器上想要模拟多台集群部署的效果，有两种方案：一种是借助虚拟机，另一种是借助容器技术。&lt;/p&gt;
&lt;p&gt;在本系列课程中，使用后者容器技术来实现集群的搭建。&lt;/p&gt;
&lt;h3 id=&#34;22docker简介&#34;&gt;2.2、Docker简介&lt;/h3&gt;
&lt;p&gt;Docker是一个开源的应用容器引擎，基于Go语言并遵从Apache2.0协议开源。&lt;/p&gt;
&lt;p&gt;Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。&lt;/p&gt;
&lt;p&gt;容器是完全使用沙箱机制，相互之间不会有任何的接口，更重要的是容器性能开销很低。&lt;/p&gt;
&lt;h3 id=&#34;23docker安装&#34;&gt;2.3、Docker安装&lt;/h3&gt;
&lt;h4 id=&#34;231windows系统下安装&#34;&gt;2.3.1、Windows系统下安装&lt;/h4&gt;
&lt;p&gt;window系统下的安装可以参考如下的链接文档：&lt;a href=&#34;https://www.runoob.com/docker/windows-docker-install.html&#34;&gt;https://www.runoob.com/docker/windows-docker-install.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以按照如上的链接在window系统下安装Docker。&lt;/p&gt;
&lt;h4 id=&#34;232macos系统下安装&#34;&gt;2.3.2、MacOS系统下安装&lt;/h4&gt;
&lt;p&gt;MacOS系统下的安装，有两种方式。同样可以参考如下链接：&lt;a href=&#34;https://www.runoob.com/docker/macos-docker-install.html&#34;&gt;https://www.runoob.com/docker/macos-docker-install.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;24docker测试&#34;&gt;2.4、Docker测试&lt;/h3&gt;
&lt;p&gt;Docker安装完成以后，可以进行测试。可以通过终端命令的形式查看Docker是否安装成功：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/1561086326268.jpg&#34; alt=&#34;docker版本查看&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;25docker中安装consul&#34;&gt;2.5、Docker中安装consul&lt;/h3&gt;
&lt;p&gt;Docker仅仅是一个容器，是搭建集群的一个环境。如果想要搭建多个集群，还必须安装consul环境。Docker中安装consul环境，可以使用指令实现。Docker安装consul指令如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;docker search&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;docker search consul
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用如上命令查看consul的镜像文件，在终端输出如下所示内容：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190621-114548@2x.png&#34; alt=&#34;docker中查找consul的镜像文件&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;docker pull&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;docker pull consul
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过search查询了consul镜像的相关内容后，可以使用如上的docker pull命令安装consul环境。
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190621-115304@2x.png&#34; alt=&#34;Docker安装consul环境&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;26检验docker安装consul成功&#34;&gt;2.6、检验Docker安装Consul成功&lt;/h3&gt;
&lt;p&gt;在Docker中安装consul可以，可以通过如下命令查看docker中安装consul是否成功：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190621-134602@2x.png&#34; alt=&#34;docker中检查是否安装了consul&#34;&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run consul version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190621-115457@2x.png&#34; alt=&#34;docker中查看consul版本&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;27docker中启动一个单独节点consul-agent&#34;&gt;2.7、Docker中启动一个单独节点consul agent&lt;/h3&gt;
&lt;p&gt;Docker中安装好了consul以后，首先尝试启动一个server节点，可以通过如下命令来启动docker中的单个节点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run -p 8500:8500/tcp consul agent -server -ui -bootstrap-expect=1 -client=0.0.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190711-155259@2x.png&#34; alt=&#34;Docker启动单节点server&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上的命令中，参数说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;暴露了端口，分别是：HTTP端口：8500&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-h：对应的node1为节点的名称&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-server：表示启动的节点类型为server类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-bootstrap-expect：用于server节点选举leader的参数,表示达到几个server节点时开始选举&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在暴露的http端口中，还对应的映射到了主机的端口上，因此，我们可以通过在主机中访问server的信息。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;curl访问HTTP接口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl localhost:8500/v1/catalog/nodes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190621-165728@2x.png&#34; alt=&#34;http端口的映射访问&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dig来和DNS接口进行交互：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dig @0.0.0.0 -p 8600 node1.node.consul
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190621-165754@2x.png&#34; alt=&#34;dns端口映射访问&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，我们还可以浏览器来进行访问，在主机的浏览器中键入：&lt;a href=&#34;http://127.0.0.1:8500&#34;&gt;http://127.0.0.1:8500&lt;/a&gt; 进行访问，可以查看到server节点的相关信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190621-171549@2x.png&#34; alt=&#34;主机的浏览器访问sever信息&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宿主机上查看节点数量
在宿主机上已经安装了Consul， 可以用命令行来和容器里的Consul Agent进行交互：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;consul members
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190621-172012@2x.png&#34; alt=&#34;宿主机中的与docker中的节点进行交互&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;三微服务管理--docker搭建consul集群&#34;&gt;三、微服务管理--Docker搭建Consul集群&lt;/h2&gt;
&lt;h3 id=&#34;31一台主机上搭建consul集群并测试&#34;&gt;3.1、一台主机上搭建Consul集群并测试&lt;/h3&gt;
&lt;p&gt;借助Docker容器，已经启动了一个server节点，并能够与之通信。
接下来，希望借助Docker来搭建consul集群。以启动3个consul集群节点为例：&lt;/p&gt;
&lt;h4 id=&#34;311启动第一个节点&#34;&gt;3.1.1、启动第一个节点&lt;/h4&gt;
&lt;p&gt;启动第一个节点的时候没有使用了 -bootstrap 参数， 而是使用了 -bootstrap-expect 3, 使用这个参数节点会等到所有三个端都连接到一起了才会启动并且成为一个可用的cluster。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ docker run -d -p 8500:8500 -e CONSUL_BIND_INTERFACE=&#39;eth0&#39; --name=consul_server_1 consul agent -server -bootstrap -ui -node=1 -client=&#39;0.0.0.0&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对如上的参数做如下说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ui：表示启动 Web UI 管理器，默认开放端口 8500，可以在浏览器进行访问。&lt;/li&gt;
&lt;li&gt;--name&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;312查看节点ip&#34;&gt;3.1.2、查看节点IP&lt;/h4&gt;
&lt;p&gt;我们需要知道这个container的内部IP， 使用下面的命令我们吧这个IP放到了环境变量 JOIN_IP 里。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
$ JOIN_IP=&amp;quot;$(docker inspect -f &#39;{{ .NetworkSettings.IPAddress }}&#39; node1)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以直接查看container的IP，如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$docker inspect -f &#39;{{ .NetworkSettings.IPAddress }}&#39; node1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;313启动第二个节点&#34;&gt;3.1.3、启动第二个节点&lt;/h4&gt;
&lt;p&gt;启动 node2并且告诉他通过 $JOIN_IP 加入到 node1：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ docker run -d -e CONSUL_BIND_INTERFACE=&#39;eth0&#39; --name=consul_server_2 consul agent -server -node=2  -join=&#39;172.17.0.2&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里需要对参数作一下说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CONSUL_BIND_INTERFACE是consul镜像提供给我们的几个常用的环境变量，该常量与-bind作用相同。&lt;/li&gt;
&lt;li&gt;name：为启动的节点命名&lt;/li&gt;
&lt;li&gt;node：为起订的节点赋值一个id&lt;/li&gt;
&lt;li&gt;agent：表示启动 Agent 进程。&lt;/li&gt;
&lt;li&gt;server：表示启动Consul Server 模式。&lt;/li&gt;
&lt;li&gt;join：表示加入到某一个集群中去。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;314启动第三个节点&#34;&gt;3.1.4、启动第三个节点&lt;/h4&gt;
&lt;p&gt;按照同样的方法我们启动 node3：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ docker run -d -e CONSUL_BIND_INTERFACE=&#39;eth0&#39; --name=consul_server_3 consul agent -server -node=3  -join=&#39;172.17.0.2&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在我们就有了一个拥有3个节点的运行在一台机器上的集群。注意，根据Consul Agent的名字给container起了名字。&lt;/p&gt;
&lt;p&gt;我们没有暴露出任何一个端口用以访问这个集群， 但是我们可以使用第四个agent节点以client的模式（不是用 -server参数）。这意味着他不参与选举但是可以和集群交互。而且这个client模式的agent也不需要磁盘做持久化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ docker run -d -e CONSUL_BIND_INTERFACE=&#39;eth0&#39; --name=consul_server_4 consul agent -client -node=4 -join=&#39;172.17.0.2&#39; -client=&#39;0.0.0.0&#39;

$ docker run -d -e CONSUL_BIND_INTERFACE=&#39;eth0&#39; --name=consul_server_5 consul agent -client -node=5 -join=&#39;172.17.0.2&#39; -client=&#39;0.0.0.0&#39;

$ docker run -d -e CONSUL_BIND_INTERFACE=&#39;eth0&#39; --name=consul_server_6 consul agent -client -node=5 -join=&#39;172.17.0.2&#39; -client=&#39;0.0.0.0&#39;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果上述命令都能执行成功，就意味着我们的集群搭建成功了。&lt;/p&gt;
&lt;h3 id=&#34;32查看集群的状态&#34;&gt;3.2、查看集群的状态&lt;/h3&gt;
&lt;p&gt;集群搭建完成以后，我们可以通过浏览器或者终端命令行的形式来查看，集群里面的节点的状态。&lt;/p&gt;
&lt;h4 id=&#34;321浏览器&#34;&gt;3.2.1、浏览器：&lt;/h4&gt;
&lt;p&gt;我们可以在浏览器中访问localhost:8500端口,可以看到如下效果:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;三个serve类型的节点集群节点：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190712-152703@2x.png&#34; alt=&#34;http://7xtcwd.com1.z0.glb.clouddn.com/WX20190712-152703@2x.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的Node节点（server和client）：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190712-152716@2x.png&#34; alt=&#34;http://7xtcwd.com1.z0.glb.clouddn.com/WX20190712-152716@2x.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;322命令行查看节点状态&#34;&gt;3.2.2、命令行查看节点状态：&lt;/h4&gt;
&lt;p&gt;在终端下执行如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$consul members
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$docker exec consul_server_1 consul members
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;均可以看到如下输出效果：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190712-153156@2x.png&#34; alt=&#34;http://7xtcwd.com1.z0.glb.clouddn.com/WX20190712-153156@2x.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;33停止节点&#34;&gt;3.3、停止节点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;活动容器状态查看
使用docker ps命令可以输出当前运行活动中的容器：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$docker ps
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190712-153542@2x.png&#34; alt=&#34;http://7xtcwd.com1.z0.glb.clouddn.com/WX20190712-153542@2x.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;停止容器活动
可以使用如下命令将目前正处于活动中的容器停止：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$docker stop containerID 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190712-153839@2x.png&#34; alt=&#34;http://7xtcwd.com1.z0.glb.clouddn.com/WX20190712-153839@2x.png&#34;&gt;
如果要停止多个，可以用空格隔开。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移除容器
如果想要彻底移除启动的节点容器，可以通过rm命令来实现：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$docker rm containerID
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190712-154045@2x.png&#34; alt=&#34;http://7xtcwd.com1.z0.glb.clouddn.com/WX20190712-154045@2x.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;四微服务管理--微服务定义&#34;&gt;四、微服务管理--微服务定义&lt;/h2&gt;
&lt;h3 id=&#34;41consul常用命令及选项&#34;&gt;4.1、consul常用命令及选项&lt;/h3&gt;
&lt;h4 id=&#34;411常用命令command&#34;&gt;4.1.1、常用命令：command&lt;/h4&gt;
&lt;p&gt;consul命令的使用形式为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;consul command [option]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;agent：consul的节点分为client和server两类，这两类节点统称为agent节点。&lt;/li&gt;
&lt;li&gt;join：该命令的作用是将agent加入到consul的集群当中。当新启动一个agent节点后，往往需要指定节点需要加入到特定的consul集群中，此时使用join命令进行指定。&lt;/li&gt;
&lt;li&gt;members：列出consul集群中的所有的成员节点信息，包括ip，端口，状态，类型等信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;412常用选项option&#34;&gt;4.1.2、常用选项：option&lt;/h4&gt;
&lt;p&gt;除command命令外，还有option选项供开发者使用，常见的和常使用的option有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-data-dir：该选项用于指定agent储存状态的数据目录，这是所有agent都必须的，对于server尤其重要，因为他们必须持久化集群的状态。&lt;/li&gt;
&lt;li&gt;-config-dir：该选项用于指定service的配置文件和检查定义所在的位置。通常会指定为&amp;quot;某一个路径/consul.d&amp;quot;（通常情况下，.d表示一系列配置文件存放的目录）&lt;/li&gt;
&lt;li&gt;-config-file：指定一个要装载的配置文件。该选项可以配置多次，进而配置多个配置文件。&lt;/li&gt;
&lt;li&gt;-dev：该选项用于创建一个开发环境下的server节点，该参数配置下，不会有任何持久化操作，即不会有任何数据写入到磁盘。dev模式仅仅是在开发和测试环境中使用，不能用于生产环境。&lt;/li&gt;
&lt;li&gt;-bootstrap-expect：该选项用于通知consul server类型节点，指定集群的server节点个数，该参数是为了延迟选举启动，直到全部的节点启动完毕以后再进行启动。&lt;/li&gt;
&lt;li&gt;-node：该node选项用于指定节点在集群中的名称，该名称在集群中需要是唯一的，推荐直接使用机器的IP。&lt;/li&gt;
&lt;li&gt;-bind：该选项用于指定节点所在的IP地址。&lt;/li&gt;
&lt;li&gt;-server：该选项用于指明consul节点类型为server类型。每个数据中心（DC）的server数量推荐3到5个。所有的server节点加入到集群后要经过选举，采用raft一致性算法来确保数据操作的一致性。&lt;/li&gt;
&lt;li&gt;-client：该参数用于指定consul界定为client节点类型。&lt;/li&gt;
&lt;li&gt;-join：英文为加入的意思，join选项用于指定要将节点添加到具体哪个集群中。&lt;/li&gt;
&lt;li&gt;-dc：dc是datacenter的简称，该选项用于指定节点加入的dc实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42微服务定义标准及选项&#34;&gt;4.2、微服务定义标准及选项&lt;/h3&gt;
&lt;p&gt;除了命令行选项，微服务的定义和配置也可以放入文件中。在某些情况下，这可能更容易，比如当使用配置管理系统配置时。配置文件是JSON格式的，使得它们易于被人和计算机读取和编辑。配置被格式化为单个JSON对象，其中包含配置。&lt;/p&gt;
&lt;p&gt;配置文件不仅用于设置代理，还用于提供检查和服务定义。这些配置文件同样可以被其他软件和功能所识别。它们分别记录在检查配置和服务配置下。服务和检查定义支持在重新加载期间更新。&lt;/p&gt;
&lt;p&gt;例如，如下的JSON格式配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{
  &amp;quot;datacenter&amp;quot;: &amp;quot;east-aws&amp;quot;,
  &amp;quot;data_dir&amp;quot;: &amp;quot;/opt/consul&amp;quot;,
  &amp;quot;log_level&amp;quot;: &amp;quot;INFO&amp;quot;,
  &amp;quot;node_name&amp;quot;: &amp;quot;foobar&amp;quot;,
  &amp;quot;server&amp;quot;: true,
  &amp;quot;watches&amp;quot;: [
    {
        &amp;quot;type&amp;quot;: &amp;quot;checks&amp;quot;,
        &amp;quot;handler&amp;quot;: &amp;quot;/usr/bin/health-check-handler.sh&amp;quot;
    }
  ],
  &amp;quot;telemetry&amp;quot;: {
     &amp;quot;statsite_address&amp;quot;: &amp;quot;127.0.0.1:2180&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述的json文件格式是一个案例，consul的json文件配置可选项有很多，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;addresses：该配置选项用于设置绑定地址。在Consul 1.0和更高版本中，可以将这些设置为要绑定到的地址列表。支持绑定设置多种类型的地址，包括：dns、http、https、grpc等共四种类型。&lt;/li&gt;
&lt;li&gt;bootstrap：该配置相当于在命令行中添加了-bootstrap命令行标志。&lt;/li&gt;
&lt;li&gt;bootstrap_expect：该配置相当于在命令行中添加了-bootstrap_expect命令行标志。&lt;/li&gt;
&lt;li&gt;bind_addr：该配置相当于在命令行中添加-bind指令操作。&lt;/li&gt;
&lt;li&gt;ca_file：该配置用于指定ca证书文件的目录。&lt;/li&gt;
&lt;li&gt;ca_path：该配置用于指定ca证书的整体目录。&lt;/li&gt;
&lt;li&gt;client_addr：该配置与命令行中-client指令功能相同。&lt;/li&gt;
&lt;li&gt;config_entries：在该配置项下，通过配置二级配置项来进行，二级配置项可以配置bootstrap选项。&lt;/li&gt;
&lt;li&gt;connect：关于连接的一些配置项通过该配置进行设置，同样是通过二级配置项来完成，可支持的二级配置项有：enabled、ca_provider、ca_config。&lt;/li&gt;
&lt;li&gt;datacenter：该配置项与命令行中-datacenter指令作用相同。&lt;/li&gt;
&lt;li&gt;data_dir：该配置项与命令行中-data-dir指令作用相同，用于指定微服务json定义文件所在的目录。&lt;/li&gt;
&lt;li&gt;dns_config：该选项用于配置dns相关参数。&lt;/li&gt;
&lt;li&gt;domain：该配置项与命令行中的-domain指令作用相同。&lt;/li&gt;
&lt;li&gt;node_id：该配置项与命令行中的-node-id指令作用相同，用于自定义设定node-id。&lt;/li&gt;
&lt;li&gt;node_name：该配置项与命令行中的-node指令作用相同，用于为node指定名称。&lt;/li&gt;
&lt;li&gt;ports：该配置项用于配置节点的端口号，通过二级配置选项可以配置：dns、http、https、grpc、serf_lan、serf_wan、server等不同类型的端口。&lt;/li&gt;
&lt;li&gt;protocol：该配置选项与命令行中的-protocol指令功能相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上，只是列出了部分json配置文件的配置项，全部的配置选项在consul的官方网站有相关的说明，可以访问如下链接进行查看：&lt;a href=&#34;https://www.consul.io/docs/agent/options.html&#34;&gt;https://www.consul.io/docs/agent/options.html&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>微服务特性</title>
                <link>http://www.songx.fun/blog/day76%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%89%B9%E6%80%A7/day76_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day76%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%89%B9%E6%80%A7/day76_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;微服务特性&#34;&gt;微服务特性&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一微服务简介-构建单体应用&#34;&gt;一、微服务简介-构建单体应用&lt;/h2&gt;
&lt;p&gt;互联网技术发展迅速的今天，微服务倍受关注：文章、博客、社交媒体讨论和会议演讲都在谈论。与此同时，也有持怀疑态度的软件社区人员认为微服务没什么新鲜可言。反对者声称它的思想只是面向服务架构的重塑。然而，无论是炒作还是怀疑，不可否认，微服务架构模式具有非常明显的优势 —- 特别是在实施敏捷开发和复杂的企业应用迭代开发方面。&lt;/p&gt;
&lt;p&gt;从本篇文章开始，我们来开学了解学习微服务的相关知识。&lt;/p&gt;
&lt;h3 id=&#34;11单体应用&#34;&gt;1.1、单体应用&lt;/h3&gt;
&lt;p&gt;我们先不问微服务是什么？微服务该如何实现？让我们从我们原本最熟悉的创建一个应用和一个普通的项目开始说起。&lt;/p&gt;
&lt;h4 id=&#34;111打车系统&#34;&gt;1.1.1、打车系统&lt;/h4&gt;
&lt;p&gt;我们假设要开始开发一个打车应用，目标是与Uber和DiDi竞争。经过讨论和技术选型，我们开始手动开发生成一个新项目，该新应用有一个模块化的六边形架构，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/1-1.png&#34; alt=&#34;一个打车应用&#34;&gt;&lt;/p&gt;
&lt;p&gt;该应用的核心是由&lt;strong&gt;模块&lt;/strong&gt;实现的业务逻辑。它定义了&lt;strong&gt;服务、领域对象和事件&lt;/strong&gt;。围绕核心的是与外部世界接口对接的适配器。适配器示例包括数据库访问组件、生产和消费消息的消息组件和暴露了 API 或实现了一个 UI 的 web 组件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**单体应用：**所谓的单体应用就是指一个war包包含了项目的所有功能。比如上述举例的打车应用，尽管有一个逻辑模块化架构，但应用程序被作为一个单体进行打包和部署。例如，我们所熟知的许多Java应用程序被打包成WAR文件部署在如Tomcat或者Jetty之类的应用服务器上。其他Java应用程序被打包成可执行JAR包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;单体应用的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**容易开发：**开发者只需要在专用的开发工具上比如（Eclipse，myEclipse)等就可以管理整个项目代码，完成代码开发工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**容易运行和测试：**既然我们能够在本地开发工具上完成整个项目的功能开发和调试，自然也就很容易在我们本地环境上进行测试调试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**容易部署：**正如我们在举例单体应用构建项目时所说，当应用程序开发，调试，测试完成以后，我们只需要将代码进行打包，然后将打包好的应用程序拷贝到服务器上进行部署即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;112互联网公司架构&#34;&gt;1.1.2、互联网公司架构&lt;/h4&gt;
&lt;p&gt;再比如，我们拿一个常见的互联网公司的静态逻辑架构来举例，我们通过如下的架构图将系统切分成五层，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190528-115239@2x.png&#34; alt=&#34;单体应用架构&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**应用层：**面向客户的最终软件产品，直接暴露给互联网的各种App、Web站点以及Wap站点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**前置服务层：**各种重业务的聚合入口，对具体引用层做大量工作，实现业务调用链条的封装，达成业务逻辑的强实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**业务服务层：**包含各种基础的业务服务单元，比如借款系统、还款系统、征信系统、活动系统、爬虫系统、引流系统、文件系统等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**基础服务层：**不包含状态的基础业务服务，包括但不限于短信网关、文件网关、服务监控等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**数据层：**包括各种形态的数据存储层，但不限于各种数据库、缓存、消息队列等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上我们从传统的构建项目应用和项目架构拆解的角度来给大家解释了什么是单体应用，单体的特点以及传统的应用的架构设计。类似的单体应用在我们以往的互联网发展和企业应用中使用的非常普遍，现在也仍然很多企业都是类似的单体应用。&lt;/p&gt;
&lt;p&gt;但是，随着需求的增长，业务的变化，单体应用在慢慢发展和迭代后，也会遇到一些问题，单体应用的瓶颈会逐步显现。&lt;/p&gt;
&lt;p&gt;【注：】以上文档，部分内容摘抄自《Docker微服务架构实践》，作者蒋彪&lt;/p&gt;
&lt;h2 id=&#34;二微服务简介--走向单体地狱&#34;&gt;二、微服务简介--走向单体地狱&lt;/h2&gt;
&lt;p&gt;上节课我们讲了，我们在进行开发一个新的应用时，可以构建一个整体的应用系统，我们称之为单体应用。当我们的应用刚开始起步，业务功能少，代码量可控时，我们还能正常的开发。&lt;/p&gt;
&lt;h3 id=&#34;21局限性&#34;&gt;2.1、局限性&lt;/h3&gt;
&lt;p&gt;但是，随着系统业务的不断增长，代码量不断增加，我们维护创建的单体应用系统的性能和维护成本都会受到限制，限制了我们继续新增新业务的能力。&lt;/p&gt;
&lt;h3 id=&#34;22单体应用发展趋势&#34;&gt;2.2、单体应用发展趋势&lt;/h3&gt;
&lt;p&gt;成功的应用有一个趋势，整个项目随着时间推移会变得越来越臃肿。而开发团队在每个迭代开发周期中都要实现更多的用户需求，这意味着需要添加许多行代码。当原来的单体引用运行维护几年之后，小而简单的应用将会逐渐成长成一个庞大的应用。&lt;/p&gt;
&lt;h3 id=&#34;23问题与困境&#34;&gt;2.3、问题与困境&lt;/h3&gt;
&lt;p&gt;一旦应用程序成为了一个庞大、复杂的单体应用，整个开发团队可能就会陷入一个痛苦的境地，可能会遇到很多很多的问题，比如说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;敏捷开发受挫&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要问题是：应用程序实在非常复杂，其对于任何一个开发人员来说显得过于庞大&lt;/strong&gt;。最终，正确修复 bug 和实现新功能变得非常困难而耗时。&lt;/p&gt;
&lt;p&gt;就拿应用启动时间这一项指标来说，应用程序越大，启动时间越长。曾经听说过某应用程序启动需要 40 分钟以上的怪事。如果开发人员经常要重启应用服务器，那么很大一部分时间都是在等待中度过，这将极大的影响我们的工作效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;持续部署受挫&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另一个大问题是，复杂的单体应用本身就是持续部署的障碍。如今，SaaS（Software-as-a-Service软件即服务）应用发展到了可以每天多次将变更推送到生产环境。这对于复杂的单体来说非常困难，因为这需要重新部署整个应用程序才能更新其中任何一部分。联想到之前提到的漫长启动时间，这也不会是什么好事。&lt;/p&gt;
&lt;p&gt;此外，因变更所产生的影响通常不是很明确，开发者很可能需要做大量的手工测试。比如，我们仅仅是修改某个部分的代码，但是因为是全部部署，因此我们必须要重新将整个系统进行全链路测试，这样将耗费非常多额外的时间。&lt;/p&gt;
&lt;p&gt;因此，持续部署是不可能做到的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用难以扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当不同模块存在资源需求冲突时，单体应用可能难以扩展。例如，一个模块可能会进行密集型图像处理逻辑，理想情况下是部署在云服务器A实例中；另一个模块可能是一个内存数据库，最适合部署到云服务器B实例中。但是，由于这些模块是属于同一个应用，只能被部署在一起，此时就要求运维人员必须在硬件选择上做出妥协和让步，因此就使得原本我们设计的系统处理业务的能力会受到硬件环境的限制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可靠性低&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单体应用的另一个问题是可靠性低。因为所有模块都运行在同一进程中。任何模块的一个 bug，比如内存泄漏，可能会拖垮整个进程。&lt;/p&gt;
&lt;p&gt;此外，由于应用程序的所有实例都是相同的，该错误将影响到整个应用的可用性，对整个应用都造成影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;技术升级困难&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单体应用因为提及庞大，使得采用新框架和语言变得非常困难。假设有50万行代码使用了某个框架编写。如果使用较新的一个框架来重写整个应用，这将非常昂贵（在时间和成本方面）。因此，这对于团队采用新技术，对系统进行技术升级来说是一个非常大的障碍。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，经过了上面几个方面的问题的罗列，我们总结一下：当我们开发个业务量小，功能适量的一个项目应用时，通过单体应用的开发，就可以满足我们的开发需求，实现业务功能。当业务量快速增长，系统持续开发迭代时，我们的应用体积和业务复杂程度会越来越高，以至于影响开发人员的开发效率，提高了项目的维护成本，我们的项目会遇到各种瓶颈问题，应用程序的持续扩展能力受到限制，性能也因此受到影响。&lt;/p&gt;
&lt;p&gt;既然实际生产环境中遇到了这样的难题，作为项目管理者和项目开发者，就必须想办法解决出现的这些问题。&lt;/p&gt;
&lt;p&gt;我们如何做才能解决项目持续迭代后遇到的扩展能力受限和各种瓶颈问题呢？答案是&lt;strong&gt;微服务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;【注：】本文以上文档，部分内容摘抄自《Docker微服务架构实践》，作者蒋彪。&lt;/p&gt;
&lt;h3 id=&#34;三微服务简介--解决复杂问题&#34;&gt;三、微服务简介--解决复杂问题&lt;/h3&gt;
&lt;p&gt;许多大公司如阿里巴巴，腾讯，微博，滴滴等，已经采用现在所谓的微服务架构模式解决了我们前文所提到的单体应用遇到的种种问题。主要的思路：&lt;strong&gt;将应用程序分解成一套较小的互连服务。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;31微服务解决方案&#34;&gt;3、1微服务解决方案&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;一个服务通常实现了一组不同的特性或功能，例如订单管理、客户管理等。每一个微服务都是一个小型迷你应用，在需要依赖的地方，通过REST API连接其他所需要的服务之星业务逻辑。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;微服务架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一些微服务会向外暴露一组供其他模块访问和使用的API。其他微服务实现了自己的业务逻辑，在必要时，可以通过API进行业务逻辑访问。比如，之前提到的单体应用，通过拆解后，可以变成如下的架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/1-2.png&#34; alt=&#34;拆分之后的应用架构图&#34;&gt;&lt;/p&gt;
&lt;p&gt;具体的表现为：**应用程序的每个功能区域现在都由自己的微服务实现。**例如，以我们的出租车系统为例，一个是乘客的应用，一个是司机的应用。这使得它更容易地为特定的用户、司机、设备或者专门的用例部署不同的场景。每个后端服务暴露一个REST API，大部分服务消费的API由其他服务提供。例如，Driver Management 使用了 Notification 服务器来通知可用司机一个可选路程。UI服务调用了其他服务来渲染页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;微服务与数据库的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然我们将微服务架构模式明显影响到了应用程序与数据库之间的关系，与其他共享单个数据库模式服务有所不同，其每一个服务都有自己的数据库模式。一方面，这种做法与企业级数据库数据模型的想法相背，此外，它经常导致部分数据冗余。对于微服务架构而言，每一个服务都应该有自己的数据库模式，因为它能实现松耦合。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/1-5.png&#34; alt=&#34;打车应用数据库架构&#34;&gt;&lt;/p&gt;
&lt;p&gt;这种模式下设计架构的特点是每个服务都拥有各自的数据库。而且，服务可以使用一种最适合其需求、号称多语言持久架构的数据库。比如，Driver Management要找到与潜在乘客接近的司机，就必须使用支持高效地理查询的数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;【补充：伸缩立方】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论是单体应用还是微服务架构的应用，在实际的生产环境和数据量增加时，都会面临着应用扩展的需要，用以来提高处理能力。在进行系统伸缩性的探索上，有不同的方法。通常，我们常见的提高系统伸缩性能的方法有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过负载均衡器后运行的多个拷贝构成，有N份拷贝，则没份负责处理1/N的负载。比如，当我们的系统流量过大时，我们常常会部署到多个Tomcat上，这些Tomcat均挂载在同一台负载均衡器上，这样每一台Tomcat所处理的业务量就降低为原来的一部分。如下图所示：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190530-100425@2x.png&#34; alt=&#34;多台服务部署的网络拓扑图&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对数据库进行分解。原来是所有的业务和功能都存放在统一的数据库中，比如叫db1。为了提高系统性能，提高处理数据的能力，可以将原本是耦合，依赖在同一个系统中的业务模块拆分为小规模的多个业务模块，也就是我们说的微服务的实现架构，每个微服务都只实现核心功能，比如订单模块拆分为一个微服务，支付模块拆分为一个微服务。在拆分的过程中，因为每个微服务是独立部署的，所以订单模块对应的订单表存在于一个数据库db1中，支付模块所对应的支付表存在于另外一个数据库db2中。这样就完成了由一个数据库到多个数据库的拆分。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190530-103055@2x.png&#34; alt=&#34;对数据库进行分库&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对数据表进行拆分。数据库中，同一张表格的数据量过大时，我们的查询等业务在操作数据库时会变得效率下降，我们需要通过其他的方式来提高数据库操作的效率。解决这种同一张表数据的数据量过大的问题，通过拆表来解决。比如我们将0-10000000的数据存放在第1个表中，将10000001-20000000数据存放在第2个表中，依次类推。当我们操作数据库时，到对应的数据库中查询就可以了。如下图所示：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190530-111241@2x.png&#34; alt=&#34;数据库分表&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;伸缩立方&#34;&gt;&lt;strong&gt;伸缩立方&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;伸缩立方是一本技术书籍中提出的概念，这本书的名称为《The Art of Scalability》。
&lt;img src=&#34;http://www.songx.fun/img/png/1-3.png&#34; alt=&#34;开发和交付中的伸缩立方&#34;&gt;&lt;/p&gt;
&lt;p&gt;经过上述我们给大家介绍的系统伸缩性解决方案，进而解释一下伸缩立方。在上述伸缩立方的表当中，分为X轴，Y轴，Z轴。具体轴的方案如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**X轴：**运行多个负载均衡器后的多个实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**Y轴：**对应用进一步分解为微服务（分库）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**Z轴：**大数据量时，对数据进行分区（分表）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;32-微服务的优缺点&#34;&gt;3、2 微服务的优缺点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;微服务优点&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**解决复杂问题。**微服务架构把可能会变得庞大的单体应用程序分解成一套服务。虽然功能数量不变，但是应用程序已经被分解成可管理的块或者服务。每个服务都有一个明确定义边界的方式，如远程过程调用（RPC）驱动或API。微服务架构模式强制一定程度的模块化，实际上，使用单体代码来实现是极其困难的。因此，使用微服务架构模式，个体服务能被更快地开发，并更容易理解与维护。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**团队分工协作更容易。**微服务这种架构使得每个服务都可以由一个团队独立专注开发。开发者可以自由选择任何符合服务API的技术。当然，更多的组织是希望通过技术选型限制来避免完全混乱的状态。然而，这种自由意味着开发人员不再有可能在这种自由的新项目开始时使用过时的技术。当编写一个新服务时，他们可以选择当前的技术。此外，由于微服务体积较小，使用当前技术重写旧服务将变得更加可行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**独立部署。**微服务架构模式可以实现每个微服务独立部署。开发人员根本不需要去协调部署本地变更到服务。这些变更一经测试即可立即部署。比如，UI团队可以经过自己的开发和测试，并快速迭代UI变更。微服务架构模式使每个聚焦于自己核心业务的团队有了更多的自主权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**程序扩展能力强。**微服务架构模式使得每个服务能够独立扩展。开发者可以仅部署满足每个服务的容量和可用性约束的实例数目，另外每个开发团队还可以使用与服务资源要求最匹配的硬件。比如，我们可以在云服务器A实例上部署一个图像处理服务，而在云服务器B实例上部署一个内存数据库服务。微服务架构下使得我们分开部署实例变成了现实。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上几点是，我们描述了微服务的优点。和单体应用相比，微服务有其优点，当然也会有不足。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;微服务缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**规模难以界定。**如同微服务的名字一样，以微服务架构为主的设计模式重点过于强调拆分和微型，以至于会导致一个大型项目会被拆分出很多的微服务实例。在拆分的过程中，如何定义微服务迷你应用的规模，往往存在着不同的标准，有人是以核心功能为标准，有人主张以代码量为标准。总之，衡量标准不一。我们需要强调的是：**微服务仅仅是一种技术手段，而不是主要目标。**微服务的目标在于充分分解应用程序以方便应用敏捷开发和部署。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**增加系统复杂度。**因为微服务是独立部署，拆分成各个功能服务实例。因此，原本的单体应用就变成了一个分布式系统，如何管理这个分布式系统，无形之中增加了原有应用程序的复杂度。在分布式系统中，要实现各个微服务实例之间的通信和业务调用，开发者需要选择和实现基于消息或者RPC框架的进程间通信机制来实现微服务间通信。另外，多个微服务调用之间的请求，调试，协调等问题，也会增加团队间的沟通成本，相比起单体应用来说，微服务架构在这一点上也要更复杂。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**分区数据库架构难题。**当我们在进行正常的业务开发时，往往需要涉及到多个模块之间的数据调用和数据更新。在原来的单体应用下，比较容易实现，我们只需要操作不同的实体表就可以实现，但是在微服务架构中，因为数据存储是独立存储和部署，这导致我们在某个业务中更新多个模块数据时，我们需要调用不同的微服务接口API依次更新。在实际的开发和实践过程中，这个问题也会成为开发人员的主要困扰之一。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**项目测试难度增加。**在原来的单体应用中，开发者可以通过在统一的测试目录下统一编写测试用例和测试方法，然后启动应用服务，进行测试系统功能，对开发人员来说这是常见的做法也是比较熟悉的做法。相比较而言，如果我们要进行微服务的功能测试，就需要将所依赖的所有的微服务都要启动起来才能执行。虽然这个工作难度不大，但是要知道，一旦我们的某个微服务实例依赖的其他实例数量较多时，对开发者调试的工作量来说，是直线上升的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**多服务修改更加困难。**比如在原本的单体应用中存在三个模块，分别为：模块A、模块B和模块C。当我们有业务逻辑需要进行修改时，我们只需要在同一个应用程序中协作修改三个模块，完成业务功能的调整，然后测试并上线。但是在微服务中，当我们需要横框多个微服务实例间进行业务调整时，就需要仔细认真规划和协调，以便完成整个业务的调整。这样对开发者来说，迭代维护的成本也会增加。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**微服务需要进行多次部署。**原来的单体应用在部署时，可以通过将所有的项目模块打包到一个整体的部署包内，然后部署到一台或者一组服务器上。相比较之下，将程序改为微服务架构以后，应用程序的数量就变多了，这样在整体运行时就需要部署多次，这是一个不小的工作量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上几点是微服务架构不足的地方。我们必须要辩证的看待和使用微服务，本质上它是一项技术，我们要利用微服务技术解决现实项目中的问题。&lt;/p&gt;
&lt;h2 id=&#34;四微服务的概念与微服务架构实践的问题&#34;&gt;四、微服务的概念与微服务架构实践的问题&lt;/h2&gt;
&lt;p&gt;前面几节课程我们向大家讲了从单体应用如何发展到微服务架构的项目架构的转变，以及单体应用和微服务架构各自的优缺点。本节课，我们来看一看微服务的定义和标准，以及在实践中解决的问题。&lt;/p&gt;
&lt;h3 id=&#34;41-微服务的定义&#34;&gt;4、1 微服务的定义&lt;/h3&gt;
&lt;p&gt;结合我们之前所了解到的文章和相关知识，并结合相关资料。我们借鉴微服务之父Martin先生给微服务的定义：**将一个单体应用拆分成一组微小的服务组件，每个微小的服务组件运行在自己的进程上，组件之间通过如RESTful API这样的轻量级机制进行交互，这些服务以业务能力为核心，用自动化部署机制独立部署，另外，这些服务可以用不同的语言进行研发，用不同技术来存储数据。**通过以上的定义描述，我们可以基本确定给出微服务的节特征，如下所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在分布式环境中，将单体应用拆分为一系列服务，共同组成整个系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个服务都轻量级，单独部署，运行在自己的进程中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个微服务注重自己的核心能力的开发，微服务组件之间采用轻量级通信方式进行通信，包括但不限于RESTful API。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照业务边界进行划分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微服务是一种编程架构思想，有不同的语言实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42-微服务实践要解决的问题&#34;&gt;4、2 微服务实践要解决的问题&lt;/h3&gt;
&lt;p&gt;用微服务来进行实践到生产项目中，首先要解决一些问题。比如下图的微服务业务架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190530-150342@2x.png&#34; alt=&#34;微服务架构&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图图表展示的架构图中，我们假设将业务商户服务A、订单服务B和产品服务C分别拆分为一个微服务应用，单独进行部署。此时，我们面临很多要可能出现的问题要解决，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1、客户端如何访问这些服务？&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2、每个服务之间如何进行通信？&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;3、多个微服务，应如何实现？&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;4、如果服务出现异常宕机，该如何解决？&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上这些都是问题，需要一个个解决。&lt;/p&gt;
&lt;h4 id=&#34;421客户端如何访问服务&#34;&gt;4.2.1、客户端如何访问服务&lt;/h4&gt;
&lt;p&gt;在单体应用开发中，所有的服务都是本地的，前端UI界面，移动端APP程序可以直接访问后端服务器程序。&lt;/p&gt;
&lt;p&gt;现在按功能拆分成独立的服务，跑在独立的进程中。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190530-151455@2x.png&#34; alt=&#34;多服务部署&#34;&gt;&lt;/p&gt;
&lt;p&gt;此时，后台有N个服务，前台就需要记住管理N个服务，一个服务&lt;strong&gt;下线&lt;/strong&gt;、&lt;strong&gt;更新&lt;/strong&gt;、&lt;strong&gt;升级&lt;/strong&gt;，前台和移动端APP就要重新部署或者重新发包，这明显不服务我们拆分的理念。尤其是对当下业务需求的飞速发展，业务的变更是非常频繁的。&lt;/p&gt;
&lt;p&gt;除了访问管理出现困难以外，N个小服务的调用也是一个不小的网络开销。另外，一般微服务在系统内部，通常是无状态的，而我们的用户在进行业务操作时，往往是跨业务模块进行操作，且需要是有状态的，在此时的这个系统架构中，也无法解决这个问题。传统的用来解决用户登录信息和权限管理通常有一个统一的地方维护管理（OAuth），我们称之为授权管理。&lt;/p&gt;
&lt;p&gt;基于以上列出的问题，我们采用一种叫做网关（英文为API Gateway）的技术方案来解决这些问题，网关的作用主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提供统一服务入口，让微服务对前台透明&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;聚合后台的服务，节省流量，提升性能&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提供安全，过滤，流控等API管理功能&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网关(API Gateway)可以有很多广义的实现办法，可以是一个软硬一体的盒子，也可以是一个简单的MVC框架，甚至是一个Node.js的服务端。他们最重要的作用是为前台（通常是移动应用）提供后台服务的聚合，提供一个统一的服务出口，解除他们之间的耦合，不过API Gateway也有可能成为&lt;strong&gt;单点故障&lt;/strong&gt;点或者性能的瓶颈。&lt;/p&gt;
&lt;p&gt;最终，添加了网关(API Gateway)的业务架构图变更为如下所示：
&lt;img src=&#34;http://7xtcwd.com1.z0.glb.clouddn.com/WX20190530-154328@2x.png&#34; alt=&#34;网关&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;422服务之间如何通信&#34;&gt;4.2.2、服务之间如何通信&lt;/h4&gt;
&lt;p&gt;所有的微服务都是独立部署，运行在自己的进程容器中，所以微服务与微服务之间的通信就是IPC（Inter Process Communication），翻译为进程间通信。进程间通信的方案已经比较成熟了，现在最常见的有两大类：&lt;strong&gt;同步调用、异步消息调用&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&#34;同步调用&#34;&gt;&lt;strong&gt;同步调用&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;同步调用比较简单，一致性强，但是容易出调用问题，性能体验上也会差些，特别是调用层次多的时候。同步调用的有两种实现方式：分别是&lt;strong&gt;REST&lt;/strong&gt;和&lt;strong&gt;RPC&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**REST：**REST基于HTTP，实现更容易，各种语言都支持，同时能够跨客户端，对客户端没有特殊的要求，只要具备HTTP的网络请求库功能就能使用。&lt;/li&gt;
&lt;li&gt;**RPC：**rpc的特点是传输效率高，安全性可控，在系统内部调用实现时使用的较多。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于REST和RPC的特点，我们通常采用的原则为：&lt;strong&gt;向系统外部暴露采用REST，向系统内部暴露调用采用RPC方式。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;异步消息调用&#34;&gt;&lt;strong&gt;异步消息调用&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;异步消息的方式在分布式系统中有特别广泛的应用，他既能减低调用服务之间的耦合，又能成为调用之间的缓冲，确保消息积压不会冲垮被调用方，同时能保证调用方的服务体验，继续干自己该干的活，不至于被后台性能拖慢。需要付出的代价是一致性的减弱，需要接受数据&lt;strong&gt;最终一致性&lt;/strong&gt;，所谓的最终一致性就是只可能不会立刻同步完成，会有延时，但是最终会完成数据同步；还有就是后台服务一般要实现&lt;strong&gt;幂等性&lt;/strong&gt;，因为消息送出于性能的考虑一般会有重复（保证消息的被收到且仅收到一次对性能是很大的考验）。最后就是必须引入一个独立的 Broker，作为中间代理池。&lt;/p&gt;
&lt;p&gt;常见的异步消息调用的框架有：Kafaka、Notify、MessageQueue。&lt;/p&gt;
&lt;p&gt;最终，大部分的服务间的调用架构实现如下所示：
&lt;img src=&#34;http://7xtcwd.com1.z0.glb.clouddn.com/WX20190530-170424@2x.png&#34; alt=&#34;服务间通信&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;423如何实现众多微服务&#34;&gt;4.2.3、如何实现众多微服务&lt;/h4&gt;
&lt;p&gt;在微服务架构中，一般每一个服务都是有多个拷贝，来做负载均衡。一个服务随时可能下线，也可能应对临时访问压力增加新的服务节点。这就出现了新的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**服务之间如何相互感知？**例如有新的服务实例上线，已上线的实例如何知道并与之通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**服务如何管理？**服务实例数量多了，也面临着如何管理的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就是服务的发现、识别与管理问题。解决多服务之间的识别，发现的问题一般是通过注册的方式来进行。&lt;/p&gt;
&lt;p&gt;具体来说：当服务上线时，服务提供者将自己的服务注册信息注册到某个专门的框架中，并通过心跳维持长链接，实时更新链接信息。服务调用者通过服务管理框架进行寻址，根据特定的算法，找到对应的服务，或者将服务的注册信息缓存到本地，这样提高性能。当服务下线时，服务管理框架会发送服务下线的通知给其他服务。&lt;/p&gt;
&lt;p&gt;常见的服务管理框架有：Zookeeper等框架。&lt;/p&gt;
&lt;p&gt;如上的问题解决方案有两种具体的实现，分别是：&lt;strong&gt;基于客户端的服务注册与发现&lt;/strong&gt;、&lt;strong&gt;基于服务端的服务注册与发现&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&#34;基于客户端的服务注册与发现&#34;&gt;基于客户端的服务注册与发现&lt;/h5&gt;
&lt;p&gt;优点是架构简单，扩展灵活，只对服务注册器依赖。缺点是客户端要维护所有调用服务的地址，有技术难度，一般大公司都有成熟的内部框架支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190530-173138@2x.png&#34; alt=&#34;基于客户端的服务注册与发现&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;基于服务端的服务注册与发现&#34;&gt;基于服务端的服务注册与发现&lt;/h5&gt;
&lt;p&gt;优点是简单，所有服务对于前台调用方透明，一般在小公司在云服务上部署的应用采用的比较多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190530-173212@2x.png&#34; alt=&#34;基于服务端的服务注册与发现&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;424服务宕机等异常情况的处理&#34;&gt;4.2.4、服务宕机等异常情况的处理&lt;/h4&gt;
&lt;p&gt;前面提到，单体应用开发一个很大的风险是，把所有鸡蛋放在一个篮子里，一荣俱荣，一损俱损。而分布式最大的特性就是网络是不可靠的。通过微服务拆分能降低这个风险，不过如果没有特别的保障，结局肯定是噩梦。&lt;/p&gt;
&lt;p&gt;因此，当我们的系统是由一系列的服务调用链组成的时候，我们必须确保任一环节出问题都不至于影响整体链路。相应的手段有很多，比如说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;重试机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;限流&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;熔断机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;负载均衡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;降级（本地缓存）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E6%A1%86%E6%9E%B6/">框架</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>项目搭建、登录注册和Session功能开发</title>
                <link>http://www.songx.fun/blog/day38-41beego%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/day38_%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%92%8Csession%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day38-41beego%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/day38_%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%92%8Csession%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;项目搭建登录注册和session功能开发&#34;&gt;项目搭建、登录注册和Session功能开发&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一-项目搭建和注册用户功能&#34;&gt;一 项目搭建和注册用户功能&lt;/h2&gt;
&lt;h3 id=&#34;11-项目搭建&#34;&gt;1.1 项目搭建&lt;/h3&gt;
&lt;h4 id=&#34;111-创建项目&#34;&gt;1.1.1 创建项目&lt;/h4&gt;
&lt;p&gt;首先打开终端进入gopath下的src目录，然后执行以下命令，创建一个beego项目：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bee new myblog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190519-230051@2x.png&#34; alt=&#34;项目创建&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后通过goland打开该项目：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190520-062806@2x.png&#34; alt=&#34;项目目录&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;112-修改端口配置&#34;&gt;1.1.2 修改端口配置&lt;/h4&gt;
&lt;p&gt;我们打开conf包下的配置文件：app.conf文件，修改端口号为8080：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;appname = myblog
httpport = 8080
runmode = dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;113-项目运行和效果&#34;&gt;1.1.3 项目运行和效果&lt;/h4&gt;
&lt;p&gt;然后在终端中进入该项目目录，然后运行项目：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190520-063001@2x.png&#34; alt=&#34;项目运行&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，项目已经运行了，并且监听在8080的端口上。接下来我们打开浏览器输入网址：&lt;a href=&#34;http://127.0.0.1:8080/&#34;&gt;http://127.0.0.1:8080/&lt;/a&gt;，然后可以看到欢迎界面：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190520-063119@2x.png&#34; alt=&#34;浏览器效果&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;12-用户注册功能&#34;&gt;1.2 用户注册功能&lt;/h3&gt;
&lt;h4 id=&#34;121-数据库创建及连接&#34;&gt;1.2.1 数据库创建及连接&lt;/h4&gt;
&lt;p&gt;首先我们先在创建一个数据库：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190520-063304@2x.png&#34; alt=&#34;数据库创建&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们先创建一个工具包utils，然后创建一个go文件，用于做mysql的工具类，里面提供连接数据库和创建表的功能。&lt;/p&gt;
&lt;p&gt;首先提供一个初始化方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func InitMysql() {

	fmt.Println(&amp;quot;InitMysql....&amp;quot;)
	driverName := beego.AppConfig.String(&amp;quot;driverName&amp;quot;)

	//注册数据库驱动
	orm.RegisterDriver(driverName, orm.DRMySQL)

	//数据库连接
	user := beego.AppConfig.String(&amp;quot;mysqluser&amp;quot;)
	pwd := beego.AppConfig.String(&amp;quot;mysqlpwd&amp;quot;)
	host := beego.AppConfig.String(&amp;quot;host&amp;quot;)
	port := beego.AppConfig.String(&amp;quot;port&amp;quot;)
	dbname := beego.AppConfig.String(&amp;quot;dbname&amp;quot;)

	//dbConn := &amp;quot;root:yu271400@tcp(127.0.0.1:3306)/cmsproject?charset=utf8&amp;quot;
	dbConn := user + &amp;quot;:&amp;quot; + pwd + &amp;quot;@tcp(&amp;quot; + host + &amp;quot;:&amp;quot; + port + &amp;quot;)/&amp;quot; + dbname + &amp;quot;?charset=utf8&amp;quot;

	//dbConn := &amp;quot;root:yu271400@tcp(127.0.0.1:3306)/cmsproject?charset=utf8&amp;quot;
	dbConn := user + &amp;quot;:&amp;quot; + pwd + &amp;quot;@tcp(&amp;quot; + host + &amp;quot;:&amp;quot; + port + &amp;quot;)/&amp;quot; + dbname + &amp;quot;?charset=utf8&amp;quot;

	db, _ = sql.Open(driverName, dbConn)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;122-数据库表设计&#34;&gt;1.2.2 数据库表设计&lt;/h4&gt;
&lt;p&gt;然后设计一下数据表，我们需要用户的id，并且作为主键，用户名username和密码password，还有状态status，这个用于标记该用户是否被删除，0表示正常状态，1表示删除。还要就是注册时间，我们用整型的时间戳来表示即可，所以sql语句如下：可以直接操作数据库创建，也可以通过代码进行创建：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//创建用户表
func CreateTableWithUser() {
	sql := `CREATE TABLE IF NOT EXISTS users(
		id INT(4) PRIMARY KEY AUTO_INCREMENT NOT NULL,
		username VARCHAR(64),
		password VARCHAR(64),
		status INT(4),
		createtime INT(10)
		);`

	ModifyDB(sql)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;123-数据库操作方法&#34;&gt;1.2.3 数据库操作方法&lt;/h4&gt;
&lt;p&gt;然后再提供一个方法，用于执行sql语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//操作数据库
func ModifyDB(sql string, args ...interface{}) (int64, error) {
	result, err := db.Exec(sql, args...)
	if err != nil {
		log.Println(err)
		return 0, err
	}
	count, err := result.RowsAffected()
	if err != nil {
		log.Println(err)
		return 0, err
	}
	return count, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再提供一个方法，用于之后的数据库操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
//查询
func QueryRowDB(sql string) *sql.Row{
	return db.QueryRow(sql)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;124-定义user和数据库操作方法&#34;&gt;1.2.4 定义User和数据库操作方法&lt;/h4&gt;
&lt;p&gt;然后再models中创建一个model文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package models

import (
	&amp;quot;myblogweb/utils&amp;quot;
	&amp;quot;fmt&amp;quot;
)

type User struct {
	Id         int
	Username   string
	Password   string
	Status     int // 0 正常状态， 1删除
	Createtime int64
}

//--------------数据库操作-----------------

//插入
func InsertUser(user User)(int64, error){
	return utils.ModifyDB(&amp;quot;insert into users(username,password,status,createtime) values (?,?,?,?)&amp;quot;,
		user.Username,user.Password,user.Status,user.Createtime)
}

//按条件查询
func QueryUserWightCon(con string)int{
	sql := fmt.Sprintf(&amp;quot;select id from users %s&amp;quot;,con)
	fmt.Println(sql)
	row:=utils.QueryRowDB(sql)
	id :=0
	row.Scan(&amp;amp;id)
	return id
}

//根据用户名查询id
func QueryUserWithUsername(username string) int{
	sql := fmt.Sprintf(&amp;quot;where username=&#39;%s&#39;&amp;quot;,username)
	return QueryUserWightCon(sql)
}

//根据用户名和密码，查询id
func QueryUserWithParam(username ,password string)int{
	sql:=fmt.Sprintf(&amp;quot;where username=&#39;%s&#39; and password=&#39;%s&#39;&amp;quot;,username,password)
	return QueryUserWightCon(sql)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;125-创建registerhtml注册文件&#34;&gt;1.2.5 创建register.html注册文件&lt;/h4&gt;
&lt;p&gt;我们先在views包下，创建一个html页面：register.html。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;注册&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;../static/css/lib/login.css&amp;quot;&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;../static/css/blogsheet.css&amp;quot;&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/lib/jquery-3.3.1.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/lib/jquery.url.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/blog.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;nav&amp;quot;&amp;gt;
        &amp;lt;div id=&amp;quot;nav-login&amp;quot;&amp;gt;
            &amp;lt;ul&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/login&amp;quot;&amp;gt;登录&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/register&amp;quot;&amp;gt;注册&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;

            &amp;lt;/ul&amp;gt;

        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;


    &amp;lt;div class=&amp;quot;htmleaf-container&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;wrapper&amp;quot;&amp;gt;
            &amp;lt;!--注册表单--&amp;gt;
            &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
                &amp;lt;h1&amp;gt;Welcome&amp;lt;/h1&amp;gt;
                &amp;lt;form id=&amp;quot;register-form&amp;quot; class=&amp;quot;form&amp;quot;&amp;gt;
                    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; placeholder=&amp;quot;Username&amp;quot;&amp;gt;
                    &amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot; placeholder=&amp;quot;Password&amp;quot; id=&amp;quot;register-password&amp;quot;&amp;gt;
                    &amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;repassword&amp;quot; placeholder=&amp;quot;rePassword&amp;quot;&amp;gt;
                    &amp;lt;br&amp;gt;
                    &amp;lt;button type=&amp;quot;submit&amp;quot; id=&amp;quot;login-button&amp;quot;&amp;gt;Register&amp;lt;/button&amp;gt;
                &amp;lt;/form&amp;gt;
            &amp;lt;/div&amp;gt;

            {{/*背景动画*/}}
            &amp;lt;ul class=&amp;quot;bg-bubbles&amp;quot;&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;126-添加用户注册逻辑验证&#34;&gt;1.2.6 添加用户注册逻辑验证&lt;/h4&gt;
&lt;p&gt;添加表单验证：我们使用jquery来实现js部分，在js目录下，创建子目录lib，在里面放jquery框架文件，并在页面中引入。&lt;/p&gt;
&lt;p&gt;然后重新创建一个js文件：blog.js
首先添加表单验证：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(document).ready(function () {
    //注册表单验证
    $(&amp;quot;register-from&amp;quot;).validate({
        rules:{
            username:{
                required:true,
                rangelength:[5,10]
            },
            password:{
                required:true,
                rangelength:[5,10]
            },
            repassword:{
                required:true,
                rangelength:[5,10],
                equalTo:&amp;quot;#register-password&amp;quot;
            }
        },
        messages:{
            username:{
                required:&amp;quot;请输入用户名&amp;quot;,
                rangelength:&amp;quot;用户名必须是5-10位&amp;quot;
            },
            password:{
                required:&amp;quot;请输入密码&amp;quot;,
                rangelength:&amp;quot;密码必须是5-10位&amp;quot;
            },
            repassword:{
                required:&amp;quot;请确认密码&amp;quot;,
                rangelength:&amp;quot;密码必须是5-10位&amp;quot;,
                equalTo:&amp;quot;两次输入的密码必须相等&amp;quot;
            }
        },
        submitHandler:function (form) {
            var urlStr = &amp;quot;/register&amp;quot;;
            // alert(&amp;quot;urlStr:&amp;quot;+urlStr)
            $(form).ajaxSubmit({
                url:urlStr,
                type:&amp;quot;post&amp;quot;,
                dataType:&amp;quot;json&amp;quot;,
                success:function (data,status) {
                    alert(&amp;quot;data:&amp;quot;+data.message)
                    if (data.code == 1){
                        setTimeout(function () {
                            window.location.href=&amp;quot;/login&amp;quot;
                        },1000)
                    }
                },
                err:function (data,status) {
                    alert(&amp;quot;err:&amp;quot;+data.message+&amp;quot;:&amp;quot;+status)
                }
            })
        }
    })
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当用户点击表单的submit按钮，会跳转到/register路径，而因为设置为post请求，所以我们可以在post中完成表单的注册。如果注册成功，再跳转到/login路径。&lt;/p&gt;
&lt;h4 id=&#34;127-控制器开发controller&#34;&gt;1.2.7 控制器开发(controller)&lt;/h4&gt;
&lt;p&gt;我们在controllers包下创建一个新的controller，用来处理用户的注册：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package controllers

import &amp;quot;github.com/astaxie/beego&amp;quot;

type RegisterController struct {
	beego.Controller
}

func (this *RegisterController) Get(){
	this.TplName = &amp;quot;register.html&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;128-添加路由解析&#34;&gt;1.2.8 添加路由解析&lt;/h4&gt;
&lt;p&gt;接下来，我们需要新注册一个路由，修改router.go文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func init() {
    beego.Router(&amp;quot;/&amp;quot;, &amp;amp;controllers.MainController{})
    beego.Router(&amp;quot;/register&amp;quot;, &amp;amp;controllers.RegisterController{})
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;129-post方法编码实现&#34;&gt;1.2.9 Post方法编码实现&lt;/h4&gt;
&lt;p&gt;我们创建一个Post()方法，用于处理post的请求：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
//处理注册
func (this *RegisterController) Post() {
	//获取表单信息
	username := this.GetString(&amp;quot;username&amp;quot;)
	password := this.GetString(&amp;quot;password&amp;quot;)
	repassword := this.GetString(&amp;quot;repassword&amp;quot;)
	fmt.Println(username, password, repassword)

	//注册之前先判断该用户名是否已经被注册，如果已经注册，返回错误
	id := models.QueryUserWithUsername(username)
	fmt.Println(&amp;quot;id:&amp;quot;,id)
	if id &amp;gt; 0 {
		this.Data[&amp;quot;json&amp;quot;] = map[string]interface{}{&amp;quot;code&amp;quot;:0,&amp;quot;message&amp;quot;:&amp;quot;用户名已经存在&amp;quot;}
		this.ServeJSON()
		return
	}

	//注册用户名和密码
	//存储的密码是md5后的数据，那么在登录的验证的时候，也是需要将用户的密码md5之后和数据库里面的密码进行判断
	password = utils.MD5(password)
	fmt.Println(&amp;quot;md5后：&amp;quot;,password)

	user := models.User{0,username,password,0,time.Now().Unix()}
	_,err :=models.InsertUser(user)
	if err != nil{
		this.Data[&amp;quot;json&amp;quot;] = map[string]interface{}{&amp;quot;code&amp;quot;:0,&amp;quot;message&amp;quot;:&amp;quot;注册失败&amp;quot;}
	}else{
		this.Data[&amp;quot;json&amp;quot;] = map[string]interface{}{&amp;quot;code&amp;quot;:1,&amp;quot;message&amp;quot;:&amp;quot;注册成功&amp;quot;}
	}
	this.ServeJSON()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路就是先接收表单信息，然后判断数据库中是否已经存在了该用户名，如果已经存在，那么无法进行注册，我们可以通过json返回信息：用户名已经存在。&lt;/p&gt;
&lt;p&gt;否则再进行注册，出于对密码安全的考虑，我们可以在数据库中存储密码的md5加密数据。&lt;/p&gt;
&lt;h4 id=&#34;1210-工具方法&#34;&gt;1.2.10 工具方法&lt;/h4&gt;
&lt;p&gt;所以在工具包中，再添加一个工具类：myUtils.go&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package utils

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;crypto/md5&amp;quot;
)

//传入的数据不一样，那么MD5后的32位长度的数据肯定会不一样
func MD5(str string) string{
	md5str:=fmt.Sprintf(&amp;quot;%x&amp;quot;,md5.Sum([]byte(str)))
	return md5str
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1211-项目运行&#34;&gt;1.2.11 项目运行&lt;/h4&gt;
&lt;p&gt;我们打开终端，进入项目所在的目录，执行命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bee run
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190520-065447@2x.png&#34; alt=&#34;项目运行命令&#34;&gt;&lt;/p&gt;
&lt;p&gt;项目启动后，监听在8080端口上。&lt;/p&gt;
&lt;p&gt;并且执行了InitMysql()方法，初始化数据库，我们打开数据库进行刷新，已经创建好了一张数据表user：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190520-083914@2x.png&#34; alt=&#34;数据库表&#34;&gt;&lt;/p&gt;
&lt;p&gt;打开浏览器，输入以下网址：&lt;a href=&#34;http://localhost:8080/register&#34;&gt;http://localhost:8080/register&lt;/a&gt; ,然后输入用户名和密码进行注册。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190520-084747@2x.png&#34; alt=&#34;注册接口调用&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190520-084800@2x.png&#34; alt=&#34;数据库表数据查看&#34;&gt;&lt;/p&gt;
&lt;p&gt;此处，大家可以反复的试验，比如用户名长度不够，重复密码不一致，相同用户名等。&lt;/p&gt;
&lt;h2 id=&#34;二-用户登录功能&#34;&gt;二 用户登录功能&lt;/h2&gt;
&lt;p&gt;上一章节我们已经实现了注册用户名和密码。接下来我们实现登录。&lt;/p&gt;
&lt;h3 id=&#34;21-定义logincontroller&#34;&gt;2.1 定义LoginController&lt;/h3&gt;
&lt;p&gt;先创建一个新的go文件，用来定义新的Controller：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type LoginController struct {
	beego.Controller
}
func (this *LoginController) Get() {
	this.TplName = &amp;quot;login.html&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22-注册登录功能路由&#34;&gt;2.2 注册登录功能路由&lt;/h3&gt;
&lt;p&gt;然后注册一个新的路由：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func init() {
    beego.Router(&amp;quot;/&amp;quot;, &amp;amp;controllers.MainController{})
    beego.Router(&amp;quot;/register&amp;quot;, &amp;amp;controllers.RegisterController{})
    beego.Router(&amp;quot;/login&amp;quot;, &amp;amp;controllers.LoginController{})
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-新增post方法处理登录请求&#34;&gt;2.3 新增Post方法处理登录请求&lt;/h3&gt;
&lt;p&gt;然后添加一个Post方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (this *LoginController) Post() {
	username := this.GetString(&amp;quot;username&amp;quot;)
	password := this.GetString(&amp;quot;password&amp;quot;)
	fmt.Println(&amp;quot;username:&amp;quot;, username, &amp;quot;,password:&amp;quot;, password)
	id := models.QueryUserWithParam(username, utils.MD5(password))
	fmt.Println(&amp;quot;id:&amp;quot;,id)
	if id &amp;gt; 0 {
		this.Data[&amp;quot;json&amp;quot;] = map[string]interface{}{&amp;quot;code&amp;quot;: 1, &amp;quot;message&amp;quot;: &amp;quot;登录成功&amp;quot;}
	} else {
		this.Data[&amp;quot;json&amp;quot;] = map[string]interface{}{&amp;quot;code&amp;quot;: 0, &amp;quot;message&amp;quot;: &amp;quot;登录失败&amp;quot;}
	}
	this.ServeJSON()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;24-用户登录的model操作&#34;&gt;2.4 用户登录的model操作&lt;/h3&gt;
&lt;p&gt;在之前的Post方法中，我们已经接收页面传来的用户名和密码，然后user_model.go中添加一个方法，用于根据用户名和密码来查询id，表示用户登录的用户名和密码是否正确。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//根据用户名和密码，查询id
func QueryUserWithParam(username ,password string)int{
	sql:=fmt.Sprintf(&amp;quot;where username=&#39;%s&#39; and password=&#39;%s&#39;&amp;quot;,username,password)
	return QueryUserWightCon(sql)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;25-视图层开发&#34;&gt;2.5 视图层开发&lt;/h3&gt;
&lt;h4 id=&#34;251-新建loginhtml文件&#34;&gt;2.5.1 新建login.html文件&lt;/h4&gt;
&lt;p&gt;我们重新再views包下创建一个html页面，login.html，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;登录&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;../static/css/lib/login.css&amp;quot;&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;../static/css/blogsheet.css&amp;quot;&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/lib/jquery-3.3.1.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/lib/jquery.url.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/blog.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&amp;quot;nav&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;nav-login&amp;quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/login&amp;quot;&amp;gt;登录&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/register&amp;quot;&amp;gt;注册&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;

    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=&amp;quot;htmleaf-container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;wrapper&amp;quot;&amp;gt;
    {{/*注册表单*/}}
        &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
            &amp;lt;h1&amp;gt;Welcome&amp;lt;/h1&amp;gt;
            &amp;lt;form id=&amp;quot;login-form&amp;quot; class=&amp;quot;form&amp;quot;&amp;gt;
                &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; placeholder=&amp;quot;请输入用户名&amp;quot;&amp;gt;
                &amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot; placeholder=&amp;quot;请输入密码&amp;quot; id=&amp;quot;login-password&amp;quot;&amp;gt;
                &amp;lt;br&amp;gt;
                &amp;lt;button type=&amp;quot;submit&amp;quot; id=&amp;quot;login-button&amp;quot;&amp;gt;登录&amp;lt;/button&amp;gt;
            &amp;lt;/form&amp;gt;
        &amp;lt;/div&amp;gt;

    {{/*背景动画*/}}
        &amp;lt;ul class=&amp;quot;bg-bubbles&amp;quot;&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;因为内容和注册页类似，可以将注册页的内容复制过来，但是要注意标签id等的不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;252-js实现登录逻辑验证&#34;&gt;2.5.2 js实现登录逻辑验证&lt;/h4&gt;
&lt;p&gt;接下来我们实现js部分，在blog.js中添加代码，实现登录部分：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //登录
    $(&amp;quot;#login-form&amp;quot;).validate({
        rules:{
            username:{
                required:true,
                rangelength:[5,10]
            },
            password:{
                required:true,
                rangelength:[5,10]
            }
        },
        messages:{
            username:{
                required:&amp;quot;请输入用户名&amp;quot;,
                rangelength:&amp;quot;用户名必须是5-10位&amp;quot;
            },
            password:{
                required:&amp;quot;请输入密码&amp;quot;,
                rangelength:&amp;quot;密码必须是5-10位&amp;quot;
            }
        },
        submitHandler:function (form) {
            var urlStr =&amp;quot;/login&amp;quot;
            alert(&amp;quot;urlStr:&amp;quot;+urlStr)
            $(form).ajaxSubmit({
                url:urlStr,
                type:&amp;quot;post&amp;quot;,
                dataType:&amp;quot;json&amp;quot;,
                success:function (data,status) {
                    alert(&amp;quot;data:&amp;quot;+data.message+&amp;quot;:&amp;quot;+status)
                    if(data.code == 1){
                        setTimeout(function () {
                            window.location.href=&amp;quot;/&amp;quot;
                        },1000)
                    }
                },
                error:function (data,status) {
                    alert(&amp;quot;err:&amp;quot;+data.message+&amp;quot;:&amp;quot;+status)
                }
            });
        }
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;26-项目运行&#34;&gt;2.6 项目运行&lt;/h3&gt;
&lt;p&gt;启动项目后，打开浏览器输入以下访问路径：&lt;a href=&#34;http://127.0.0.1:8080/login&#34;&gt;http://127.0.0.1:8080/login&lt;/a&gt; 然后输入用户名和密码，并且登录，页面返回信息依次如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190520-090352@2x.png&#34; alt=&#34;用户登录&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190520-090526@2x.png&#34; alt=&#34;登录成功内容提示&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;三-项目session处理&#34;&gt;三 项目Session处理&lt;/h2&gt;
&lt;h3 id=&#34;31-session使用场景介绍&#34;&gt;3.1 Session使用场景介绍&lt;/h3&gt;
&lt;p&gt;我们希望用户登录后可以有写博客的功能，当然也允许用户退出：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190521-104344@2x.png&#34; alt=&#34;写博客功能&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果用户没有登录，直接访问首页，只可以查看文章，标签，相册等，但是没有写博客的功能：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190521-104814@2x.png&#34; alt=&#34;无权限写文章&#34;&gt;&lt;/p&gt;
&lt;p&gt;实现该功能的操作需要使用session。&lt;/p&gt;
&lt;h3 id=&#34;32-sesion功能添加&#34;&gt;3.2 Sesion功能添加&lt;/h3&gt;
&lt;h4 id=&#34;321-启用sesion功能&#34;&gt;3.2.1 启用Sesion功能&lt;/h4&gt;
&lt;p&gt;首先我们在登录的时候添加session。
先修改配置文件打开session，打开conf包下的app.conf文件，添加一行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;appname = myblog
httpport = 8080
runmode = dev

sessionon = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者在main.go中打开session：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	utils.InitMysql()
	beego.BConfig.WebConfig.Session.SessionOn = true // 打开session
	beego.Run()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;以上两个操作，选择一个即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;322-登录功能添加session处理&#34;&gt;3.2.2 登录功能添加Session处理&lt;/h4&gt;
&lt;p&gt;然后修改登录的Post方法，在登录的时候，我们设置session：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (this *LoginController) Post() {
	...
	if id &amp;gt; 0 {
		/*
		设置了session后悔将数据处理设置到cookie，然后再浏览器进行网络请求的时候回自动带上cookie
		因为我们可以通过获取这个cookie来判断用户是谁，这里我们使用的是session的方式进行设置
		 */
		this.SetSession(&amp;quot;loginuser&amp;quot;, username)
		this.Data[&amp;quot;json&amp;quot;] = map[string]interface{}{&amp;quot;code&amp;quot;: 1, &amp;quot;message&amp;quot;: &amp;quot;登录成功&amp;quot;}
	} else {
		this.Data[&amp;quot;json&amp;quot;] = map[string]interface{}{&amp;quot;code&amp;quot;: 0, &amp;quot;message&amp;quot;: &amp;quot;登录失败&amp;quot;}
	}
	this.ServeJSON()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;323-添加首页路由&#34;&gt;3.2.3 添加首页路由&lt;/h4&gt;
&lt;p&gt;接下来，我们新添加一个路由：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func init() {
    beego.Router(&amp;quot;/&amp;quot;, &amp;amp;controllers.HomeController{})
    beego.Router(&amp;quot;/register&amp;quot;, &amp;amp;controllers.RegisterController{})
    beego.Router(&amp;quot;/login&amp;quot;, &amp;amp;controllers.LoginController{})
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当访问/，这个根路径的时候，我们表示访问首页。&lt;/p&gt;
&lt;h4 id=&#34;324-添加首页控制器&#34;&gt;3.2.4 添加首页控制器&lt;/h4&gt;
&lt;p&gt;接下来创建一个新的Controller，HomeController，用于控制首页。但是在这之前，我们先设置一个父Controller用于获取session，查看用户是否登录。&lt;/p&gt;
&lt;p&gt;先创建一个go文件：base_controller.go&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type BaseController struct {
	beego.Controller
	IsLogin   bool
	Loginuser interface{}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先定义个BaseController，里面额外设置两个字段，IsLogin表示用户是否登录，Loginuser表示用户名。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//判断是否登录
func (this *BaseController) Prepare() {
	loginuser := this.GetSession(&amp;quot;loginuser&amp;quot;)
	fmt.Println(&amp;quot;loginuser----&amp;gt;&amp;quot;, loginuser)
	if loginuser != nil {
		this.IsLogin = true
		this.Loginuser = loginuser
	} else {
		this.IsLogin = false
	}
	this.Data[&amp;quot;IsLogin&amp;quot;] = this.IsLogin
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下类，重写Prepare()方法，用于获取session。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//判断是否登录
func (this *BaseController) Prepare() {
	loginuser := this.GetSession(&amp;quot;loginuser&amp;quot;)
	fmt.Println(&amp;quot;loginuser----&amp;gt;&amp;quot;, loginuser)
	if loginuser != nil {
		this.IsLogin = true
		this.Loginuser = loginuser
	} else {
		this.IsLogin = false
	}
	this.Data[&amp;quot;IsLogin&amp;quot;] = this.IsLogin
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个函数主要是为了用户扩展用的，这个函数会在下面定义的这些 Method 方法之前执行，用户可以重写这个函数实现类似用户验证之类。然后再创建一个home_controller.go文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type HomeController struct {
	//beego.Controller
	BaseController
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在Get()方法 中，渲染home页面即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (this *HomeController)Get(){
	fmt.Println(&amp;quot;IsLogin:&amp;quot;,this.IsLogin,this.Loginuser)
	this.TplName=&amp;quot;home.html&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;325-视图层开发&#34;&gt;3.2.5 视图层开发&lt;/h4&gt;
&lt;p&gt;我们需要如下几个功能：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190521-111948@2x.png&#34; alt=&#34;导航栏&#34;&gt;
后续的每个页面都有这几个功能。所以我们可以让页面嵌套。&lt;/p&gt;
&lt;h5 id=&#34;3251-导航栏布局&#34;&gt;3.2.5.1 导航栏布局&lt;/h5&gt;
&lt;p&gt;现在views目录下创建一个子目录block，里面创建一个html页面：nav.html，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;nav&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;nav-write-article&amp;quot;&amp;gt;
        &amp;lt;ul&amp;gt;
        {{/*如果已经登录，才会显示&amp;quot;写博客&amp;quot;*/}}
        {{if .IsLogin}}
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/article/add&amp;quot;&amp;gt;写博客&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        {{end}}
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;


    &amp;lt;div id=&amp;quot;nav-menu&amp;quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/&amp;quot;&amp;gt;首页&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/tags&amp;quot;&amp;gt;标签&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/album&amp;quot;&amp;gt;相册&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/#&amp;quot;&amp;gt;关于我&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;


    &amp;lt;div id=&amp;quot;nav-login&amp;quot;&amp;gt;
        &amp;lt;ul&amp;gt;
        {{if .IsLogin}}
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;退出&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        {{else}}
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/login&amp;quot;&amp;gt;登录&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/register&amp;quot;&amp;gt;注册&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        {{end}}
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;

&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然这里需要判断用户是否登录，如果登录，显示写博客功能，以及可以退出。否则显示登录或注册。&lt;/p&gt;
&lt;h5 id=&#34;3252-首页视图homehtml&#34;&gt;3.2.5.2 首页视图home.html&lt;/h5&gt;
&lt;p&gt;接下来，我们创建一个新的页面：&lt;strong&gt;home.html&lt;/strong&gt;，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;首页&amp;lt;/title&amp;gt;
    &amp;lt;link href=&amp;quot;../static/css/blogsheet.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
{{template &amp;quot;block/nav.html&amp;quot; .}}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过页面的嵌套，我们可以将标签显示到home页面上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;特别注意，{{template &amp;quot;block/nav.html&amp;quot; .}}，后面的&lt;code&gt;.&lt;/code&gt;，这是传递当前参数到子模板&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;3253-适配已有视图文件&#34;&gt;3.2.5.3 适配已有视图文件&lt;/h5&gt;
&lt;p&gt;同样，我们将之前的login.html页面和register.html页面，也将nav嵌套进来，代码如下：&lt;/p&gt;
&lt;p&gt;login.html&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;登录&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;../static/css/lib/login.css&amp;quot;&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;../static/css/blogsheet.css&amp;quot;&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/lib/jquery-3.3.1.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/lib/jquery.url.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/blog.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;!--
&amp;lt;div id=&amp;quot;nav&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;nav-login&amp;quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/login&amp;quot;&amp;gt;登录&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/register&amp;quot;&amp;gt;注册&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;

    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
--&amp;gt;
{{template &amp;quot;block/nav.html&amp;quot;}}

&amp;lt;div class=&amp;quot;htmleaf-container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;wrapper&amp;quot;&amp;gt;
    {{/*注册表单*/}}
        &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
            &amp;lt;h1&amp;gt;Welcome&amp;lt;/h1&amp;gt;
            &amp;lt;form id=&amp;quot;login-form&amp;quot; class=&amp;quot;form&amp;quot;&amp;gt;
                &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; placeholder=&amp;quot;请输入用户名&amp;quot;&amp;gt;
                &amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot; placeholder=&amp;quot;请输入密码&amp;quot; id=&amp;quot;login-password&amp;quot;&amp;gt;
                &amp;lt;br&amp;gt;
                &amp;lt;button type=&amp;quot;submit&amp;quot; id=&amp;quot;login-button&amp;quot;&amp;gt;登录&amp;lt;/button&amp;gt;
            &amp;lt;/form&amp;gt;
        &amp;lt;/div&amp;gt;

    {{/*背景动画*/}}
        &amp;lt;ul class=&amp;quot;bg-bubbles&amp;quot;&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;register.html&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;注册&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;../static/css/lib/login.css&amp;quot;&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;../static/css/blogsheet.css&amp;quot;&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/lib/jquery-3.3.1.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/lib/jquery.url.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/blog.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;!--
&amp;lt;div id=&amp;quot;nav&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;nav-login&amp;quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/login&amp;quot;&amp;gt;登录&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/register&amp;quot;&amp;gt;注册&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;

        &amp;lt;/ul&amp;gt;

    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
--&amp;gt;

{{template &amp;quot;block/nav.html&amp;quot;}}

&amp;lt;div class=&amp;quot;htmleaf-container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;wrapper&amp;quot;&amp;gt;
    {{/*注册表单*/}}
        &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
            &amp;lt;h1&amp;gt;Welcome&amp;lt;/h1&amp;gt;
            &amp;lt;form id=&amp;quot;register-form&amp;quot; class=&amp;quot;form&amp;quot;&amp;gt;
                &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; placeholder=&amp;quot;Username&amp;quot;&amp;gt;
                &amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot; placeholder=&amp;quot;Password&amp;quot; id=&amp;quot;register-password&amp;quot;&amp;gt;
                &amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;repassword&amp;quot; placeholder=&amp;quot;rePassword&amp;quot;&amp;gt;
                &amp;lt;br&amp;gt;
                &amp;lt;button type=&amp;quot;submit&amp;quot; id=&amp;quot;login-button&amp;quot;&amp;gt;Register&amp;lt;/button&amp;gt;
            &amp;lt;/form&amp;gt;
        &amp;lt;/div&amp;gt;

    {{/*背景动画*/}}
        &amp;lt;ul class=&amp;quot;bg-bubbles&amp;quot;&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;326-添加退出脚本&#34;&gt;3.2.6 添加退出脚本&lt;/h4&gt;
&lt;p&gt;我们先在nav.html页面中，添加退出的脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;    &amp;lt;div id=&amp;quot;nav-login&amp;quot;&amp;gt;
        &amp;lt;ul&amp;gt;
        {{if .IsLogin}}
            &amp;lt;li&amp;gt;&amp;lt;a href=&#39;javascript:if(confirm(&amp;quot;确定退出吗？&amp;quot;)){location=&amp;quot;/exit&amp;quot;}&#39;&amp;gt;退出&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        {{else}}
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/login&amp;quot;&amp;gt;登录&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/register&amp;quot;&amp;gt;注册&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        {{end}}
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;326-添加退出路由&#34;&gt;3.2.6 添加退出路由&lt;/h4&gt;
&lt;p&gt;然后重新注册一个路由，用于处理退出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func init() {
    beego.Router(&amp;quot;/&amp;quot;, &amp;amp;controllers.HomeController{})
    //注册
    beego.Router(&amp;quot;/register&amp;quot;, &amp;amp;controllers.RegisterController{})
    //登录
    beego.Router(&amp;quot;/login&amp;quot;, &amp;amp;controllers.LoginController{})
    //退出
	beego.Router(&amp;quot;/exit&amp;quot;, &amp;amp;controllers.ExitController{})

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;327-添加退出功能控制器&#34;&gt;3.2.7 添加退出功能控制器&lt;/h4&gt;
&lt;p&gt;然后再创建一个go文件：exit_controller.go&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package controllers

type ExitController struct {
	BaseController
}

func (this *ExitController)Get(){
	//清除该用户登录状态的数据
	this.DelSession(&amp;quot;loginuser&amp;quot;)
	this.Redirect(&amp;quot;/&amp;quot;,302)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;清除session后，重定位到/路径上。&lt;/p&gt;
&lt;h4 id=&#34;328-项目运行&#34;&gt;3.2.8 项目运行&lt;/h4&gt;
&lt;p&gt;我们重启项目后，打来浏览器输入网址：&lt;a href=&#34;http://127.0.0.1:8080/&#34;&gt;http://127.0.0.1:8080/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;浏览器如下：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190521-113931@2x.png&#34; alt=&#34;浏览器效果&#34;&gt;&lt;/p&gt;
&lt;p&gt;服务器端运行如下：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190521-114207@2x.png&#34; alt=&#34;后台程序日志&#34;&gt;&lt;/p&gt;
&lt;p&gt;点击退出按钮，后台程序执行效果：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190521-135733@2x.png&#34; alt=&#34;退户功能日志&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E6%A1%86%E6%9E%B6/">框架</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>写文章、项目首页和查看文章详情功能开发</title>
                <link>http://www.songx.fun/blog/day38-41beego%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/day39_%E5%86%99%E6%96%87%E7%AB%A0%E9%A1%B9%E7%9B%AE%E9%A6%96%E9%A1%B5%E5%92%8C%E6%9F%A5%E7%9C%8B%E6%96%87%E7%AB%A0%E8%AF%A6%E6%83%85%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day38-41beego%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/day39_%E5%86%99%E6%96%87%E7%AB%A0%E9%A1%B9%E7%9B%AE%E9%A6%96%E9%A1%B5%E5%92%8C%E6%9F%A5%E7%9C%8B%E6%96%87%E7%AB%A0%E8%AF%A6%E6%83%85%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;写文章项目首页和查看文章详情功能开发&#34;&gt;写文章、项目首页和查看文章详情功能开发&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点击写文章，我们进入写文章的页面，当用户点击按钮进行提交后，应该将文章的数据存入到数据库中。&lt;/p&gt;
&lt;h2 id=&#34;一-写文章功能开发&#34;&gt;一 写文章功能开发&lt;/h2&gt;
&lt;h3 id=&#34;11-数据库表设计&#34;&gt;1.1 数据库表设计&lt;/h3&gt;
&lt;p&gt;首先我们先设计数据库，用户提交的文章，包含标题，标签，简介，内容， 创建时间等。
在mysqlUtils.go文件中，添加article表的操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//创建文章表
func CreateTableWithArticle(){
	sql:=`create table if not exists article(
		id int(4) primary key auto_increment not null,
		title varchar(30),
		author varchar(20),
		tags varchar(30),
		short varchar(255),
		content longtext,
		createtime int(10)
		);`
	ModifyDB(sql)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-model层实现&#34;&gt;1.2 model层实现&lt;/h3&gt;
&lt;h4 id=&#34;121-文章结构体定义&#34;&gt;1.2.1 文章结构体定义&lt;/h4&gt;
&lt;p&gt;在model目录下创建一个go文件：article_model.go&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package models

import &amp;quot;myblog/utils&amp;quot;

type Article struct {
	Id         int
	Title      string
	Tags       string
	Short      string
	Content    string
	Author     string
	Createtime int64
	//Status int //Status=0为正常，1为删除，2为冻结
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;122-添加文章及数据库操作&#34;&gt;1.2.2 添加文章及数据库操作&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//---------数据处理-----------
func AddArticle(article Article) (int64, error) {
	i, err := insertArticle(article)
	return i, err
}

//-----------数据库操作---------------
//插入一篇文章
func insertArticle(article Article) (int64, error) {
	return utils.ModifyDB(&amp;quot;insert into article(title,tags,short,content,author,createtime) values(?,?,?,?,?,?)&amp;quot;,
		article.Title, article.Tags, article.Short, article.Content, article.Author, article.Createtime)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目前我们只是写文章，所以需要的是添加数据。&lt;/p&gt;
&lt;h3 id=&#34;13-控制器层&#34;&gt;1.3 控制器层&lt;/h3&gt;
&lt;h4 id=&#34;131-添加文章控制器定义&#34;&gt;1.3.1 添加文章控制器定义&lt;/h4&gt;
&lt;p&gt;首先创建一个controller文件，add_article_controller.go。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package controllers
import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;myblog/models&amp;quot;
	&amp;quot;time&amp;quot;
)
type AddArticleController struct {
	BaseController
}
/*
当访问/add路径的时候回触发AddArticleController的Get方法
响应的页面是通过TpName
 */
func (this *AddArticleController) Get() {
	this.TplName = &amp;quot;write_article.html&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;132-控制器实现添加文章逻辑处理&#34;&gt;1.3.2 控制器实现添加文章逻辑处理&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//通过this.ServerJSON()这个方法去返回json字符串
func (this *AddArticleController) Post() {

	//获取浏览器传输的数据，通过表单的name属性获取值
	title := this.GetString(&amp;quot;title&amp;quot;)
	tags := this.GetString(&amp;quot;tags&amp;quot;)
	short := this.GetString(&amp;quot;short&amp;quot;)
	content := this.GetString(&amp;quot;content&amp;quot;)
	fmt.Printf(&amp;quot;title:%s,tags:%s\n&amp;quot;, title, tags)

	//实例化model，将它出入到数据库中
	art := models.Article{0, title, tags, short, content, &amp;quot;千锋教育&amp;quot;, time.Now().Unix()}
	_, err := models.AddArticle(art)

	//返回数据给浏览器
	var response map[string]interface{}
	if err == nil {
		//无误
		response = map[string]interface{}{&amp;quot;code&amp;quot;: 1, &amp;quot;message&amp;quot;: &amp;quot;ok&amp;quot;}
	} else {
		response = map[string]interface{}{&amp;quot;code&amp;quot;: 0, &amp;quot;message&amp;quot;: &amp;quot;error&amp;quot;}
	}

	this.Data[&amp;quot;json&amp;quot;] = response
	this.ServeJSON()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果用户请求写文章路径，会展示write_article.html页面。添加完信息后，点击提交按钮，进行提交数据。&lt;/p&gt;
&lt;h3 id=&#34;14-注册添加文章路由&#34;&gt;1.4 注册添加文章路由&lt;/h3&gt;
&lt;p&gt;然后注册一个新的路由：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//写文章
beego.Router(&amp;quot;/article/add&amp;quot;, &amp;amp;controllers.AddArticleController{})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;15-视图层开发&#34;&gt;1.5 视图层开发&lt;/h3&gt;
&lt;h4 id=&#34;151-新建write_articlehtml文件&#34;&gt;1.5.1 新建write_article.html文件&lt;/h4&gt;
&lt;p&gt;我们在views目录下创建一个html文件(write_article.html)，用于写文章。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;写文章&amp;lt;/title&amp;gt;
    &amp;lt;link href=&amp;quot;../static/css/blogsheet.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/lib/jquery-3.3.1.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/lib/jquery.url.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/blog.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

{{template &amp;quot;block/nav.html&amp;quot; .}}

&amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;
    &amp;lt;form id=&amp;quot;write-art-form&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
        &amp;lt;div&amp;gt;标题&amp;lt;/div&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; placeholder=&amp;quot;请输入标题&amp;quot; name=&amp;quot;title&amp;quot; &amp;gt;
        &amp;lt;div&amp;gt;标签&amp;lt;/div&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; placeholder=&amp;quot;请输入标签&amp;quot; name=&amp;quot;tags&amp;quot; &amp;gt;
        &amp;lt;div&amp;gt;简介&amp;lt;/div&amp;gt;
        &amp;lt;textarea placeholder=&amp;quot;请输入简介&amp;quot; name=&amp;quot;short&amp;quot;&amp;gt;&amp;lt;/textarea&amp;gt;
        &amp;lt;div&amp;gt;内容&amp;lt;/div&amp;gt;
        &amp;lt;textarea id=&amp;quot;content&amp;quot; placeholder=&amp;quot;请输入内容&amp;quot; name=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/textarea&amp;gt;
        &amp;lt;input id=&amp;quot;write-article-id&amp;quot; hidden name=&amp;quot;id&amp;quot; &amp;gt;
        &amp;lt;br&amp;gt;
        &amp;lt;button type=&amp;quot;button&amp;quot; onclick=&amp;quot;history.back()&amp;quot;&amp;gt;返回&amp;lt;/button&amp;gt;
        &amp;lt;button type=&amp;quot;submit&amp;quot; id=&amp;quot;write-art-submit&amp;quot;&amp;gt;提交&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;152-编写js文件实现添加文章功能&#34;&gt;1.5.2 编写js文件实现添加文章功能&lt;/h4&gt;
&lt;p&gt;接下来写js脚本文件，打开static/js目录下的blog.js文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;	//添加文章的表单
    $(&amp;quot;#write-art-form&amp;quot;).validate({
        rules: {
            title: &amp;quot;required&amp;quot;,
            tags: &amp;quot;required&amp;quot;,
            short: {
                required: true,
                minlength: 2
            },
            content: {
                required: true,
                minlength: 2
            }
        },
        messages: {
            title: &amp;quot;请输入标题&amp;quot;,
            tags: &amp;quot;请输入标签&amp;quot;,
            short: {
                required: &amp;quot;请输入简介&amp;quot;,
                minlength: &amp;quot;简介内容最少两个字符&amp;quot;
            },
            content: {
                required: &amp;quot;请输入文章内容&amp;quot;,
                minlength: &amp;quot;文章内容最少两个字符&amp;quot;
            }
        },
        submitHandler: function (form) {
            var urlStr = &amp;quot;/article/add&amp;quot;;
            alert(&amp;quot;urlStr:&amp;quot; + urlStr);
            $(form).ajaxSubmit({
                url: urlStr,
                type: &amp;quot;post&amp;quot;,
                dataType: &amp;quot;json&amp;quot;,
                success: function (data, status) {
                    alert(&amp;quot;:data:&amp;quot; + data.message);
                    setTimeout(function () {
                        window.location.href = &amp;quot;/&amp;quot;
                    }, 1000)
                },
                error: function (data, status) {
                    alert(&amp;quot;err:&amp;quot; + data.message + &amp;quot;:&amp;quot; + status)
                }
            });
        }
    })
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;16-项目运行&#34;&gt;1.6 项目运行&lt;/h3&gt;
&lt;p&gt;运行项目后，打开浏览器，登录后进入首页，点击写文章：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190521-145856@2x.png&#34; alt=&#34;写博客功能入口&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后进入写文章页面：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190521-150025@2x.png&#34; alt=&#34;写文章详情&#34;&gt;&lt;/p&gt;
&lt;p&gt;点击按钮进行提交，然后查询数据库，数据已经被插入进去了。&lt;/p&gt;
&lt;h2 id=&#34;二-项目首页功能实现&#34;&gt;二 项目首页功能实现&lt;/h2&gt;
&lt;p&gt;在上节课内容中，我们学习实现了写文章的功能。本节课，我们要实现首页功能的开发。首页是用户登录后要展示的页面。最终想实现的功能是：点击首页，就会自动查询数据库，显示文章；如果文章较多，我们可以实现分页。&lt;/p&gt;
&lt;h3 id=&#34;21-查询文章功能&#34;&gt;2.1 查询文章功能&lt;/h3&gt;
&lt;h4 id=&#34;211-查询文章控制器&#34;&gt;2.1.1 查询文章控制器&lt;/h4&gt;
&lt;p&gt;我们首先修改home_controller.go文件，在Get()方法中，先查询所有的文章，并显示到页面上。因为文章可能很多，为了更好的用户体验，我们需要分页查询。默认查询第一页。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (this *HomeController) Get() {
	page, _ := this.GetInt(&amp;quot;page&amp;quot;)
	if page &amp;lt;= 0 {
		page = 1
	}
	var artList []models.Article
	artList, _ = models.FindArticleWithPage(page)
	this.Data[&amp;quot;PageCode&amp;quot;] = 1
	this.Data[&amp;quot;HasFooter&amp;quot;] = true
	fmt.Println(&amp;quot;IsLogin:&amp;quot;, this.IsLogin, this.Loginuser)
	this.Data[&amp;quot;Content&amp;quot;] = models.MakeHomeBlocks(artList, this.IsLogin)
	this.TplName = &amp;quot;home.html&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;212-model层处理&#34;&gt;2.1.2 model层处理&lt;/h4&gt;
&lt;p&gt;我们先在article_model.go文件中，添加文章的查询，而且要分页查询：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
//-----------查询文章---------

//根据页码查询文章
func FindArticleWithPage(page int) ([]Article, error) {
	//从配置文件中获取每页的文章数量
	num, _ := beego.AppConfig.Int(&amp;quot;articleListPageNum&amp;quot;)
	page--
	fmt.Println(&amp;quot;----------&amp;gt;page&amp;quot;, page)
	return QueryArticleWithPage(page, num)
}

/**
分页查询数据库
limit分页查询语句，
	语法：limit m，n

	m代表从多少位开始获取，与id值无关
	n代表获取多少条数据

注意limit前面咩有where
 */
func QueryArticleWithPage(page, num int) ([]Article, error) {
	sql := fmt.Sprintf(&amp;quot;limit %d,%d&amp;quot;, page*num, num)
	return QueryArticlesWithCon(sql)
}

func QueryArticlesWithCon(sql string) ([]Article, error) {
	sql = &amp;quot;select id,title,tags,short,content,author,createtime from article &amp;quot; + sql
	rows, err := utils.QueryDB(sql)
	if err != nil {
		return nil, err
	}
	var artList []Article
	for rows.Next() {
		id := 0
		title := &amp;quot;&amp;quot;
		tags := &amp;quot;&amp;quot;
		short := &amp;quot;&amp;quot;
		content := &amp;quot;&amp;quot;
		author := &amp;quot;&amp;quot;
		var createtime int64
		createtime = 0
		rows.Scan(&amp;amp;id, &amp;amp;title, &amp;amp;tags, &amp;amp;short, &amp;amp;content, &amp;amp;author, &amp;amp;createtime)
		art := Article{id, title, tags, short, content, author, createtime}
		artList = append(artList, art)
	}
	return artList, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;213-首页显示内容结构体定义&#34;&gt;2.1.3 首页显示内容结构体定义&lt;/h4&gt;
&lt;p&gt;在models目录下创建一个go文件，用来控制首页显示内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type HomeBlockParam struct {
	Id         int
	Title      string
	Tags       [] TagLink
	Short      string
	Content    string
	Author     string
	CreateTime string
	//查看文章的地址
	Link string

	//修改文章的地址
	UpdateLink string
	DeleteLink string

	//记录是否登录
	IsLogin bool
}
//标签链接
type TagLink struct {
	TagName string
	TagUrl  string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们需要将从数据库中查询出来的数据，转为对应的结构体对象，所以先设计结构体，这里我们需要考虑如果用户是登录状态，那么是可以修改或删除某一篇文章。当然，如果没有登录，那么只能查看。所以在设计结构体的时候，我们直接创建了修改和删除的链接字段。&lt;/p&gt;
&lt;h4 id=&#34;214-首页内容显示功能&#34;&gt;2.1.4 首页内容显示功能&lt;/h4&gt;
&lt;p&gt;接下来，我们添加一个方法，用于将文章中的内容，显示到页面上：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//----------首页显示内容---------
func MakeHomeBlocks(articles []Article, isLogin bool) template.HTML {
	htmlHome := &amp;quot;&amp;quot;
	for _, art := range articles {
		//将数据库model转换为首页模板所需要的model
		homeParam := HomeBlockParam{}
		homeParam.Id = art.Id
		homeParam.Title = art.Title
		homeParam.Tags = createTagsLinks(art.Tags)
		fmt.Println(&amp;quot;tag--&amp;gt;&amp;quot;, art.Tags)
		homeParam.Short = art.Short
		homeParam.Content = art.Content
		homeParam.Author = art.Author
		homeParam.CreateTime = utils.SwitchTimeStampToData(art.Createtime)
		homeParam.Link = &amp;quot;/article/&amp;quot; + strconv.Itoa(art.Id)
		homeParam.UpdateLink = &amp;quot;/article/update?id=&amp;quot; + strconv.Itoa(art.Id)
		homeParam.DeleteLink = &amp;quot;/article/delete?id=&amp;quot; + strconv.Itoa(art.Id)
		homeParam.IsLogin = isLogin

		//处理变量
		//ParseFile解析该文件，用于插入变量
		t, _ := template.ParseFiles(&amp;quot;views/block/home_block.html&amp;quot;)
		buffer := bytes.Buffer{}
		//就是将html文件里面的比那两替换为穿进去的数据
		t.Execute(&amp;amp;buffer, homeParam)
		htmlHome += buffer.String()
	}
	fmt.Println(&amp;quot;htmlHome--&amp;gt;&amp;quot;,htmlHome)
	return template.HTML(htmlHome)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;额外还需要一个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
//将tags字符串转化成首页模板所需要的数据结构
func createTagsLinks(tags string) []TagLink {
	var tagLink [] TagLink
	tagsPamar := strings.Split(tags, &amp;quot;&amp;amp;&amp;quot;)
	for _, tag := range tagsPamar {
		tagLink = append(tagLink, TagLink{tag, &amp;quot;/?tag=&amp;quot; + tag})
	}
	return tagLink
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;214-视图层开发&#34;&gt;2.1.4 视图层开发&lt;/h4&gt;
&lt;p&gt;接下来我们设计一下页面，刚刚在model的MakeHomeBlocks()方法中，就是需要使用模板填充格式化html页面内容，所以我们在views/block下再创建一个html页面：home_block.html，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;home-block-item&amp;quot;&amp;gt;
    &amp;lt;h2&amp;gt;&amp;lt;a href=&amp;quot;{{.Link}}&amp;quot;&amp;gt;{{.Title}}&amp;lt;/a&amp;gt;&amp;lt;/h2&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;span&amp;gt;{{.CreateTime}}&amp;lt;/span&amp;gt;
        &amp;lt;span&amp;gt;
        {{range .Tags}}
            &amp;lt;a href=&amp;quot;{{.TagUrl}}&amp;quot;&amp;gt;&amp;amp;nbsp{{.TagName}}&amp;lt;/a&amp;gt;
        {{end}}
        &amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;a href={{.Link}}&amp;gt;{{.Short}}&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
{{if .IsLogin}}
    &amp;lt;div class=&amp;quot;home-block-item-udpate&amp;quot;&amp;gt;
        &amp;lt;a href=&#39;javascript:if(confirm(&amp;quot;确定删除吗？&amp;quot;)){location=&amp;quot;{{.DeleteLink}}&amp;quot;}&#39;&amp;gt;删除&amp;lt;/a&amp;gt;
        &amp;lt;a href={{.UpdateLink}}&amp;gt;修改&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
{{end}}
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们现实了从数据中查询出的文章的数据，如果用户是登录状态，那么我们现实删除和修改，因为用户有这两个权限，否则就不显示。&lt;/p&gt;
&lt;h4 id=&#34;215-项目运行&#34;&gt;2.1.5 项目运行&lt;/h4&gt;
&lt;h5 id=&#34;2151-准备测试数据&#34;&gt;2.1.5.1 准备测试数据&lt;/h5&gt;
&lt;p&gt;我们在数据库中插入10条数据：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-113706@2x.png&#34; alt=&#34;数据库的数据&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;2151-页面显示数据条数配置&#34;&gt;2.1.5.1 页面显示数据条数配置&lt;/h5&gt;
&lt;p&gt;接下来我们设置一下配置文件，每页显示6条(也可以8条，10条。。)，
修改conf目录下的app.conf文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;appname = myblog
httpport = 8080
runmode = dev

#mysql配置
driverName = mysql
mysqluser = root
mysqlpwd = yu271400
host = 127.0.0.1
port = 3306
dbname = myblog

#Session
sessionon = true
sessionprovider = &amp;quot;file&amp;quot;
sessionname = &amp;quot;qianfengjiaoyumyblog&amp;quot;
sessiongcmaxlifetime = 1800
sessionproviderconfig = &amp;quot;./tmp&amp;quot;
sessioncookielifetime = 1800

articleListPageNum = 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后启动项目，打开浏览器输入网址：&lt;a href=&#34;http://127.0.0.1:8080/&#34;&gt;http://127.0.0.1:8080/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-141320@2x.png&#34; alt=&#34;未登录首页效果&#34;&gt;&lt;/p&gt;
&lt;p&gt;用户虽然没有登录，但是也是可以查看的，接下来我们点击登录按钮进行登录：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-141446@2x.png&#34; alt=&#34;登录后首页效果&#34;&gt;
登录后，用户就可以有删除和修改的功能了。&lt;/p&gt;
&lt;h3 id=&#34;22-文章分页展示功能&#34;&gt;2.2 文章分页展示功能&lt;/h3&gt;
&lt;p&gt;截止，我们已经已经能够显示出第一页的内容了，接下来我们添加上一页和下一页的功能。&lt;/p&gt;
&lt;h4 id=&#34;221-分页结构体定义&#34;&gt;2.2.1 分页结构体定义&lt;/h4&gt;
&lt;p&gt;首先在home_model.go中添加一个分页的结构体对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type HomeFooterPageCode struct {
	HasPre bool
	HasNext bool
	ShowPage string
	PreLink string
	NextLink string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;222-查询文章及修改方法&#34;&gt;2.2.2 查询文章及修改方法&lt;/h4&gt;
&lt;p&gt;接下来添加方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//-----------翻页-----------
//page是当前的页数
func ConfigHomeFooterPageCode(page int) HomeFooterPageCode {
	pageCode := HomeFooterPageCode{}
	//查询出总的条数
	num := GetArticleRowsNum()
	//从配置文件中读取每页显示的条数
	pageRow, _ := beego.AppConfig.Int(&amp;quot;articleListPageNum&amp;quot;)
	//计算出总页数
	allPageNum := (num-1)/pageRow + 1
	pageCode.ShowPage = fmt.Sprintf(&amp;quot;%d/%d&amp;quot;, page, allPageNum)
	//当前页数小于等于1，那么上一页的按钮不能点击
	if page &amp;lt;= 1 {
		pageCode.HasPre = false
	} else {
		pageCode.HasPre = true
	}
	//当前页数大于等于总页数，那么下一页的按钮不能点击
	if page &amp;gt;= allPageNum {
		pageCode.HasNext = false
	} else {
		pageCode.HasNext = true
	}
	pageCode.PreLink = &amp;quot;/?page=&amp;quot; + strconv.Itoa(page-1)
	pageCode.NextLink = &amp;quot;/?page=&amp;quot; + strconv.Itoa(page+1)
	return pageCode
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码需要查询出数据库中所有文章的总量，所以我们要先在article_model.go文件中，加入查询总数据量的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//------翻页------
//存储表的行数，只有自己可以更改，当文章新增或者删除时需要更新这个值
var artcileRowsNum = 0
//只有首次获取行数的时候采取统计表里的行数
func GetArticleRowsNum() int {
	if artcileRowsNum == 0 {
		artcileRowsNum = QueryArticleRowNum()
	}
	return artcileRowsNum
}

//查询文章的总条数
func QueryArticleRowNum() int {
	row := utils.QueryRowDB(&amp;quot;select count(id) from article&amp;quot;)
	num := 0
	row.Scan(&amp;amp;num)
	return num
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们还要考虑一个问题，就是当新增或删除文章的时候，数据总量会发生改变，所以还要修改增加文章的方法：&lt;/p&gt;
&lt;p&gt;先新增一个方法用于设置总页数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//设置页数
func SetArticleRowsNum(){
	artcileRowsNum = QueryArticleRowNum()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后修改增加文章的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//---------添加文章-----------
func AddArticle(article Article) (int64, error) {
	i, err := insertArticle(article)
	SetArticleRowsNum()
	return i, err
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;223-首页控制器添加分页处理逻辑&#34;&gt;2.2.3 首页控制器添加分页处理逻辑&lt;/h4&gt;
&lt;p&gt;修改home_controller.go的Get()方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (this *HomeController) Get() {
	...
	artList, _ = models.FindArticleWithPage(page)
	this.Data[&amp;quot;PageCode&amp;quot;] = models.ConfigHomeFooterPageCode(page)
	this.Data[&amp;quot;HasFooter&amp;quot;] = true
	...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;224-修改首页视图添加分页控件&#34;&gt;2.2.4 修改首页视图添加分页控件&lt;/h4&gt;
&lt;p&gt;修改home.html页面：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;首页&amp;lt;/title&amp;gt;
    &amp;lt;link href=&amp;quot;../static/css/blogsheet.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
{{template &amp;quot;block/nav.html&amp;quot; .}}
&amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;
{{.Content}}
{{if .HasFooter}}
    &amp;lt;div id=&amp;quot;home-footer&amp;quot;&amp;gt;
        &amp;lt;a {{if .PageCode.HasPre}}href=&amp;quot;{{.PageCode.PreLink}}&amp;quot; {{else}} class=&amp;quot;disable&amp;quot; {{end}}&amp;gt;上一页&amp;lt;/a&amp;gt;
        &amp;lt;span&amp;gt;{{.PageCode.ShowPage}}页&amp;lt;/span&amp;gt;
        &amp;lt;a {{if .PageCode.HasNext}}href=&amp;quot;{{.PageCode.NextLink}}&amp;quot; {{else}} class=&amp;quot;disable&amp;quot; {{end}}&amp;gt;下一页&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
{{end}}
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;增添上一页，下一页的链接。&lt;/p&gt;
&lt;h4 id=&#34;225-项目运行&#34;&gt;2.2.5 项目运行&lt;/h4&gt;
&lt;p&gt;首先我们再向数据库中插入5条数据，然后修改配置文件，每页显示5条。
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-141839@2x.png&#34; alt=&#34;分页展示&#34;&gt;
接下来，我们新增加一篇文章，点击写博客：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-142111@2x.png&#34; alt=&#34;编写新文章&#34;&gt;
最后一页显示为我们刚刚增加的一篇文章，截止到现在我们可以很完美的显示页码了。&lt;/p&gt;
&lt;h2 id=&#34;三-文章详情功能开发&#34;&gt;三 文章详情功能开发&lt;/h2&gt;
&lt;p&gt;上节课内容我们实现了项目主页的文章列表功能和分页功能。本节课继续进行开发实现，当点击文章的时候，应该显示文章的详细内容。&lt;/p&gt;
&lt;h3 id=&#34;31-查看文章详情&#34;&gt;3.1 查看文章详情&lt;/h3&gt;
&lt;h4 id=&#34;311-添加路由设置&#34;&gt;3.1.1 添加路由设置&lt;/h4&gt;
&lt;p&gt;首先先设置路由：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func init() {
    ...
	//写文章
	beego.Router(&amp;quot;/article/add&amp;quot;, &amp;amp;controllers.AddArticleController{})
	//显示文章内容
	beego.Router(&amp;quot;/article/:id&amp;quot;, &amp;amp;controllers.ShowArticleController{})
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;312-添加控制器和逻辑实现&#34;&gt;3.1.2 添加控制器和逻辑实现&lt;/h4&gt;
&lt;p&gt;然后再controllers目录下创建一个go文件，show_article_controller.go：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ShowArticleController struct {
	//beego.Controller
	BaseController
}

func (this *ShowArticleController) Get() {
	idStr := this.Ctx.Input.Param(&amp;quot;:id&amp;quot;)
	id, _ := strconv.Atoi(idStr)
	fmt.Println(&amp;quot;id:&amp;quot;, id)
	//获取id所对应的文章信息
	art := models.QueryArticleWithId(id)
	this.Data[&amp;quot;Title&amp;quot;] = art.Title
	this.Data[&amp;quot;Content&amp;quot;] = art.Content
	//this.Data[&amp;quot;Content&amp;quot;] = utils.SwitchMarkdownToHtml(art.Content)
	this.TplName=&amp;quot;show_article.html&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;313-修改model添加查询方法&#34;&gt;3.1.3 修改model，添加查询方法&lt;/h4&gt;
&lt;p&gt;接下来在article_model.go文件中，添加方法，根据id查询文章：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//----------查询文章-------------
func QueryArticleWithId(id int) Article {
	row := utils.QueryRowDB(&amp;quot;select id,title,tags,short,content,author,createtime from article where id=&amp;quot; + strconv.Itoa(id))
	title := &amp;quot;&amp;quot;
	tags := &amp;quot;&amp;quot;
	short := &amp;quot;&amp;quot;
	content := &amp;quot;&amp;quot;
	author := &amp;quot;&amp;quot;
	var createtime int64
	createtime = 0
	row.Scan(&amp;amp;id, &amp;amp;title, &amp;amp;tags, &amp;amp;short, &amp;amp;content, &amp;amp;author, &amp;amp;createtime)
	art := Article{id, title, tags, short, content, author, createtime}
	return art
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;314-创建文章详情视图&#34;&gt;3.1.4 创建文章详情视图&lt;/h4&gt;
&lt;p&gt;接下来我们创建view，在views目录下，新建html页面文件，show_article.html：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;{{.Title}}&amp;lt;/title&amp;gt;
    &amp;lt;link href=&amp;quot;../static/css/blogsheet.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
{{template &amp;quot;block/nav.html&amp;quot; .}}
&amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;
    &amp;lt;h1&amp;gt;{{.Title}}&amp;lt;/h1&amp;gt;
    &amp;lt;div&amp;gt;{{.Content}}&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;315-项目运行&#34;&gt;3.1.5 项目运行&lt;/h4&gt;
&lt;p&gt;接下来我们重启项目，并刷新页面,并点击一篇文章：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-144626@2x.png&#34; alt=&#34;文章详情&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;32-开发支持markdown格式&#34;&gt;3.2 开发支持Markdown格式&lt;/h3&gt;
&lt;p&gt;虽然页面能够显示文章内容，但是看着很不舒服，一锅粥一样，我们通过markdown语法格式显示。&lt;/p&gt;
&lt;h4 id=&#34;321-markdown语法功能相关库&#34;&gt;3.2.1 markdown语法功能相关库&lt;/h4&gt;
&lt;p&gt;我们先了解一下，在进行项目开发前先熟悉下我们需要用到的库。包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;转换Markdown语法：russross/blackfriday&lt;/li&gt;
&lt;li&gt;查找Document的内容：PuerkitoBio/goquery&lt;/li&gt;
&lt;li&gt;语法高亮：sourcegraph/syntaxhighlight&lt;/li&gt;
&lt;li&gt;插入模块：html/template&lt;/li&gt;
&lt;li&gt;执行外部命令：os/exec&lt;/li&gt;
&lt;li&gt;文件操作：path/filepath&lt;/li&gt;
&lt;li&gt;创建Web服务器：SimpleHTTPServer&lt;/li&gt;
&lt;li&gt;解析.yml配置文件：gopkg.in/yaml.v2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先需要安装markdown的安装包：
打开终端输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go get github.com/russross/blackfriday
go get github.com/PuerkitoBio/goquery
go get github.com/sourcegraph/syntaxhighlight
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;322-工具库源码&#34;&gt;3.2.2 工具库源码&lt;/h4&gt;
&lt;p&gt;安装之后也可以到src目录下查看:
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-144232@2x.png&#34; alt=&#34;查看工具库下载&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;33-语法介绍&#34;&gt;3.3 语法介绍&lt;/h3&gt;
&lt;h4 id=&#34;331-russrossblackfriday包&#34;&gt;3.3.1 russross/blackfriday包&lt;/h4&gt;
&lt;p&gt;第三方库russross/blackfriday用于在golang中使用markdown语法。
&lt;strong&gt;markdown&lt;/strong&gt;: 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。
Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。
test.md：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;## 一、russross/blackfriday包
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	fileread, _ := ioutil.ReadFile(&amp;quot;extra/blackfriday转换markdown/test.md&amp;quot;)
	//转换Markdown语法，如将&amp;quot;#&amp;quot;转换为&amp;quot;&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;&amp;quot;
	subHtml := blackfriday.MarkdownCommon(fileread)
	subHtmlStr := string(subHtml)
	fmt.Println(subHtmlStr)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;h2&amp;gt;一、russross/blackfriday包&amp;lt;/h2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;332-puerkitobiogoquery包&#34;&gt;3.3.2 PuerkitoBio/goquery包&lt;/h4&gt;
&lt;p&gt;做过 Web 开发的，应该都用过或听过 jQuery，它提供了方便的操作 DOM 的 API。使用 Go 语言做服务器端开发，有时候需要解析 HTML 文件，比如抓取网站内容、写一个爬虫等。这时候如果有一个类似 jQuery 的库可以使用，操作 DOM 会很方便，而且，上手也会很快。&lt;code&gt;PuerkitoBio/goquery&lt;/code&gt; 这个库就实现了类似 jQuery 的功能，让你能方便的使用 Go 语言操作 HTML 文档。
该库提供的类型很少，但方法却很多，我们不可能一个个方法讲解。这里通过模拟几个使用场景来讲解该库的使用。&lt;/p&gt;
&lt;h5 id=&#34;3321-document&#34;&gt;3.3.2.1 Document&lt;/h5&gt;
&lt;p&gt;Document 代表一个将要被操作的 HTML 文档，不过，和 jQuery 不同，它装载的是 DOM 文档的一部分。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Document struct {
	*Selection
	Url *url.URL
	rootNode *html.Node // 文档的根节点
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为 Document 中内嵌了一个 Selection 类型，因此，Document 可以直接使用 Selection 类型的方法。提供有五种方法获取一个 Document 实例。&lt;/p&gt;
&lt;h5 id=&#34;33212-selection&#34;&gt;3.3.2.1.2 Selection&lt;/h5&gt;
&lt;p&gt;Selection 代表符合特定条件的节点集合。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Selection struct {
	Nodes []*html.Node
	document *Document
	prevSel *Selection
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般地，得到了 Document 实例后，通过 Dcoument.Find 方法获取一个 Selection 实例，然后像 jQuery 一样使用链式语法和方法操作它。
Selection 类型提供的方法可以分为如下几大类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类似函数的位置操作&lt;/li&gt;
&lt;li&gt;扩大 Selection 集合（增加选择的节点）&lt;/li&gt;
&lt;li&gt;过滤方法，减少节点集合&lt;/li&gt;
&lt;li&gt;循环遍历选择的节点&lt;/li&gt;
&lt;li&gt;修改文档&lt;/li&gt;
&lt;li&gt;检测或获取节点属性值&lt;/li&gt;
&lt;li&gt;查询或显示一个节点的身份&lt;/li&gt;
&lt;li&gt;在文档树之间来回跳转（常用的查找节点方法）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;33213-基本用法&#34;&gt;3.3.2.1.3. 基本用法：&lt;/h5&gt;
&lt;p&gt;1、创建文档&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;d,e := goquery.NewDocumentFromReader(reader io.Reader)
d,e := goquery.NewDocument(url string)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、查找内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ele.Find(&amp;quot;#title&amp;quot;) //根据id查找
ele.Find(&amp;quot;.title&amp;quot;) //根据class查找
ele.Find(&amp;quot;h2&amp;quot;).Find(&amp;quot;a&amp;quot;) //链式调用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、获取内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ele.Html()
ele.Text()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、获取属性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ele.Attr(“href”)
ele.AttrOr(“href”, “”)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、遍历&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ele.Find(“.item”).Each(func(index int, ele *goquery.Selection){
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	doc, err := goquery.NewDocument(&amp;quot;http://studygolang.com/topics&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}

	doc.Find(&amp;quot;.topic&amp;quot;).Each(func(i int, contentSelection *goquery.Selection) {
		title := contentSelection.Find(&amp;quot;.title a&amp;quot;).Text()
        //Find(&amp;quot;.title a&amp;quot;)与Find(&amp;quot;.title&amp;quot;).Find(&amp;quot;a&amp;quot;)一样
		fmt.Println(&amp;quot;第&amp;quot;, i+1, &amp;quot;个帖子的标题：&amp;quot;, title)
		//ret,_ := contentSelection.Html()
		//fmt.Printf(&amp;quot;\n\n\n%v&amp;quot;, ret)
		//fmt.Println(contentSelection.Text())
	})
    //最终输出为 html 文档：
	//new, err := doc.Html()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中Find中的输入字符串是CSS selector，其语法风格参照 &lt;a href=&#34;http://www.w3school.com.cn/cssref/css_selectors.asp&#34;&gt;http://www.w3school.com.cn/cssref/css_selectors.asp&lt;/a&gt; 。如：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;语法&lt;/th&gt;
&lt;th&gt;表述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;#firstname&lt;/td&gt;
&lt;td&gt;选择 id=&amp;quot;firstname&amp;quot; 的所有元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;选择所有元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;选择所有 &lt;p&gt; 元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;div,p&lt;/td&gt;
&lt;td&gt;选择所有 &lt;div&gt; 元素和所有 &lt;p&gt; 元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;div p&lt;/td&gt;
&lt;td&gt;选择 &lt;div&gt; 元素内部的所有 &lt;p&gt; 元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;div&amp;gt;p&lt;/td&gt;
&lt;td&gt;选择父元素为 &lt;div&gt; 元素的所有 &lt;p&gt; 元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;div+p&lt;/td&gt;
&lt;td&gt;选择紧接在 &lt;div&gt; 元素之后的所有 &lt;p&gt; 元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[target]&lt;/td&gt;
&lt;td&gt;选择带有 target 属性所有元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[target=_blank]&lt;/td&gt;
&lt;td&gt;选择 target=&amp;quot;_blank&amp;quot; 的所有元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a[src*=”abc”]&lt;/td&gt;
&lt;td&gt;选择其 src 属性中包含 “abc” 子串的每个 &lt;a&gt; 元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a[src$=”.pdf”]&lt;/td&gt;
&lt;td&gt;选择其 src 属性以 “.pdf” 结尾的所有 &lt;a&gt; 元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;333-sourcegraphsyntaxhighlight包&#34;&gt;3.3.3 sourcegraph/syntaxhighlight包&lt;/h4&gt;
&lt;p&gt;syntaxhighlight包提供代码的语法高亮显示。 它目前使用独立于语言的词法分析器，并在JavaScript，Java，Ruby，Python，Go和C上表现出色。主要的AsHTML(src []byte) ([]byte, error)函数，输出就是HTML与google-code-prettify相同的CSS类，因此任何样式表也应该适用于此包。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
   src := []byte(`
/* hello, world! */
var a = 3;

// b is a cool function
function b() {
  return 7;
}`)
   highlighted, err := syntaxhighlight.AsHTML(src)
   if err != nil {
      fmt.Println(err)
      os.Exit(1)
   }
   fmt.Println(string(highlighted))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&amp;quot;com&amp;quot;&amp;gt;/* hello, world! */&amp;lt;/span&amp;gt;
&amp;lt;span class=&amp;quot;kwd&amp;quot;&amp;gt;var&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;pln&amp;quot;&amp;gt;a&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;pun&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;dec&amp;quot;&amp;gt;3&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;pun&amp;quot;&amp;gt;;&amp;lt;/span&amp;gt;
&amp;lt;span class=&amp;quot;com&amp;quot;&amp;gt;// b is a cool function&amp;lt;/span&amp;gt;
&amp;lt;span class=&amp;quot;kwd&amp;quot;&amp;gt;function&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;pln&amp;quot;&amp;gt;b&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;pun&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;pun&amp;quot;&amp;gt;)&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;pun&amp;quot;&amp;gt;{&amp;lt;/span&amp;gt;
  &amp;lt;span class=&amp;quot;kwd&amp;quot;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;dec&amp;quot;&amp;gt;7&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;pun&amp;quot;&amp;gt;;&amp;lt;/span&amp;gt;
&amp;lt;span class=&amp;quot;pun&amp;quot;&amp;gt;}&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过如下规则就行的转换&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var DefaultHTMLConfig = HTMLConfig{
	String:        &amp;quot;str&amp;quot;,
	Keyword:       &amp;quot;kwd&amp;quot;,
	Comment:       &amp;quot;com&amp;quot;,
	Type:          &amp;quot;typ&amp;quot;,
	Literal:       &amp;quot;lit&amp;quot;,
	Punctuation:   &amp;quot;pun&amp;quot;,
	Plaintext:     &amp;quot;pln&amp;quot;,
	Tag:           &amp;quot;tag&amp;quot;,
	HTMLTag:       &amp;quot;htm&amp;quot;,
	HTMLAttrName:  &amp;quot;atn&amp;quot;,
	HTMLAttrValue: &amp;quot;atv&amp;quot;,
	Decimal:       &amp;quot;dec&amp;quot;,
	Whitespace:    &amp;quot;&amp;quot;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;34-修改项目代码&#34;&gt;3.4 修改项目代码&lt;/h3&gt;
&lt;h4 id=&#34;341-导入样式&#34;&gt;3.4.1 导入样式&lt;/h4&gt;
&lt;p&gt;首先在show_article.html页面上导入样式包：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    ...
    &amp;lt;link href=&amp;quot;../static/css/lib/highlight.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;342-添加markdown语法转换方法&#34;&gt;3.4.2 添加Markdown语法转换方法&lt;/h4&gt;
&lt;p&gt;接下来在utils目录下，myUtils.go文件中添加方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func SwitchMarkdownToHtml(content string) template.HTML {
	markdown := blackfriday.MarkdownCommon([]byte(content))

	//获取到html文档
	doc, _ := goquery.NewDocumentFromReader(bytes.NewReader(markdown))
	/**
	对document进程查询，选择器和css的语法一样
	第一个参数：i是查询到的第几个元素
	第二个参数：selection就是查询到的元素
	 */
	doc.Find(&amp;quot;code&amp;quot;).Each(func(i int, selection *goquery.Selection) {
		light, _ := syntaxhighlight.AsHTML([]byte(selection.Text()))
		selection.SetHtml(string(light))
		fmt.Println(selection.Html())
		fmt.Println(&amp;quot;light:&amp;quot;, string(light))
		fmt.Println(&amp;quot;\n\n\n&amp;quot;)
	})
	htmlString, _ := doc.Html()
	return template.HTML(htmlString)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;343-修改控制器程序&#34;&gt;3.4.3 修改控制器程序&lt;/h4&gt;
&lt;p&gt;最后修改controller中的Get()方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (this *ShowArticleController) Get() {
	...
	this.Data[&amp;quot;Title&amp;quot;] = art.Title
	//this.Data[&amp;quot;Content&amp;quot;] = art.Content
	this.Data[&amp;quot;Content&amp;quot;] = utils.SwitchMarkdownToHtml(art.Content)
	this.TplName=&amp;quot;show_article.html&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;35-项目运行效果&#34;&gt;3.5 项目运行效果&lt;/h3&gt;
&lt;p&gt;重启项目后，然后刷新页面：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-143848@2x.png&#34; alt=&#34;支持Markdown语法效果&#34;&gt;
可以看到，效果就比较好看了，这就实现了我们对页面的美化效果。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E6%A1%86%E6%9E%B6/">框架</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>修改文章、删除文章和标签功能开发</title>
                <link>http://www.songx.fun/blog/day38-41beego%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/day40_%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0%E5%92%8C%E6%96%87%E7%AB%A0%E6%A0%87%E7%AD%BE%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day38-41beego%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/day40_%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0%E5%92%8C%E6%96%87%E7%AB%A0%E6%A0%87%E7%AD%BE%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;修改文章删除文章和标签功能开发&#34;&gt;修改文章、删除文章和标签功能开发&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;@author：Davie&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;版权所有：北京千锋互联科技有限公司&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上节课内容我们学习了查看文章详情的功能开发。本节课我们事先修改文章的功能。&lt;/p&gt;
&lt;h2 id=&#34;一-修改文章功能开发&#34;&gt;一 修改文章功能开发&lt;/h2&gt;
&lt;h3 id=&#34;11-添加修改文章功能路由&#34;&gt;1.1 添加修改文章功能路由&lt;/h3&gt;
&lt;p&gt;首先我们先添加一个路由：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func init() {
    ...
	//写文章
	beego.Router(&amp;quot;/article/add&amp;quot;, &amp;amp;controllers.AddArticleController{})
	//显示文章内容
	beego.Router(&amp;quot;/article/:id&amp;quot;, &amp;amp;controllers.ShowArticleController{})
	//更新文章
	beego.Router(&amp;quot;/article/update&amp;quot;, &amp;amp;controllers.UpdateArticleController{})
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-添加修改文章功能的控制器&#34;&gt;1.2 添加修改文章功能的控制器&lt;/h3&gt;
&lt;h4 id=&#34;121-定义修改文章控制器&#34;&gt;1.2.1 定义修改文章控制器&lt;/h4&gt;
&lt;p&gt;然后新创建一个Controller(update_article_controller.go)，用于控制更新操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type UpdateArticleController struct {
	BaseController
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;122-添加get方法&#34;&gt;1.2.2 添加get方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//当访问/update路径的时候回触发Get()方法，响应的页面是通过TplName这个属性指定返回给客户端的页面
func (this *UpdateArticleController) Get() {
	id, _ := this.GetInt(&amp;quot;id&amp;quot;)
	fmt.Println(id)
	//获取id所对应的文章信息
	art := models.QueryArticleWithId(id)
	this.Data[&amp;quot;Title&amp;quot;] = art.Title
	this.Data[&amp;quot;Tags&amp;quot;] = art.Tags
	this.Data[&amp;quot;Short&amp;quot;] = art.Short
	this.Data[&amp;quot;Content&amp;quot;] = art.Content
	this.Data[&amp;quot;Id&amp;quot;] = art.Id
	this.TplName = &amp;quot;write_article.html&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当点击修改按钮触发路由之后，通过get请求，进入Get()方法，其实还是现实写文章的页面，只不过里面已经填好了要修改的数据。
要想在页面上显示要修改的文章的数据，就需要根据id查询这篇文章，然后将数据传入到前端页面。
当用户点击提交按钮，触发post请求，进入Post()方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//修改文章
func (this *UpdateArticleController) Post() {
	id, _ := this.GetInt(&amp;quot;id&amp;quot;)
	fmt.Println(&amp;quot;postid:&amp;quot;, id)
	//获取浏览器传输的数据，通过表单的name属性获取值
	title := this.GetString(&amp;quot;title&amp;quot;)
	tags := this.GetString(&amp;quot;tags&amp;quot;)
	short := this.GetString(&amp;quot;short&amp;quot;)
	content := this.GetString(&amp;quot;content&amp;quot;)
	//实例化model，修改数据库
	art := models.Article{id, title, tags, short, content, &amp;quot;&amp;quot;, 0}
	_, err := models.UpdateArticle(art)
	//返回数据给浏览器
	if err == nil {
		this.Data[&amp;quot;json&amp;quot;] = map[string]interface{}{&amp;quot;code&amp;quot;: 1, &amp;quot;message&amp;quot;: &amp;quot;更新成功&amp;quot;}
	} else {
		this.Data[&amp;quot;json&amp;quot;] = map[string]interface{}{&amp;quot;code&amp;quot;: 0, &amp;quot;message&amp;quot;: &amp;quot;更新失败&amp;quot;}
	}
	this.ServeJSON()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-视图层views&#34;&gt;1.3 视图层（views）&lt;/h3&gt;
&lt;p&gt;修改文章和写文章，我们用同一个页面即可，只不过需要修改write_article.html页面的数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;写文章&amp;lt;/title&amp;gt;
    &amp;lt;link href=&amp;quot;../static/css/blogsheet.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/lib/jquery-3.3.1.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/lib/jquery.url.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;../static/js/blog.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

{{template &amp;quot;block/nav.html&amp;quot; .}}

&amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;
    &amp;lt;form id=&amp;quot;write-art-form&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
        &amp;lt;div&amp;gt;标题&amp;lt;/div&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; placeholder=&amp;quot;请输入标题&amp;quot; name=&amp;quot;title&amp;quot; value=&amp;quot;{{.Title}}&amp;quot;&amp;gt;
        &amp;lt;div&amp;gt;标签&amp;lt;/div&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; placeholder=&amp;quot;请输入标签&amp;quot; name=&amp;quot;tags&amp;quot; value=&amp;quot;{{.Tags}}&amp;quot;&amp;gt;
        &amp;lt;div&amp;gt;简介&amp;lt;/div&amp;gt;
        &amp;lt;textarea placeholder=&amp;quot;请输入简介&amp;quot; name=&amp;quot;short&amp;quot;&amp;gt;{{.Short}}&amp;lt;/textarea&amp;gt;
        &amp;lt;div&amp;gt;内容&amp;lt;/div&amp;gt;
        &amp;lt;textarea id=&amp;quot;content&amp;quot; placeholder=&amp;quot;请输入内容&amp;quot; name=&amp;quot;content&amp;quot;&amp;gt;{{.Content}}&amp;lt;/textarea&amp;gt;
        &amp;lt;input id=&amp;quot;write-article-id&amp;quot; hidden name=&amp;quot;id&amp;quot; value=&amp;quot;{{.Id}}&amp;quot;&amp;gt;
        &amp;lt;button type=&amp;quot;button&amp;quot; onclick=&amp;quot;history.back()&amp;quot;&amp;gt;返回&amp;lt;/button&amp;gt;
        &amp;lt;button type=&amp;quot;submit&amp;quot; id=&amp;quot;write-art-submit&amp;quot;&amp;gt;提交&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之前点击提交按钮，是为了添加文章。现在也有可能是修改文章。到底是修改还是添加，其实要看页面上id的值，如果是添加使用默认值0，如果是修改是从数据库中查询出的真实数值，所以需要修改js脚本文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;submitHandler: function (form) {
    alert(&amp;quot;hello&amp;quot;)
    var urlStr = &amp;quot;/article/add&amp;quot;;
    //判断文章id确定提交的表单的服务器地址
    //若id大于零，说明是修改文章
    var artId = $(&amp;quot;#write-article-id&amp;quot;).val();
    alert(&amp;quot;artId:&amp;quot; + artId);
    if (artId &amp;gt; 0) {
        urlStr = &amp;quot;/article/update&amp;quot;
    }
    alert(&amp;quot;urlStr:&amp;quot; + urlStr);
    $(form).ajaxSubmit({
        url: urlStr,
        type: &amp;quot;post&amp;quot;,
        dataType: &amp;quot;json&amp;quot;,
        success: function (data, status) {
            alert(&amp;quot;:data:&amp;quot; + data.message);
            setTimeout(function () {
                window.location.href = &amp;quot;/&amp;quot;
            }, 1000)
        },
        error: function (data, status) {
            alert(&amp;quot;err:&amp;quot; + data.message + &amp;quot;:&amp;quot; + status)
        }
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14-model层添加修改数据方法&#34;&gt;1.4 model层添加修改数据方法&lt;/h3&gt;
&lt;p&gt;然后我们就可以去修改数据库了，在article_model.go文件中，添加方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//----------修改数据----------
func UpdateArticle(article Article) (int64, error) {
	//数据库操作
	return utils.ModifyDB(&amp;quot;update article set title=?,tags=?,short=?,content=? where id=?&amp;quot;,
		article.Title, article.Tags, article.Short, article.Content, article.Id)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;15-项目运行&#34;&gt;1.5 项目运行&lt;/h3&gt;
&lt;p&gt;重启项目后，我们打来浏览器输入网址：&lt;a href=&#34;http://127.0.0.1:8080/&#34;&gt;http://127.0.0.1:8080/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-155033@2x.png&#34; alt=&#34;项目运行&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们就修改第一篇文章：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-155245@2x.png&#34; alt=&#34;修改文章&#34;&gt;&lt;/p&gt;
&lt;p&gt;提交修改效果：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-155431@2x.png&#34; alt=&#34;查看修改效果&#34;&gt;&lt;/p&gt;
&lt;p&gt;也可以查询数据库，也已经更新完毕：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-155627@2x.png&#34; alt=&#34;数据库修改&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;二-删除文章功能开发&#34;&gt;二 删除文章功能开发&lt;/h2&gt;
&lt;p&gt;当用户登录后，是可以有删除功能的，点击删除，就可以删除一篇文章。删除文章功能不需要view页面，直接弹框确认即可，现在我们来实现model和controller部分。&lt;/p&gt;
&lt;h3 id=&#34;21-model添加删除方法&#34;&gt;2.1 model添加删除方法&lt;/h3&gt;
&lt;p&gt;在article_model.go文件中，添加 删除文章的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//----------删除文章---------
func DeleteArticle(artID int) (int64, error) {
	i, err := deleteArticleWithArtId(artID)
	SetArticleRowsNum()
	return i, err
}
func deleteArticleWithArtId(artID int) (int64, error) {
	return utils.ModifyDB(&amp;quot;delete from article where id=?&amp;quot;, artID)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除的时候，肯定是根据文章的ID来删除，当点击删除按钮的时候，可以传过来文章ID。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{if .IsLogin}}
    &amp;lt;div class=&amp;quot;home-block-item-udpate&amp;quot;&amp;gt;
        &amp;lt;a href=&#39;javascript:if(confirm(&amp;quot;确定删除吗？&amp;quot;)){location=&amp;quot;{{.DeleteLink}}}&amp;quot;}&#39;&amp;gt;删除&amp;lt;/a&amp;gt;
        &amp;lt;a href={{.UpdateLink}}&amp;gt;修改&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
{{end}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22-添加删除文章控制器&#34;&gt;2.2 添加删除文章控制器&lt;/h3&gt;
&lt;p&gt;接下来，我们实现controller部分，在controllers目录下，创建一个新的go文件：delete_article_controller.go&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package controllers
import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;myblogweb/models&amp;quot;
	&amp;quot;log&amp;quot;
)

type DeleteArticleController struct {
	BaseController
}
//点击删除后重定向到首页
func (this *DeleteArticleController) Get() {
	artID, _ := this.GetInt(&amp;quot;id&amp;quot;)
	fmt.Println(&amp;quot;删除 id:&amp;quot;, artID)
	_, err := models.DeleteArticle(artID)
	if err != nil {
		log.Println(err)
	}
	this.Redirect(&amp;quot;/&amp;quot;, 302)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先接收要删除的文章ID，然后操作sql语句进行删除数据，自后重定向到首页上。&lt;/p&gt;
&lt;h3 id=&#34;23-添加删除文章路由&#34;&gt;2.3 添加删除文章路由&lt;/h3&gt;
&lt;p&gt;接下来注册个新的路由：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 删除文章
beego.Router(&amp;quot;/article/delete&amp;quot;, &amp;amp;controllers.DeleteArticleController{})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;24-项目运行&#34;&gt;2.4 项目运行&lt;/h3&gt;
&lt;p&gt;重启项目后，打开浏览器输入：&lt;a href=&#34;http://127.0.0.1:8080/&#34;&gt;http://127.0.0.1:8080/&lt;/a&gt;，并且要登录，才能有删除功能。
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-161409@2x.png&#34; alt=&#34;删除提示&#34;&gt;
我们删除第一篇文章，点击删除按钮。然后弹出确认框，选择确定。就会删除第一篇文章。然后跳转到首页。
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-161420@2x.png&#34; alt=&#34;刷新首页&#34;&gt;
我们发现首页已经没有第一篇文章了，此时也可以查询一下数据库：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-161457@2x.png&#34; alt=&#34;数据库验证&#34;&gt;
我们发现数据库中id为1的文章已经被删除。&lt;/p&gt;
&lt;h2 id=&#34;三-标签功能开发&#34;&gt;三 标签功能开发&lt;/h2&gt;
&lt;p&gt;上节课内容我们实现了删除文章的操作，本节课我们继续进行相关功能开发。当我们点击标签按钮的时候，应该要显示每个标签对应了多少篇文章。&lt;/p&gt;
&lt;h3 id=&#34;31-model层&#34;&gt;3.1 model层&lt;/h3&gt;
&lt;h4 id=&#34;311-article_model添加查询方法&#34;&gt;3.1.1 article_model添加查询方法&lt;/h4&gt;
&lt;p&gt;当点击标签的时候，需要查询出数据库中所有的标签，然后再统计出每个标签的文章总量，显示到前端页面上。&lt;/p&gt;
&lt;p&gt;所以我们应该先查询出数据库中所有的标签。
在article_model.go文件中，加入以下代码，先查询出所有的标签。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//查询标签，返回一个字段的列表
func QueryArticleWithParam(param string) []string {
	rows, err := utils.QueryDB(fmt.Sprintf(&amp;quot;select %s from article&amp;quot;, param))
	if err != nil {
		log.Println(err)
	}
	var paramList []string
	for rows.Next() {
		arg := &amp;quot;&amp;quot;
		rows.Scan(&amp;amp;arg)
		paramList = append(paramList, arg)
	}
	return paramList
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;312-新增model结构体定义&#34;&gt;3.1.2 新增model结构体定义&lt;/h4&gt;
&lt;p&gt;然后再models目录下，创建一个新的model文件：tags_model.go&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package models
import &amp;quot;strings&amp;quot;
func HandleTagsListData(tags []string) map[string]int {
	var tagsMap = make(map[string]int)
	for _, tag := range tags {
		tagList := strings.Split(tag, &amp;quot;&amp;amp;&amp;quot;)
		for _, value := range tagList {
			tagsMap[value]++
		}
	}
	return tagsMap
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32-添加控制器层&#34;&gt;3.2 添加控制器层&lt;/h3&gt;
&lt;p&gt;接下来，我们在controllers目录下新建一个controller的go文件，tags_controller.go。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package controllers

import (
	&amp;quot;myblogweb/models&amp;quot;
	&amp;quot;fmt&amp;quot;
)
type TagsController struct {
	BaseController
}
func (this *TagsController) Get() {
	tags := models.QueryArticleWithParam(&amp;quot;tags&amp;quot;)
	fmt.Println(models.HandleTagsListData(tags))
	this.Data[&amp;quot;Tags&amp;quot;] = models.HandleTagsListData(tags)
	this.TplName = &amp;quot;tags.html&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;33-添加标签功能路由&#34;&gt;3.3 添加标签功能路由&lt;/h3&gt;
&lt;p&gt;并且在router.go中注册新的路由：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//标签
beego.Router(&amp;quot;/tags&amp;quot;, &amp;amp;controllers.TagsController{})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;34-添加视图层文件&#34;&gt;3.4 添加视图层文件&lt;/h3&gt;
&lt;p&gt;最后我们去写前端页面，来接收数据。在views包下，新建一个html文件，tags.html：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;标签&amp;lt;/title&amp;gt;
    &amp;lt;link href=&amp;quot;../static/css/blogsheet.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
{{template &amp;quot;block/nav.html&amp;quot; .}}
&amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;
    &amp;lt;h1&amp;gt;标签&amp;lt;/h1&amp;gt;
    &amp;lt;div id=&amp;quot;tags-list&amp;quot;&amp;gt;
    {{range $k,$v := .Tags}}
        &amp;lt;div&amp;gt;&amp;lt;a href=&amp;quot;/?tag={{$k}}&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;global-color&amp;quot;&amp;gt;{{$k}}&amp;lt;/span&amp;gt; 有{{$v}}篇文章&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;{{end}}
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;35-项目运行&#34;&gt;3.5 项目运行&lt;/h3&gt;
&lt;p&gt;重新启动项目后，在浏览器中点击标签按钮：
&lt;img src=&#34;http://www.songx.fun/img/png/WX20190522-165548@2x.png&#34; alt=&#34;项目运行&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E6%A1%86%E6%9E%B6/">框架</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%B7%A5%E5%85%B7/">工具</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>循环语句</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day05_%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day05_%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;一程序的流程结构&#34;&gt;一、程序的流程结构&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序的流程控制结构一共有三种：顺序结构，选择结构，循环结构。&lt;/p&gt;
&lt;p&gt;顺序结构：代码从上向下逐行的执行&lt;/p&gt;
&lt;p&gt;选择结构：条件满足，某些代码才会被执行。0-1次&lt;/p&gt;
&lt;p&gt;​	if语句，switch语句&lt;/p&gt;
&lt;p&gt;循环结构：条件满足，某些代码会被反复的多次执行。0-n次&lt;/p&gt;
&lt;p&gt;​	for语句&lt;/p&gt;
&lt;h1 id=&#34;二循环语句&#34;&gt;二、循环语句&lt;/h1&gt;
&lt;p&gt;循环语句表示条件满足，可以反复的执行某段代码。&lt;/p&gt;
&lt;p&gt;for是唯一的循环语句。(Go没有while循环)&lt;/p&gt;
&lt;p&gt;##2.1 for语句&lt;/p&gt;
&lt;p&gt;语法结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for init; condition; post { }
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;初始化语句只执行一次。在初始化循环之后，将检查该条件。如果条件计算为true，那么{}中的循环体将被执行，然后是post语句。post语句将在循环的每次成功迭代之后执行。在执行post语句之后，该条件将被重新检查。如果它是正确的，循环将继续执行，否则循环终止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    for i := 1; i &amp;lt;= 10; i++ {
        fmt.Printf(&amp;quot; %d&amp;quot;,i)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在for循环中声明的变量仅在循环范围内可用。因此，i不能在外部访问循环。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;22-for循环变体&#34;&gt;2.2 for循环变体&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;所有的三个组成部分，即初始化、条件和post都是可选的。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for condition { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果与while相似&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果与for(;;) 一样&lt;/p&gt;
&lt;p&gt;for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for key, value := range oldMap {
    newMap[key] = value
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {

   var b int = 15
   var a int

   numbers := [6]int{1, 2, 3, 5} 

   /* for 循环 */
   for a := 0; a &amp;lt; 10; a++ {
      fmt.Printf(&amp;quot;a 的值为: %d\n&amp;quot;, a)
   }

   for a &amp;lt; b {
      a++
      fmt.Printf(&amp;quot;a 的值为: %d\n&amp;quot;, a)
      }

   for i,x:= range numbers {
      fmt.Printf(&amp;quot;第 %d 位 x 的值 = %d\n&amp;quot;, i,x)
   }   
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a 的值为: 0
a 的值为: 1
a 的值为: 2
a 的值为: 3
a 的值为: 4
a 的值为: 5
a 的值为: 6
a 的值为: 7
a 的值为: 8
a 的值为: 9
a 的值为: 1
a 的值为: 2
a 的值为: 3
a 的值为: 4
a 的值为: 5
a 的值为: 6
a 的值为: 7
a 的值为: 8
a 的值为: 9
a 的值为: 10
a 的值为: 11
a 的值为: 12
a 的值为: 13
a 的值为: 14
a 的值为: 15
第 0 位 x 的值 = 1
第 1 位 x 的值 = 2
第 2 位 x 的值 = 3
第 3 位 x 的值 = 5
第 4 位 x 的值 = 0
第 5 位 x 的值 = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22-多层for循环&#34;&gt;2.2 多层for循环&lt;/h2&gt;
&lt;p&gt;for循环中又有循环嵌套，就表示多层循环了。&lt;/p&gt;
&lt;h1 id=&#34;三跳出循环的语句&#34;&gt;三、跳出循环的语句&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-break语句&#34;&gt;1、 break语句&lt;/h2&gt;
&lt;p&gt;break：跳出循环体。break语句用于在结束其正常执行之前突然终止for循环&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    for i := 1; i &amp;lt;= 10; i++ {
        if i &amp;gt; 5 {
            break //loop is terminated if i &amp;gt; 5
        }
        fmt.Printf(&amp;quot;%d &amp;quot;, i)
    }
    fmt.Printf(&amp;quot;\nline after for loop&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2continue语句&#34;&gt;2、continue语句&lt;/h2&gt;
&lt;p&gt;continue：跳出一次循环。continue语句用于跳过for循环的当前迭代。在continue语句后面的for循环中的所有代码将不会在当前迭代中执行。循环将继续到下一个迭代。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    for i := 1; i &amp;lt;= 10; i++ {
        if i%2 == 0 {
            continue
        }
        fmt.Printf(&amp;quot;%d &amp;quot;, i)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四goto语句&#34;&gt;四、goto语句&lt;/h1&gt;
&lt;p&gt;goto：可以无条件地转移到过程中指定的行。&lt;/p&gt;
&lt;p&gt;语法结构：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;goto label;
..
..
label: statement;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/goto1.jpg&#34; alt=&#34;goto1&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   /* 定义局部变量 */
   var a int = 10

   /* 循环 */
   LOOP: for a &amp;lt; 20 {
      if a == 15 {
         /* 跳过迭代 */
         a = a + 1
         goto LOOP
      }
      fmt.Printf(&amp;quot;a的值为 : %d\n&amp;quot;, a)
      a++     
   }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;统一错误处理
多处错误处理存在代码重复时是非常棘手的，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;		err := firstCheckError()
    if err != nil {
        goto onExit
    }
    err = secondCheckError()
    if err != nil {
        goto onExit
    }
    fmt.Println(&amp;quot;done&amp;quot;)
    return
onExit:
    fmt.Println(err)
    exitProcess()



&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本文图片来源于网络&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>知名编程语言或系统的发展简史</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC1%E8%8A%82_%E7%9F%A5%E5%90%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%88%96%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day01_%E7%AC%AC1%E8%8A%82_%E7%9F%A5%E5%90%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%88%96%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;知名编程语言或系统的发展简史&#34;&gt;知名编程语言或系统的发展简史&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹
版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一b语言&#34;&gt;一、B语言&lt;/h2&gt;
&lt;p&gt;B语言之父：Ken Thompson（肯.汤普森）。B语言是贝尔实验室开发的一种通用的程序设计语言，它是于1969年前后Ken Thompson（肯.汤普森）在Dennis Ritchie丹尼斯.里奇（Dennis Ritchie）的支持下设计出来。该语言得名于汤姆森的妻子Bonnie，它是一门开发于60年代中期的语言，现在使用者已经很少了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/KenThompson.jpg&#34; alt=&#34;Ken Thompson&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;二c语言&#34;&gt;二、C语言&lt;/h2&gt;
&lt;p&gt;C语言之父：Dennis Ritchie（丹尼斯·里奇）。美国著名计算机专家、C语言发明人、UNIX之父。在1969-1973年期间发明了C语言和Unix操作系统。&lt;/p&gt;
&lt;p&gt;到了70年代，诞生了一门非常重要的语言，这就是今天的大名鼎鼎的C语言。而C语言之父是美国著名的计算机专家。丹尼斯.利奇。
在开发C语言的时候其实是以B语言为基础。之所以发明C语言，实际上是因为这两个人，刚刚的B语言之父肯.汤普森和丹尼斯.里奇，一块写了一个操作系统，就是Unix系统。在写Unix系统的过程中，需要一种便利的语言，而B语言又达不到这个要求，所以丹尼斯.里奇就在B语言上进行改造，发明了C语言。目前 C语言是世界上最常用的程序语言之一。自从被C语言取代之后，B语言几乎已遭弃置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/dannis.jpg&#34; alt=&#34;dannis&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;三unix系统&#34;&gt;三、Unix系统&lt;/h2&gt;
&lt;p&gt;Unix之父：Dennis Ritchie（丹尼斯·里奇）及Ken Thompson（肯.汤普森）&lt;/p&gt;
&lt;p&gt;提到C语言就不得不说一下Unix系统。而Unix之父，自然就是这两个人，左侧这个是B语言之父肯汤姆森。右侧这个是C语言之父丹尼斯.里奇。有意思的是，肯.汤普森当年开发 Unix的初衷是运行他编写的一款计算机游戏 Space Travel，这款游戏模拟太阳系天体运动，由玩家驾驶飞船，观赏景色并尝试在各种行星和月亮上登陆。他先后在多个系统上试验，但运行效果不甚理想，于是决定自己开发操作系统，就这样，Unix 诞生了。英文中的前缀 Uni 是小的意思，小而且巧。这是 Unix 的设计初衷，这个理念也一直影响至今。
因为他们俩在1973年左右的时候发明了Unix操作系统，也因此获得了1983年的图灵大奖。这个奖项就相当于IT行业的诺贝尔奖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/WX20190322-173439.png&#34; alt=&#34;WX20190322-173439&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;四c语言&#34;&gt;四、C++语言&lt;/h2&gt;
&lt;p&gt;C++之父：Bjarne Stroustrup（本贾尼·斯特劳斯特卢普）。1982年，美国贝尔实验室的Bjarne Stroustrup博士在C语言的基础上引入并扩充了面向对象的概念，发明了—种新的程序语言。为了表达该语言与c语言的渊源关系，它被命名为C++。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/BjarneStroustrup.jpg&#34; alt=&#34;Bjarne Stroustrup&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;五python语言&#34;&gt;五、Python语言&lt;/h2&gt;
&lt;p&gt;Python之父：Guido van Rossum（吉多.范.罗苏姆）。1989年，为了打发圣诞节假期，Guido开始写Python语言的编译/解释器。1994年发布1.0版本。1995年9月发布了Python3.5版。&lt;/p&gt;
&lt;p&gt;python语言的理念就是：人生苦短，我用python。吉多推崇的是简洁，大方，美观，精致。吉多一直认为python是一门很优秀的语言，实际上python也确实是可以做各个行业，无论是web开发，还是服务器端维护，还有爬虫等等，但是在每个方向上都没有做到最精，所以在某些地方没有得到很大的体现。但是吉多一直认为酒香不怕巷子深，所以也没有大力的宣传。但是近几年随着人工智能也被大众所熟知。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/GuidovanRossum.png&#34; alt=&#34;Guido van Rossum&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;六java语言&#34;&gt;六、Java语言&lt;/h2&gt;
&lt;p&gt;Java之父是James Gosling（詹姆斯.高斯林）。1991年开发Oak，1994年更名为Java。1995年5月正式发布。&lt;/p&gt;
&lt;p&gt;实际上python比java的产生还要更早一点。java的出现，正是互联网大力兴起的时候，而java因为语言的特性，在互联网上有很大的优势，发布最初就异常火爆，掩盖住了python的势头。java最初的模型是在1991年的时候开发出，他的创始人詹姆斯高斯林。那个时候还叫做Oak橡树，后来詹姆斯希望使用java语言可以像喝咖啡一样轻松，愉悦。改名为java。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/JamesGosling.jpg&#34; alt=&#34;James Gosling&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;七javascript语言&#34;&gt;七、JavaScript语言&lt;/h2&gt;
&lt;p&gt;Javascript之父是Brendan Eich（布兰登.艾奇)。JavaScript，是一门运行在浏览器端的脚本语言。这门语言是由网景公司在1995年发布的。当时网景公司主要是做浏览器方面，他们想把java语言应用在浏览器端，能够实现一些比如用户登录并验证的工作。招聘了一个新员工，叫做布兰登.艾奇，布兰登对java没有兴趣，为了应付公司的任务，只用了10天时间就设计出了JavaScript这门语言。但是JavaScript发展至今，随着前端开发异常的火爆，它已经是浏览器端的龙头语言了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/BrendanEich.jpg&#34; alt=&#34;Brendan Eich&#34;&gt;&lt;/p&gt;
&lt;p&gt;8、Golang：Go的三个作者分别是： Rob Pike（罗伯.派克），Ken Thompson（肯.汤普森）和Robert Griesemer（罗伯特.格利茨默）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/aa.jpg&#34; alt=&#34;aa&#34;&gt;&lt;/p&gt;
&lt;p&gt;本文所有图片来自网络，侵删&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934/&#34;&gt;https://www.bilibili.com/video/av56018934/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>指针</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day12_%E6%8C%87%E9%92%88/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day12_%E6%8C%87%E9%92%88/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;一指针&#34;&gt;一、指针&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;11-指针的概念&#34;&gt;1.1 指针的概念&lt;/h2&gt;
&lt;p&gt;指针是存储另一个变量的内存地址的变量。&lt;/p&gt;
&lt;p&gt;我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。&lt;/p&gt;
&lt;p&gt;一个指针变量可以指向任何一个值的内存地址它指向那个值的内存地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.songx.fun/img/png/pointer1.png&#34; alt=&#34;pointer1&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上面的图中，变量b的值为156，存储在内存地址0x1040a124。变量a持有b的地址，现在a被认为指向b。&lt;/p&gt;
&lt;h2 id=&#34;12-获取变量的地址&#34;&gt;1.2 获取变量的地址&lt;/h2&gt;
&lt;p&gt;Go 语言的取地址符是 &amp;amp;，放到一个变量前使用就会返回相应变量的内存地址。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   var a int = 10   

   fmt.Printf(&amp;quot;变量的地址: %x\n&amp;quot;, &amp;amp;a  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;变量的地址: 20818a220
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13-声明指针&#34;&gt;1.3 声明指针&lt;/h2&gt;
&lt;p&gt;声明指针，*T是指针变量的类型，它指向T类型的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var var_name *var-type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var ip *int        /* 指向整型*/
var fp *float32    /* 指向浮点型 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   var a int= 20   /* 声明实际变量 */
   var ip *int        /* 声明指针变量 */

   ip = &amp;amp;a  /* 指针变量的存储地址 */

   fmt.Printf(&amp;quot;a 变量的地址是: %x\n&amp;quot;, &amp;amp;a  )

   /* 指针变量的存储地址 */
   fmt.Printf(&amp;quot;ip 变量的存储地址: %x\n&amp;quot;, ip )

   /* 使用指针访问值 */
   fmt.Printf(&amp;quot;*ip 变量的值: %d\n&amp;quot;, *ip )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a 变量的地址是: 20818a220
ip 变量的存储地址: 20818a220
*ip 变量的值: 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type name int8
type first struct {
	a int
	b bool
	name
}

func main() {
	a := new(first)
	a.a = 1
	a.name = 11
	fmt.Println(a.b, a.a, a.name)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;false 1 11
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;未初始化的变量自动赋上初始值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type name int8
type first struct {
	a int
	b bool
	name
}

func main() {
	var a = first{1, false, 2}
	var b *first = &amp;amp;a
	fmt.Println(a.b, a.a, a.name, &amp;amp;a, b.a, &amp;amp;b, (*b).a)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;false 1 2 &amp;amp;{1 false 2} 1 0xc042068018 1
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;获取指针地址在指针变量前加&amp;amp;的方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;14-空指针&#34;&gt;1.4 空指针&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Go 空指针&lt;/strong&gt;
当一个指针被定义后没有分配到任何变量时，它的值为 nil。
nil 指针也称为空指针。
nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。
一个指针变量通常缩写为 ptr。&lt;/p&gt;
&lt;p&gt;空指针判断：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if(ptr != nil)     /* ptr 不是空指针 */
if(ptr == nil)    /* ptr 是空指针 */
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;15-获取指针的值&#34;&gt;1.5 获取指针的值&lt;/h2&gt;
&lt;p&gt;获取一个指针意味着访问指针指向的变量的值。语法是：*a&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main  
import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    b := 255
    a := &amp;amp;b
    fmt.Println(&amp;quot;address of b is&amp;quot;, a)
    fmt.Println(&amp;quot;value of b is&amp;quot;, *a)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;16-操作指针改变变量的数值&#34;&gt;1.6 操作指针改变变量的数值&lt;/h2&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    b := 255
    a := &amp;amp;b
    fmt.Println(&amp;quot;address of b is&amp;quot;, a)
    fmt.Println(&amp;quot;value of b is&amp;quot;, *a)
    *a++
    fmt.Println(&amp;quot;new value of b is&amp;quot;, b)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;address of b is 0x1040a124  
value of b is 255  
new value of b is 256  
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;17-使用指针传递函数的参数&#34;&gt;1.7 使用指针传递函数的参数&lt;/h2&gt;
&lt;p&gt;示例代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func change(val *int) {  
    *val = 55
}
func main() {  
    a := 58
    fmt.Println(&amp;quot;value of a before function call is&amp;quot;,a)
    b := &amp;amp;a
    change(b)
    fmt.Println(&amp;quot;value of a after function call is&amp;quot;, a)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;value of a before function call is 58  
value of a after function call is 55  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;不要将一个指向数组的指针传递给函数。使用切片。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们想对函数内的数组进行一些修改，并且对调用者可以看到函数内的数组所做的更改。一种方法是将一个指向数组的指针传递给函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func modify(arr *[3]int) {  
    (*arr)[0] = 90
}

func main() {  
    a := [3]int{89, 90, 91}
    modify(&amp;amp;a)
    fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[90 90 91]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func modify(arr *[3]int) {  
    arr[0] = 90
}

func main() {  
    a := [3]int{89, 90, 91}
    modify(&amp;amp;a)
    fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[90 90 91]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;虽然将指针传递给一个数组作为函数的参数并对其进行修改，但这并不是实现这一目标的惯用方法。我们有切片。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func modify(sls []int) {  
    sls[0] = 90
}

func main() {  
    a := [3]int{89, 90, 91}
    modify(a[:])
    fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[90 90 91]
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Go不支持指针算法。&lt;/p&gt;
&lt;p&gt;package main&lt;/p&gt;
&lt;p&gt;func main() {&lt;br&gt;
b := [...]int{109, 110, 111}
p := &amp;amp;b
p++
}&lt;/p&gt;
&lt;p&gt;nvalid operation: p++ (non-numeric type *[3]int)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;指针数组&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

const MAX int = 3

func main() {

   a := []int{10,100,200}
   var i int

   for i = 0; i &amp;lt; MAX; i++ {
      fmt.Printf(&amp;quot;a[%d] = %d\n&amp;quot;, i, a[i] )
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;结果&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a[0] = 10
a[1] = 100
a[2] = 200
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有一种情况，我们可能需要保存数组，这样我们就需要使用到指针。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

const MAX int = 3

func main() {
   a := []int{10,100,200}
   var i int
   var ptr [MAX]*int;

   for  i = 0; i &amp;lt; MAX; i++ {
      ptr[i] = &amp;amp;a[i] /* 整数地址赋值给指针数组 */
   }

   for  i = 0; i &amp;lt; MAX; i++ {
      fmt.Printf(&amp;quot;a[%d] = %d\n&amp;quot;, i,*ptr[i] )
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;结果&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a[0] = 10
a[1] = 100
a[2] = 200
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;18-指针的指针&#34;&gt;1.8 指针的指针&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;指针的指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var ptr **int;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {

   var a int
   var ptr *int
   var pptr **int

   a = 3000

   /* 指针 ptr 地址 */
   ptr = &amp;amp;a

   /* 指向指针 ptr 地址 */
   pptr = &amp;amp;ptr

   /* 获取 pptr 的值 */
   fmt.Printf(&amp;quot;变量 a = %d\n&amp;quot;, a )
   fmt.Printf(&amp;quot;指针变量 *ptr = %d\n&amp;quot;, *ptr )
   fmt.Printf(&amp;quot;指向指针的指针变量 **pptr = %d\n&amp;quot;, **pptr)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;结果&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;变量 a = 3000
指针变量 *ptr = 3000
指向指针的指针变量 **pptr = 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;指针作为函数参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int= 200

   fmt.Printf(&amp;quot;交换前 a 的值 : %d\n&amp;quot;, a )
   fmt.Printf(&amp;quot;交换前 b 的值 : %d\n&amp;quot;, b )

   /* 调用函数用于交换值
   * &amp;amp;a 指向 a 变量的地址
   * &amp;amp;b 指向 b 变量的地址
   */
   swap(&amp;amp;a, &amp;amp;b);

   fmt.Printf(&amp;quot;交换后 a 的值 : %d\n&amp;quot;, a )
   fmt.Printf(&amp;quot;交换后 b 的值 : %d\n&amp;quot;, b )
}

func swap(x *int, y *int) {
   var temp int
   temp = *x    /* 保存 x 地址的值 */
   *x = *y      /* 将 y 赋值给 x */
   *y = temp    /* 将 temp 赋值给 y */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;结果&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;交换前 a 的值 : 100
交换前 b 的值 : 200
交换后 a 的值 : 200
交换后 b 的值 : 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_advanced&#34;&gt;https://github.com/rubyhan1314/go_advanced&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>字符串(string)</title>
                <link>http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day09_string/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day01-15go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/day09_string/</guid>
                <pubDate>Mon, 01 Aug 2022 21:29:20 &#43;0200</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;一字符串string&#34;&gt;一、字符串(string)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;@author：韩茹&lt;/p&gt;
&lt;p&gt;版权所有：北京千锋互联科技有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;11-什么是string&#34;&gt;1.1 什么是string&lt;/h2&gt;
&lt;p&gt;Go中的字符串是一个字节的切片。可以通过将其内容封装在“”中来创建字符串。Go中的字符串是Unicode兼容的，并且是UTF-8编码的。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    name := &amp;quot;Hello World&amp;quot;
    fmt.Println(name)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12--string的使用&#34;&gt;1.2  string的使用&lt;/h2&gt;
&lt;h3 id=&#34;121-访问字符串中的单个字节&#34;&gt;1.2.1 访问字符串中的单个字节&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    name := &amp;quot;Hello World&amp;quot;
    for i:= 0; i &amp;lt; len(s); i++ {
        fmt.Printf(&amp;quot;%d &amp;quot;, s[i])
    }
    fmt.Printf(&amp;quot;\n&amp;quot;)
    for i:= 0; i &amp;lt; len(s); i++ {
        fmt.Printf(&amp;quot;%c &amp;quot;,s[i])
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;72 101 108 108 111 32 87 111 114 108 100
H e l l o   W o r l d&lt;/p&gt;
&lt;h2 id=&#34;13-strings包&#34;&gt;1.3 strings包&lt;/h2&gt;
&lt;p&gt;访问strings包，可以有很多操作string的函数。&lt;/p&gt;
&lt;h2 id=&#34;14-strconv包&#34;&gt;1.4 strconv包&lt;/h2&gt;
&lt;p&gt;访问strconv包，可以实现string和其他数值类型之间的转换。&lt;/p&gt;
&lt;p&gt;千锋Go语言的学习群：784190273&lt;/p&gt;
&lt;p&gt;作者B站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/353694001&#34;&gt;https://space.bilibili.com/353694001&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av56018934&#34;&gt;https://www.bilibili.com/video/av56018934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av47467197&#34;&gt;https://www.bilibili.com/video/av47467197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rubyhan1314/go_foundation&#34;&gt;https://github.com/rubyhan1314/go_foundation&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/golang/">golang</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%AE%80%E5%8F%B2/">简史</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E7%BC%96%E7%A8%8B/">编程</category>
                                
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/categories/%E5%9F%BA%E7%A1%80/">基础</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="http://www.songx.fun/tags/golang/">golang</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>http://www.songx.fun/blog/day38-41beego%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/code/day39_3%E9%A1%B9%E7%9B%AE%E8%AF%A6%E6%83%85%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/goquerydemo/test/</link>
                <guid isPermaLink="true">http://www.songx.fun/blog/day38-41beego%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/code/day39_3%E9%A1%B9%E7%9B%AE%E8%AF%A6%E6%83%85%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/goquerydemo/test/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>245935836@163.com (songx)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;一russrossblackfriday包&#34;&gt;一、russross/blackfriday包&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;千锋教育&lt;/li&gt;
&lt;li&gt;Go语言开发&lt;/li&gt;
&lt;li&gt;HTMl开发&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
    </channel>
</rss>
